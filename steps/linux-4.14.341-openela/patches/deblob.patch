SPDX-FileCopyrightText: 2024 GÃ¡bor Stefanik <netrolller.3d@gmail.com>

SPDX-License-Identifier: GPL-2.0-only

Remove drivers containing embedded blobs

diff -ruN ../linux-4.14.336/Documentation/networking/cops.txt ./Documentation/networking/cops.txt
--- linux-4.14.336/../linux-4.14.336/Documentation/networking/cops.txt	2024-01-10 14:45:41.000000000 +0100
+++ linux-4.14.336/./Documentation/networking/cops.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,63 +0,0 @@
-Text File for the COPS LocalTalk Linux driver (cops.c).
-	By Jay Schulist <jschlst@samba.org>
-
-This driver has two modes and they are: Dayna mode and Tangent mode.
-Each mode corresponds with the type of card. It has been found
-that there are 2 main types of cards and all other cards are
-the same and just have different names or only have minor differences
-such as more IO ports. As this driver is tested it will
-become more clear exactly what cards are supported. 
-
-Right now these cards are known to work with the COPS driver. The
-LT-200 cards work in a somewhat more limited capacity than the
-DL200 cards, which work very well and are in use by many people.
-
-TANGENT driver mode:
-	Tangent ATB-II, Novell NL-1000, Daystar Digital LT-200
-DAYNA driver mode:
-	Dayna DL2000/DaynaTalk PC (Half Length), COPS LT-95,
-	Farallon PhoneNET PC III, Farallon PhoneNET PC II
-Other cards possibly supported mode unknown though:
-	Dayna DL2000 (Full length)
-
-The COPS driver defaults to using Dayna mode. To change the driver's 
-mode if you built a driver with dual support use board_type=1 or
-board_type=2 for Dayna or Tangent with insmod.
-
-** Operation/loading of the driver.
-Use modprobe like this:	/sbin/modprobe cops.o (IO #) (IRQ #)
-If you do not specify any options the driver will try and use the IO = 0x240,
-IRQ = 5. As of right now I would only use IRQ 5 for the card, if autoprobing.
-
-To load multiple COPS driver Localtalk cards you can do one of the following.
-
-insmod cops io=0x240 irq=5
-insmod -o cops2 cops io=0x260 irq=3
-
-Or in lilo.conf put something like this:
-	append="ether=5,0x240,lt0 ether=3,0x260,lt1"
-
-Then bring up the interface with ifconfig. It will look something like this:
-lt0       Link encap:UNSPEC  HWaddr 00-00-00-00-00-00-00-F7-00-00-00-00-00-00-00-00
-          inet addr:192.168.1.2  Bcast:192.168.1.255  Mask:255.255.255.0
-          UP BROADCAST RUNNING NOARP MULTICAST  MTU:600  Metric:1
-          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
-          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 coll:0
-
-** Netatalk Configuration
-You will need to configure atalkd with something like the following to make
-it work with the cops.c driver.
-
-* For single LTalk card use.
-dummy -seed -phase 2 -net 2000 -addr 2000.10 -zone "1033"
-lt0 -seed -phase 1 -net 1000 -addr 1000.50 -zone "1033"
-
-* For multiple cards, Ethernet and LocalTalk.
-eth0 -seed -phase 2 -net 3000 -addr 3000.20 -zone "1033"
-lt0 -seed -phase 1 -net 1000 -addr 1000.50 -zone "1033"
-
-* For multiple LocalTalk cards, and an Ethernet card.
-* Order seems to matter here, Ethernet last.
-lt0 -seed -phase 1 -net 1000 -addr 1000.10 -zone "LocalTalk1"
-lt1 -seed -phase 1 -net 2000 -addr 2000.20 -zone "LocalTalk2"
-eth0 -seed -phase 2 -net 3000 -addr 3000.30 -zone "EtherTalk"
diff -ruN ../linux-4.14.336/arch/powerpc/include/asm/cpm1.h ./arch/powerpc/include/asm/cpm1.h
--- linux-4.14.336/../linux-4.14.336/arch/powerpc/include/asm/cpm1.h	2024-01-10 14:45:41.000000000 +0100
+++ linux-4.14.336/./arch/powerpc/include/asm/cpm1.h	2024-02-14 20:39:09.131692114 +0100
@@ -56,8 +56,6 @@
 
 extern void cpm_setbrg(uint brg, uint rate);
 
-extern void __init cpm_load_patch(cpm8xx_t *cp);
-
 extern void cpm_reset(void);
 
 /* Parameter RAM offsets.
diff -ruN ../linux-4.14.336/arch/powerpc/platforms/8xx/Kconfig ./arch/powerpc/platforms/8xx/Kconfig
--- linux-4.14.336/../linux-4.14.336/arch/powerpc/platforms/8xx/Kconfig	2024-01-10 14:45:41.000000000 +0100
+++ linux-4.14.336/./arch/powerpc/platforms/8xx/Kconfig	2024-02-14 21:00:16.561611905 +0100
@@ -145,35 +145,4 @@
 
 	  If in doubt, say Y here.
 
-choice
-	prompt "Microcode patch selection"
-	default NO_UCODE_PATCH
-	help
-	  Help not implemented yet, coming soon.
-
-config NO_UCODE_PATCH
-	bool "None"
-
-config USB_SOF_UCODE_PATCH
-	bool "USB SOF patch"
-	help
-	  Help not implemented yet, coming soon.
-
-config I2C_SPI_UCODE_PATCH
-	bool "I2C/SPI relocation patch"
-	help
-	  Help not implemented yet, coming soon.
-
-config I2C_SPI_SMC1_UCODE_PATCH
-	bool "I2C/SPI/SMC1 relocation patch"
-	help
-	  Help not implemented yet, coming soon.
-
-endchoice
-
-config UCODE_PATCH
-	bool
-	default y
-	depends on !NO_UCODE_PATCH
-
 endmenu
diff -ruN ../linux-4.14.336/arch/powerpc/sysdev/Makefile ./arch/powerpc/sysdev/Makefile
--- linux-4.14.336/../linux-4.14.336/arch/powerpc/sysdev/Makefile	2024-01-10 14:45:41.000000000 +0100
+++ linux-4.14.336/./arch/powerpc/sysdev/Makefile	2024-02-14 20:37:04.311700569 +0100
@@ -46,7 +46,6 @@
 obj-$(CONFIG_CPM2)		+= cpm2.o cpm2_pic.o
 obj-$(CONFIG_QUICC_ENGINE)	+= cpm_common.o
 obj-$(CONFIG_PPC_DCR)		+= dcr.o
-obj-$(CONFIG_UCODE_PATCH)	+= micropatch.o
 
 obj-$(CONFIG_PPC_MPC512x)	+= mpc5xxx_clocks.o
 obj-$(CONFIG_PPC_MPC52xx)	+= mpc5xxx_clocks.o
diff -ruN ../linux-4.14.336/arch/powerpc/sysdev/cpm1.c ./arch/powerpc/sysdev/cpm1.c
--- linux-4.14.336/../linux-4.14.336/arch/powerpc/sysdev/cpm1.c	2024-01-10 14:45:41.000000000 +0100
+++ linux-4.14.336/./arch/powerpc/sysdev/cpm1.c	2024-02-14 20:38:38.041694200 +0100
@@ -218,10 +218,6 @@
 	while (in_be16(&cpmp->cp_cpcr) & CPM_CR_FLG);
 #endif
 
-#ifdef CONFIG_UCODE_PATCH
-	cpm_load_patch(cpmp);
-#endif
-
 	/* Set SDMA Bus Request priority 5.
 	 * On 860T, this also enables FEC priority 6.  I am not sure
 	 * this is what we really want for some applications, but the
diff -ruN ../linux-4.14.336/arch/powerpc/sysdev/micropatch.c ./arch/powerpc/sysdev/micropatch.c
--- linux-4.14.336/../linux-4.14.336/arch/powerpc/sysdev/micropatch.c	2024-01-10 14:45:41.000000000 +0100
+++ linux-4.14.336/./arch/powerpc/sysdev/micropatch.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,749 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-
-/* Microcode patches for the CPM as supplied by Motorola.
- * This is the one for IIC/SPI.  There is a newer one that
- * also relocates SMC2, but this would require additional changes
- * to uart.c, so I am holding off on that for a moment.
- */
-#include <linux/init.h>
-#include <linux/errno.h>
-#include <linux/sched.h>
-#include <linux/kernel.h>
-#include <linux/param.h>
-#include <linux/string.h>
-#include <linux/mm.h>
-#include <linux/interrupt.h>
-#include <asm/irq.h>
-#include <asm/page.h>
-#include <asm/pgtable.h>
-#include <asm/8xx_immap.h>
-#include <asm/cpm.h>
-#include <asm/cpm1.h>
-
-/*
- * I2C/SPI relocation patch arrays.
- */
-
-#ifdef CONFIG_I2C_SPI_UCODE_PATCH
-
-static uint patch_2000[] __initdata = {
-	0x7FFFEFD9,
-	0x3FFD0000,
-	0x7FFB49F7,
-	0x7FF90000,
-	0x5FEFADF7,
-	0x5F89ADF7,
-	0x5FEFAFF7,
-	0x5F89AFF7,
-	0x3A9CFBC8,
-	0xE7C0EDF0,
-	0x77C1E1BB,
-	0xF4DC7F1D,
-	0xABAD932F,
-	0x4E08FDCF,
-	0x6E0FAFF8,
-	0x7CCF76CF,
-	0xFD1FF9CF,
-	0xABF88DC6,
-	0xAB5679F7,
-	0xB0937383,
-	0xDFCE79F7,
-	0xB091E6BB,
-	0xE5BBE74F,
-	0xB3FA6F0F,
-	0x6FFB76CE,
-	0xEE0DF9CF,
-	0x2BFBEFEF,
-	0xCFEEF9CF,
-	0x76CEAD24,
-	0x90B2DF9A,
-	0x7FDDD0BF,
-	0x4BF847FD,
-	0x7CCF76CE,
-	0xCFEF7E1F,
-	0x7F1D7DFD,
-	0xF0B6EF71,
-	0x7FC177C1,
-	0xFBC86079,
-	0xE722FBC8,
-	0x5FFFDFFF,
-	0x5FB2FFFB,
-	0xFBC8F3C8,
-	0x94A67F01,
-	0x7F1D5F39,
-	0xAFE85F5E,
-	0xFFDFDF96,
-	0xCB9FAF7D,
-	0x5FC1AFED,
-	0x8C1C5FC1,
-	0xAFDD5FC3,
-	0xDF9A7EFD,
-	0xB0B25FB2,
-	0xFFFEABAD,
-	0x5FB2FFFE,
-	0x5FCE600B,
-	0xE6BB600B,
-	0x5FCEDFC6,
-	0x27FBEFDF,
-	0x5FC8CFDE,
-	0x3A9CE7C0,
-	0xEDF0F3C8,
-	0x7F0154CD,
-	0x7F1D2D3D,
-	0x363A7570,
-	0x7E0AF1CE,
-	0x37EF2E68,
-	0x7FEE10EC,
-	0xADF8EFDE,
-	0xCFEAE52F,
-	0x7D0FE12B,
-	0xF1CE5F65,
-	0x7E0A4DF8,
-	0xCFEA5F72,
-	0x7D0BEFEE,
-	0xCFEA5F74,
-	0xE522EFDE,
-	0x5F74CFDA,
-	0x0B627385,
-	0xDF627E0A,
-	0x30D8145B,
-	0xBFFFF3C8,
-	0x5FFFDFFF,
-	0xA7F85F5E,
-	0xBFFE7F7D,
-	0x10D31450,
-	0x5F36BFFF,
-	0xAF785F5E,
-	0xBFFDA7F8,
-	0x5F36BFFE,
-	0x77FD30C0,
-	0x4E08FDCF,
-	0xE5FF6E0F,
-	0xAFF87E1F,
-	0x7E0FFD1F,
-	0xF1CF5F1B,
-	0xABF80D5E,
-	0x5F5EFFEF,
-	0x79F730A2,
-	0xAFDD5F34,
-	0x47F85F34,
-	0xAFED7FDD,
-	0x50B24978,
-	0x47FD7F1D,
-	0x7DFD70AD,
-	0xEF717EC1,
-	0x6BA47F01,
-	0x2D267EFD,
-	0x30DE5F5E,
-	0xFFFD5F5E,
-	0xFFEF5F5E,
-	0xFFDF0CA0,
-	0xAFED0A9E,
-	0xAFDD0C3A,
-	0x5F3AAFBD,
-	0x7FBDB082,
-	0x5F8247F8
-};
-
-static uint patch_2f00[] __initdata = {
-	0x3E303430,
-	0x34343737,
-	0xABF7BF9B,
-	0x994B4FBD,
-	0xBD599493,
-	0x349FFF37,
-	0xFB9B177D,
-	0xD9936956,
-	0xBBFDD697,
-	0xBDD2FD11,
-	0x31DB9BB3,
-	0x63139637,
-	0x93733693,
-	0x193137F7,
-	0x331737AF,
-	0x7BB9B999,
-	0xBB197957,
-	0x7FDFD3D5,
-	0x73B773F7,
-	0x37933B99,
-	0x1D115316,
-	0x99315315,
-	0x31694BF4,
-	0xFBDBD359,
-	0x31497353,
-	0x76956D69,
-	0x7B9D9693,
-	0x13131979,
-	0x79376935
-};
-#endif
-
-/*
- * I2C/SPI/SMC1 relocation patch arrays.
- */
-
-#ifdef CONFIG_I2C_SPI_SMC1_UCODE_PATCH
-
-static uint patch_2000[] __initdata = {
-	0x3fff0000,
-	0x3ffd0000,
-	0x3ffb0000,
-	0x3ff90000,
-	0x5f13eff8,
-	0x5eb5eff8,
-	0x5f88adf7,
-	0x5fefadf7,
-	0x3a9cfbc8,
-	0x77cae1bb,
-	0xf4de7fad,
-	0xabae9330,
-	0x4e08fdcf,
-	0x6e0faff8,
-	0x7ccf76cf,
-	0xfdaff9cf,
-	0xabf88dc8,
-	0xab5879f7,
-	0xb0925d8d,
-	0xdfd079f7,
-	0xb090e6bb,
-	0xe5bbe74f,
-	0x9e046f0f,
-	0x6ffb76ce,
-	0xee0cf9cf,
-	0x2bfbefef,
-	0xcfeef9cf,
-	0x76cead23,
-	0x90b3df99,
-	0x7fddd0c1,
-	0x4bf847fd,
-	0x7ccf76ce,
-	0xcfef77ca,
-	0x7eaf7fad,
-	0x7dfdf0b7,
-	0xef7a7fca,
-	0x77cafbc8,
-	0x6079e722,
-	0xfbc85fff,
-	0xdfff5fb3,
-	0xfffbfbc8,
-	0xf3c894a5,
-	0xe7c9edf9,
-	0x7f9a7fad,
-	0x5f36afe8,
-	0x5f5bffdf,
-	0xdf95cb9e,
-	0xaf7d5fc3,
-	0xafed8c1b,
-	0x5fc3afdd,
-	0x5fc5df99,
-	0x7efdb0b3,
-	0x5fb3fffe,
-	0xabae5fb3,
-	0xfffe5fd0,
-	0x600be6bb,
-	0x600b5fd0,
-	0xdfc827fb,
-	0xefdf5fca,
-	0xcfde3a9c,
-	0xe7c9edf9,
-	0xf3c87f9e,
-	0x54ca7fed,
-	0x2d3a3637,
-	0x756f7e9a,
-	0xf1ce37ef,
-	0x2e677fee,
-	0x10ebadf8,
-	0xefdecfea,
-	0xe52f7d9f,
-	0xe12bf1ce,
-	0x5f647e9a,
-	0x4df8cfea,
-	0x5f717d9b,
-	0xefeecfea,
-	0x5f73e522,
-	0xefde5f73,
-	0xcfda0b61,
-	0x5d8fdf61,
-	0xe7c9edf9,
-	0x7e9a30d5,
-	0x1458bfff,
-	0xf3c85fff,
-	0xdfffa7f8,
-	0x5f5bbffe,
-	0x7f7d10d0,
-	0x144d5f33,
-	0xbfffaf78,
-	0x5f5bbffd,
-	0xa7f85f33,
-	0xbffe77fd,
-	0x30bd4e08,
-	0xfdcfe5ff,
-	0x6e0faff8,
-	0x7eef7e9f,
-	0xfdeff1cf,
-	0x5f17abf8,
-	0x0d5b5f5b,
-	0xffef79f7,
-	0x309eafdd,
-	0x5f3147f8,
-	0x5f31afed,
-	0x7fdd50af,
-	0x497847fd,
-	0x7f9e7fed,
-	0x7dfd70a9,
-	0xef7e7ece,
-	0x6ba07f9e,
-	0x2d227efd,
-	0x30db5f5b,
-	0xfffd5f5b,
-	0xffef5f5b,
-	0xffdf0c9c,
-	0xafed0a9a,
-	0xafdd0c37,
-	0x5f37afbd,
-	0x7fbdb081,
-	0x5f8147f8,
-	0x3a11e710,
-	0xedf0ccdd,
-	0xf3186d0a,
-	0x7f0e5f06,
-	0x7fedbb38,
-	0x3afe7468,
-	0x7fedf4fc,
-	0x8ffbb951,
-	0xb85f77fd,
-	0xb0df5ddd,
-	0xdefe7fed,
-	0x90e1e74d,
-	0x6f0dcbf7,
-	0xe7decfed,
-	0xcb74cfed,
-	0xcfeddf6d,
-	0x91714f74,
-	0x5dd2deef,
-	0x9e04e7df,
-	0xefbb6ffb,
-	0xe7ef7f0e,
-	0x9e097fed,
-	0xebdbeffa,
-	0xeb54affb,
-	0x7fea90d7,
-	0x7e0cf0c3,
-	0xbffff318,
-	0x5fffdfff,
-	0xac59efea,
-	0x7fce1ee5,
-	0xe2ff5ee1,
-	0xaffbe2ff,
-	0x5ee3affb,
-	0xf9cc7d0f,
-	0xaef8770f,
-	0x7d0fb0c6,
-	0xeffbbfff,
-	0xcfef5ede,
-	0x7d0fbfff,
-	0x5ede4cf8,
-	0x7fddd0bf,
-	0x49f847fd,
-	0x7efdf0bb,
-	0x7fedfffd,
-	0x7dfdf0b7,
-	0xef7e7e1e,
-	0x5ede7f0e,
-	0x3a11e710,
-	0xedf0ccab,
-	0xfb18ad2e,
-	0x1ea9bbb8,
-	0x74283b7e,
-	0x73c2e4bb,
-	0x2ada4fb8,
-	0xdc21e4bb,
-	0xb2a1ffbf,
-	0x5e2c43f8,
-	0xfc87e1bb,
-	0xe74ffd91,
-	0x6f0f4fe8,
-	0xc7ba32e2,
-	0xf396efeb,
-	0x600b4f78,
-	0xe5bb760b,
-	0x53acaef8,
-	0x4ef88b0e,
-	0xcfef9e09,
-	0xabf8751f,
-	0xefef5bac,
-	0x741f4fe8,
-	0x751e760d,
-	0x7fdbf081,
-	0x741cafce,
-	0xefcc7fce,
-	0x751e70ac,
-	0x741ce7bb,
-	0x3372cfed,
-	0xafdbefeb,
-	0xe5bb760b,
-	0x53f2aef8,
-	0xafe8e7eb,
-	0x4bf8771e,
-	0x7e247fed,
-	0x4fcbe2cc,
-	0x7fbc30a9,
-	0x7b0f7a0f,
-	0x34d577fd,
-	0x308b5db7,
-	0xde553e5f,
-	0xaf78741f,
-	0x741f30f0,
-	0xcfef5e2c,
-	0x741f3eac,
-	0xafb8771e,
-	0x5e677fed,
-	0x0bd3e2cc,
-	0x741ccfec,
-	0xe5ca53cd,
-	0x6fcb4f74,
-	0x5dadde4b,
-	0x2ab63d38,
-	0x4bb3de30,
-	0x751f741c,
-	0x6c42effa,
-	0xefea7fce,
-	0x6ffc30be,
-	0xefec3fca,
-	0x30b3de2e,
-	0xadf85d9e,
-	0xaf7daefd,
-	0x5d9ede2e,
-	0x5d9eafdd,
-	0x761f10ac,
-	0x1da07efd,
-	0x30adfffe,
-	0x4908fb18,
-	0x5fffdfff,
-	0xafbb709b,
-	0x4ef85e67,
-	0xadf814ad,
-	0x7a0f70ad,
-	0xcfef50ad,
-	0x7a0fde30,
-	0x5da0afed,
-	0x3c12780f,
-	0xefef780f,
-	0xefef790f,
-	0xa7f85e0f,
-	0xffef790f,
-	0xefef790f,
-	0x14adde2e,
-	0x5d9eadfd,
-	0x5e2dfffb,
-	0xe79addfd,
-	0xeff96079,
-	0x607ae79a,
-	0xddfceff9,
-	0x60795dff,
-	0x607acfef,
-	0xefefefdf,
-	0xefbfef7f,
-	0xeeffedff,
-	0xebffe7ff,
-	0xafefafdf,
-	0xafbfaf7f,
-	0xaeffadff,
-	0xabffa7ff,
-	0x6fef6fdf,
-	0x6fbf6f7f,
-	0x6eff6dff,
-	0x6bff67ff,
-	0x2fef2fdf,
-	0x2fbf2f7f,
-	0x2eff2dff,
-	0x2bff27ff,
-	0x4e08fd1f,
-	0xe5ff6e0f,
-	0xaff87eef,
-	0x7e0ffdef,
-	0xf11f6079,
-	0xabf8f542,
-	0x7e0af11c,
-	0x37cfae3a,
-	0x7fec90be,
-	0xadf8efdc,
-	0xcfeae52f,
-	0x7d0fe12b,
-	0xf11c6079,
-	0x7e0a4df8,
-	0xcfea5dc4,
-	0x7d0befec,
-	0xcfea5dc6,
-	0xe522efdc,
-	0x5dc6cfda,
-	0x4e08fd1f,
-	0x6e0faff8,
-	0x7c1f761f,
-	0xfdeff91f,
-	0x6079abf8,
-	0x761cee24,
-	0xf91f2bfb,
-	0xefefcfec,
-	0xf91f6079,
-	0x761c27fb,
-	0xefdf5da7,
-	0xcfdc7fdd,
-	0xd09c4bf8,
-	0x47fd7c1f,
-	0x761ccfcf,
-	0x7eef7fed,
-	0x7dfdf093,
-	0xef7e7f1e,
-	0x771efb18,
-	0x6079e722,
-	0xe6bbe5bb,
-	0xae0ae5bb,
-	0x600bae85,
-	0xe2bbe2bb,
-	0xe2bbe2bb,
-	0xaf02e2bb,
-	0xe2bb2ff9,
-	0x6079e2bb
-};
-
-static uint patch_2f00[] __initdata = {
-	0x30303030,
-	0x3e3e3434,
-	0xabbf9b99,
-	0x4b4fbdbd,
-	0x59949334,
-	0x9fff37fb,
-	0x9b177dd9,
-	0x936956bb,
-	0xfbdd697b,
-	0xdd2fd113,
-	0x1db9f7bb,
-	0x36313963,
-	0x79373369,
-	0x3193137f,
-	0x7331737a,
-	0xf7bb9b99,
-	0x9bb19795,
-	0x77fdfd3d,
-	0x573b773f,
-	0x737933f7,
-	0xb991d115,
-	0x31699315,
-	0x31531694,
-	0xbf4fbdbd,
-	0x35931497,
-	0x35376956,
-	0xbd697b9d,
-	0x96931313,
-	0x19797937,
-	0x6935af78,
-	0xb9b3baa3,
-	0xb8788683,
-	0x368f78f7,
-	0x87778733,
-	0x3ffffb3b,
-	0x8e8f78b8,
-	0x1d118e13,
-	0xf3ff3f8b,
-	0x6bd8e173,
-	0xd1366856,
-	0x68d1687b,
-	0x3daf78b8,
-	0x3a3a3f87,
-	0x8f81378f,
-	0xf876f887,
-	0x77fd8778,
-	0x737de8d6,
-	0xbbf8bfff,
-	0xd8df87f7,
-	0xfd876f7b,
-	0x8bfff8bd,
-	0x8683387d,
-	0xb873d87b,
-	0x3b8fd7f8,
-	0xf7338883,
-	0xbb8ee1f8,
-	0xef837377,
-	0x3337b836,
-	0x817d11f8,
-	0x7378b878,
-	0xd3368b7d,
-	0xed731b7d,
-	0x833731f3,
-	0xf22f3f23
-};
-
-static uint patch_2e00[] __initdata = {
-	0x27eeeeee,
-	0xeeeeeeee,
-	0xeeeeeeee,
-	0xeeeeeeee,
-	0xee4bf4fb,
-	0xdbd259bb,
-	0x1979577f,
-	0xdfd2d573,
-	0xb773f737,
-	0x4b4fbdbd,
-	0x25b9b177,
-	0xd2d17376,
-	0x956bbfdd,
-	0x697bdd2f,
-	0xff9f79ff,
-	0xff9ff22f
-};
-#endif
-
-/*
- *  USB SOF patch arrays.
- */
-
-#ifdef CONFIG_USB_SOF_UCODE_PATCH
-
-static uint patch_2000[] __initdata = {
-	0x7fff0000,
-	0x7ffd0000,
-	0x7ffb0000,
-	0x49f7ba5b,
-	0xba383ffb,
-	0xf9b8b46d,
-	0xe5ab4e07,
-	0xaf77bffe,
-	0x3f7bbf79,
-	0xba5bba38,
-	0xe7676076,
-	0x60750000
-};
-
-static uint patch_2f00[] __initdata = {
-	0x3030304c,
-	0xcab9e441,
-	0xa1aaf220
-};
-#endif
-
-void __init cpm_load_patch(cpm8xx_t *cp)
-{
-	volatile uint		*dp;		/* Dual-ported RAM. */
-	volatile cpm8xx_t	*commproc;
-#if defined(CONFIG_I2C_SPI_UCODE_PATCH) || \
-    defined(CONFIG_I2C_SPI_SMC1_UCODE_PATCH)
-	volatile iic_t		*iip;
-	volatile struct spi_pram *spp;
-#ifdef CONFIG_I2C_SPI_SMC1_UCODE_PATCH
-	volatile smc_uart_t	*smp;
-#endif
-#endif
-	int	i;
-
-	commproc = cp;
-
-#ifdef CONFIG_USB_SOF_UCODE_PATCH
-	commproc->cp_rccr = 0;
-
-	dp = (uint *)(commproc->cp_dpmem);
-	for (i=0; i<(sizeof(patch_2000)/4); i++)
-		*dp++ = patch_2000[i];
-
-	dp = (uint *)&(commproc->cp_dpmem[0x0f00]);
-	for (i=0; i<(sizeof(patch_2f00)/4); i++)
-		*dp++ = patch_2f00[i];
-
-	commproc->cp_rccr = 0x0009;
-
-	printk("USB SOF microcode patch installed\n");
-#endif /* CONFIG_USB_SOF_UCODE_PATCH */
-
-#if defined(CONFIG_I2C_SPI_UCODE_PATCH) || \
-    defined(CONFIG_I2C_SPI_SMC1_UCODE_PATCH)
-
-	commproc->cp_rccr = 0;
-
-	dp = (uint *)(commproc->cp_dpmem);
-	for (i=0; i<(sizeof(patch_2000)/4); i++)
-		*dp++ = patch_2000[i];
-
-	dp = (uint *)&(commproc->cp_dpmem[0x0f00]);
-	for (i=0; i<(sizeof(patch_2f00)/4); i++)
-		*dp++ = patch_2f00[i];
-
-	iip = (iic_t *)&commproc->cp_dparam[PROFF_IIC];
-# define RPBASE 0x0500
-	iip->iic_rpbase = RPBASE;
-
-	/* Put SPI above the IIC, also 32-byte aligned.
-	*/
-	i = (RPBASE + sizeof(iic_t) + 31) & ~31;
-	spp = (struct spi_pram *)&commproc->cp_dparam[PROFF_SPI];
-	spp->rpbase = i;
-
-# if defined(CONFIG_I2C_SPI_UCODE_PATCH)
-	commproc->cp_cpmcr1 = 0x802a;
-	commproc->cp_cpmcr2 = 0x8028;
-	commproc->cp_cpmcr3 = 0x802e;
-	commproc->cp_cpmcr4 = 0x802c;
-	commproc->cp_rccr = 1;
-
-	printk("I2C/SPI microcode patch installed.\n");
-# endif /* CONFIG_I2C_SPI_UCODE_PATCH */
-
-# if defined(CONFIG_I2C_SPI_SMC1_UCODE_PATCH)
-
-	dp = (uint *)&(commproc->cp_dpmem[0x0e00]);
-	for (i=0; i<(sizeof(patch_2e00)/4); i++)
-		*dp++ = patch_2e00[i];
-
-	commproc->cp_cpmcr1 = 0x8080;
-	commproc->cp_cpmcr2 = 0x808a;
-	commproc->cp_cpmcr3 = 0x8028;
-	commproc->cp_cpmcr4 = 0x802a;
-	commproc->cp_rccr = 3;
-
-	smp = (smc_uart_t *)&commproc->cp_dparam[PROFF_SMC1];
-	smp->smc_rpbase = 0x1FC0;
-
-	printk("I2C/SPI/SMC1 microcode patch installed.\n");
-# endif /* CONFIG_I2C_SPI_SMC1_UCODE_PATCH) */
-
-#endif /* some variation of the I2C/SPI patch was selected */
-}
-
-/*
- *  Take this entire routine out, since no one calls it and its
- * logic is suspect.
- */
-
-#if 0
-void
-verify_patch(volatile immap_t *immr)
-{
-	volatile uint		*dp;
-	volatile cpm8xx_t	*commproc;
-	int i;
-
-	commproc = (cpm8xx_t *)&immr->im_cpm;
-
-	printk("cp_rccr %x\n", commproc->cp_rccr);
-	commproc->cp_rccr = 0;
-
-	dp = (uint *)(commproc->cp_dpmem);
-	for (i=0; i<(sizeof(patch_2000)/4); i++)
-		if (*dp++ != patch_2000[i]) {
-			printk("patch_2000 bad at %d\n", i);
-			dp--;
-			printk("found 0x%X, wanted 0x%X\n", *dp, patch_2000[i]);
-			break;
-		}
-
-	dp = (uint *)&(commproc->cp_dpmem[0x0f00]);
-	for (i=0; i<(sizeof(patch_2f00)/4); i++)
-		if (*dp++ != patch_2f00[i]) {
-			printk("patch_2f00 bad at %d\n", i);
-			dp--;
-			printk("found 0x%X, wanted 0x%X\n", *dp, patch_2f00[i]);
-			break;
-		}
-
-	commproc->cp_rccr = 0x0009;
-}
-#endif
diff -ruN ../linux-4.14.336/drivers/i2c/busses/i2c-cpm.c ./drivers/i2c/busses/i2c-cpm.c
--- linux-4.14.336/../linux-4.14.336/drivers/i2c/busses/i2c-cpm.c	2024-01-10 14:45:41.000000000 +0100
+++ linux-4.14.336/./drivers/i2c/busses/i2c-cpm.c	2024-02-14 20:42:10.901680998 +0100
@@ -461,20 +461,9 @@
 	}
 
 	if (of_device_is_compatible(ofdev->dev.of_node, "fsl,cpm1-i2c")) {
-
-		/* Check for and use a microcode relocation patch. */
 		cpm->i2c_ram = i2c_base;
 		cpm->i2c_addr = in_be16(&cpm->i2c_ram->rpbase);
 
-		/*
-		 * Maybe should use cpm_muram_alloc instead of hardcoding
-		 * this in micropatch.c
-		 */
-		if (cpm->i2c_addr) {
-			cpm->i2c_ram = cpm_muram_addr(cpm->i2c_addr);
-			iounmap(i2c_base);
-		}
-
 		cpm->version = 1;
 
 	} else if (of_device_is_compatible(ofdev->dev.of_node, "fsl,cpm2-i2c")) {
diff -ruN ../linux-4.14.336/drivers/media/usb/dvb-usb/Kconfig ./drivers/media/usb/dvb-usb/Kconfig
--- linux-4.14.336/../linux-4.14.336/drivers/media/usb/dvb-usb/Kconfig	2024-01-10 14:45:41.000000000 +0100
+++ linux-4.14.336/./drivers/media/usb/dvb-usb/Kconfig	2024-02-14 21:41:13.341455995 +0100
@@ -242,22 +242,6 @@
 	help
 	  Say Y here to support the Opera DVB-S USB2.0 receiver.
 
-config DVB_USB_AF9005
-	tristate "Afatech AF9005 DVB-T USB1.1 support"
-	depends on DVB_USB
-	select MEDIA_TUNER_MT2060 if MEDIA_SUBDRV_AUTOSELECT
-	select MEDIA_TUNER_QT1010 if MEDIA_SUBDRV_AUTOSELECT
-	help
-	  Say Y here to support the Afatech AF9005 based DVB-T USB1.1 receiver
-	  and the TerraTec Cinergy T USB XE (Rev.1)
-
-config DVB_USB_AF9005_REMOTE
-	tristate "Afatech AF9005 default remote control support"
-	depends on DVB_USB_AF9005
-	help
-	  Say Y here to support the default remote control decoding for the
-	  Afatech AF9005 based receiver.
-
 config DVB_USB_PCTV452E
 	tristate "Pinnacle PCTV HDTV Pro USB device/TT Connect S2-3600"
 	depends on DVB_USB
diff -ruN ../linux-4.14.336/drivers/media/usb/dvb-usb/Makefile ./drivers/media/usb/dvb-usb/Makefile
--- linux-4.14.336/../linux-4.14.336/drivers/media/usb/dvb-usb/Makefile	2024-01-10 14:45:41.000000000 +0100
+++ linux-4.14.336/./drivers/media/usb/dvb-usb/Makefile	2024-02-14 21:40:58.271457116 +0100
@@ -53,12 +53,6 @@
 dvb-usb-opera-objs := opera1.o
 obj-$(CONFIG_DVB_USB_OPERA1) += dvb-usb-opera.o
 
-dvb-usb-af9005-objs := af9005.o af9005-fe.o
-obj-$(CONFIG_DVB_USB_AF9005) += dvb-usb-af9005.o
-
-dvb-usb-af9005-remote-objs := af9005-remote.o
-obj-$(CONFIG_DVB_USB_AF9005_REMOTE) += dvb-usb-af9005-remote.o
-
 dvb-usb-pctv452e-objs := pctv452e.o
 obj-$(CONFIG_DVB_USB_PCTV452E) += dvb-usb-pctv452e.o
 
diff -ruN ../linux-4.14.336/drivers/media/usb/dvb-usb/af9005-fe.c ./drivers/media/usb/dvb-usb/af9005-fe.c
--- linux-4.14.336/../linux-4.14.336/drivers/media/usb/dvb-usb/af9005-fe.c	2024-01-10 14:45:41.000000000 +0100
+++ linux-4.14.336/./drivers/media/usb/dvb-usb/af9005-fe.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1484 +0,0 @@
-/* Frontend part of the Linux driver for the Afatech 9005
- * USB1.1 DVB-T receiver.
- *
- * Copyright (C) 2007 Luca Olivetti (luca@ventoso.org)
- *
- * Thanks to Afatech who kindly provided information.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * see Documentation/dvb/README.dvb-usb for more information
- */
-#include "af9005.h"
-#include "af9005-script.h"
-#include "mt2060.h"
-#include "qt1010.h"
-#include <asm/div64.h>
-
-struct af9005_fe_state {
-	struct dvb_usb_device *d;
-	enum fe_status stat;
-
-	/* retraining parameters */
-	u32 original_fcw;
-	u16 original_rf_top;
-	u16 original_if_top;
-	u16 original_if_min;
-	u16 original_aci0_if_top;
-	u16 original_aci1_if_top;
-	u16 original_aci0_if_min;
-	u8 original_if_unplug_th;
-	u8 original_rf_unplug_th;
-	u8 original_dtop_if_unplug_th;
-	u8 original_dtop_rf_unplug_th;
-
-	/* statistics */
-	u32 pre_vit_error_count;
-	u32 pre_vit_bit_count;
-	u32 ber;
-	u32 post_vit_error_count;
-	u32 post_vit_bit_count;
-	u32 unc;
-	u16 abort_count;
-
-	int opened;
-	int strong;
-	unsigned long next_status_check;
-	struct dvb_frontend frontend;
-};
-
-static int af9005_write_word_agc(struct dvb_usb_device *d, u16 reghi,
-				 u16 reglo, u8 pos, u8 len, u16 value)
-{
-	int ret;
-
-	if ((ret = af9005_write_ofdm_register(d, reglo, (u8) (value & 0xff))))
-		return ret;
-	return af9005_write_register_bits(d, reghi, pos, len,
-					  (u8) ((value & 0x300) >> 8));
-}
-
-static int af9005_read_word_agc(struct dvb_usb_device *d, u16 reghi,
-				u16 reglo, u8 pos, u8 len, u16 * value)
-{
-	int ret;
-	u8 temp0, temp1;
-
-	if ((ret = af9005_read_ofdm_register(d, reglo, &temp0)))
-		return ret;
-	if ((ret = af9005_read_ofdm_register(d, reghi, &temp1)))
-		return ret;
-	switch (pos) {
-	case 0:
-		*value = ((u16) (temp1 & 0x03) << 8) + (u16) temp0;
-		break;
-	case 2:
-		*value = ((u16) (temp1 & 0x0C) << 6) + (u16) temp0;
-		break;
-	case 4:
-		*value = ((u16) (temp1 & 0x30) << 4) + (u16) temp0;
-		break;
-	case 6:
-		*value = ((u16) (temp1 & 0xC0) << 2) + (u16) temp0;
-		break;
-	default:
-		err("invalid pos in read word agc");
-		return -EINVAL;
-	}
-	return 0;
-
-}
-
-static int af9005_is_fecmon_available(struct dvb_frontend *fe, int *available)
-{
-	struct af9005_fe_state *state = fe->demodulator_priv;
-	int ret;
-	u8 temp;
-
-	*available = false;
-
-	ret = af9005_read_register_bits(state->d, xd_p_fec_vtb_rsd_mon_en,
-					fec_vtb_rsd_mon_en_pos,
-					fec_vtb_rsd_mon_en_len, &temp);
-	if (ret)
-		return ret;
-	if (temp & 1) {
-		ret =
-		    af9005_read_register_bits(state->d,
-					      xd_p_reg_ofsm_read_rbc_en,
-					      reg_ofsm_read_rbc_en_pos,
-					      reg_ofsm_read_rbc_en_len, &temp);
-		if (ret)
-			return ret;
-		if ((temp & 1) == 0)
-			*available = true;
-
-	}
-	return 0;
-}
-
-static int af9005_get_post_vit_err_cw_count(struct dvb_frontend *fe,
-					    u32 * post_err_count,
-					    u32 * post_cw_count,
-					    u16 * abort_count)
-{
-	struct af9005_fe_state *state = fe->demodulator_priv;
-	int ret;
-	u32 err_count;
-	u32 cw_count;
-	u8 temp, temp0, temp1, temp2;
-	u16 loc_abort_count;
-
-	*post_err_count = 0;
-	*post_cw_count = 0;
-
-	/* check if error bit count is ready */
-	ret =
-	    af9005_read_register_bits(state->d, xd_r_fec_rsd_ber_rdy,
-				      fec_rsd_ber_rdy_pos, fec_rsd_ber_rdy_len,
-				      &temp);
-	if (ret)
-		return ret;
-	if (!temp) {
-		deb_info("rsd counter not ready\n");
-		return 100;
-	}
-	/* get abort count */
-	ret =
-	    af9005_read_ofdm_register(state->d,
-				      xd_r_fec_rsd_abort_packet_cnt_7_0,
-				      &temp0);
-	if (ret)
-		return ret;
-	ret =
-	    af9005_read_ofdm_register(state->d,
-				      xd_r_fec_rsd_abort_packet_cnt_15_8,
-				      &temp1);
-	if (ret)
-		return ret;
-	loc_abort_count = ((u16) temp1 << 8) + temp0;
-
-	/* get error count */
-	ret =
-	    af9005_read_ofdm_register(state->d, xd_r_fec_rsd_bit_err_cnt_7_0,
-				      &temp0);
-	if (ret)
-		return ret;
-	ret =
-	    af9005_read_ofdm_register(state->d, xd_r_fec_rsd_bit_err_cnt_15_8,
-				      &temp1);
-	if (ret)
-		return ret;
-	ret =
-	    af9005_read_ofdm_register(state->d, xd_r_fec_rsd_bit_err_cnt_23_16,
-				      &temp2);
-	if (ret)
-		return ret;
-	err_count = ((u32) temp2 << 16) + ((u32) temp1 << 8) + temp0;
-	*post_err_count = err_count - (u32) loc_abort_count *8 * 8;
-
-	/* get RSD packet number */
-	ret =
-	    af9005_read_ofdm_register(state->d, xd_p_fec_rsd_packet_unit_7_0,
-				      &temp0);
-	if (ret)
-		return ret;
-	ret =
-	    af9005_read_ofdm_register(state->d, xd_p_fec_rsd_packet_unit_15_8,
-				      &temp1);
-	if (ret)
-		return ret;
-	cw_count = ((u32) temp1 << 8) + temp0;
-	if (cw_count == 0) {
-		err("wrong RSD packet count");
-		return -EIO;
-	}
-	deb_info("POST abort count %d err count %d rsd packets %d\n",
-		 loc_abort_count, err_count, cw_count);
-	*post_cw_count = cw_count - (u32) loc_abort_count;
-	*abort_count = loc_abort_count;
-	return 0;
-
-}
-
-static int af9005_get_post_vit_ber(struct dvb_frontend *fe,
-				   u32 * post_err_count, u32 * post_cw_count,
-				   u16 * abort_count)
-{
-	u32 loc_cw_count = 0, loc_err_count;
-	u16 loc_abort_count = 0;
-	int ret;
-
-	ret =
-	    af9005_get_post_vit_err_cw_count(fe, &loc_err_count, &loc_cw_count,
-					     &loc_abort_count);
-	if (ret)
-		return ret;
-	*post_err_count = loc_err_count;
-	*post_cw_count = loc_cw_count * 204 * 8;
-	*abort_count = loc_abort_count;
-
-	return 0;
-}
-
-static int af9005_get_pre_vit_err_bit_count(struct dvb_frontend *fe,
-					    u32 * pre_err_count,
-					    u32 * pre_bit_count)
-{
-	struct af9005_fe_state *state = fe->demodulator_priv;
-	u8 temp, temp0, temp1, temp2;
-	u32 super_frame_count, x, bits;
-	int ret;
-
-	ret =
-	    af9005_read_register_bits(state->d, xd_r_fec_vtb_ber_rdy,
-				      fec_vtb_ber_rdy_pos, fec_vtb_ber_rdy_len,
-				      &temp);
-	if (ret)
-		return ret;
-	if (!temp) {
-		deb_info("viterbi counter not ready\n");
-		return 101;	/* ERR_APO_VTB_COUNTER_NOT_READY; */
-	}
-	ret =
-	    af9005_read_ofdm_register(state->d, xd_r_fec_vtb_err_bit_cnt_7_0,
-				      &temp0);
-	if (ret)
-		return ret;
-	ret =
-	    af9005_read_ofdm_register(state->d, xd_r_fec_vtb_err_bit_cnt_15_8,
-				      &temp1);
-	if (ret)
-		return ret;
-	ret =
-	    af9005_read_ofdm_register(state->d, xd_r_fec_vtb_err_bit_cnt_23_16,
-				      &temp2);
-	if (ret)
-		return ret;
-	*pre_err_count = ((u32) temp2 << 16) + ((u32) temp1 << 8) + temp0;
-
-	ret =
-	    af9005_read_ofdm_register(state->d, xd_p_fec_super_frm_unit_7_0,
-				      &temp0);
-	if (ret)
-		return ret;
-	ret =
-	    af9005_read_ofdm_register(state->d, xd_p_fec_super_frm_unit_15_8,
-				      &temp1);
-	if (ret)
-		return ret;
-	super_frame_count = ((u32) temp1 << 8) + temp0;
-	if (super_frame_count == 0) {
-		deb_info("super frame count 0\n");
-		return 102;
-	}
-
-	/* read fft mode */
-	ret =
-	    af9005_read_register_bits(state->d, xd_g_reg_tpsd_txmod,
-				      reg_tpsd_txmod_pos, reg_tpsd_txmod_len,
-				      &temp);
-	if (ret)
-		return ret;
-	if (temp == 0) {
-		/* 2K */
-		x = 1512;
-	} else if (temp == 1) {
-		/* 8k */
-		x = 6048;
-	} else {
-		err("Invalid fft mode");
-		return -EINVAL;
-	}
-
-	/* read modulation mode */
-	ret =
-	    af9005_read_register_bits(state->d, xd_g_reg_tpsd_const,
-				      reg_tpsd_const_pos, reg_tpsd_const_len,
-				      &temp);
-	if (ret)
-		return ret;
-	switch (temp) {
-	case 0:		/* QPSK */
-		bits = 2;
-		break;
-	case 1:		/* QAM_16 */
-		bits = 4;
-		break;
-	case 2:		/* QAM_64 */
-		bits = 6;
-		break;
-	default:
-		err("invalid modulation mode");
-		return -EINVAL;
-	}
-	*pre_bit_count = super_frame_count * 68 * 4 * x * bits;
-	deb_info("PRE err count %d frame count %d bit count %d\n",
-		 *pre_err_count, super_frame_count, *pre_bit_count);
-	return 0;
-}
-
-static int af9005_reset_pre_viterbi(struct dvb_frontend *fe)
-{
-	struct af9005_fe_state *state = fe->demodulator_priv;
-	int ret;
-
-	/* set super frame count to 1 */
-	ret =
-	    af9005_write_ofdm_register(state->d, xd_p_fec_super_frm_unit_7_0,
-				       1 & 0xff);
-	if (ret)
-		return ret;
-	ret = af9005_write_ofdm_register(state->d, xd_p_fec_super_frm_unit_15_8,
-					 1 >> 8);
-	if (ret)
-		return ret;
-	/* reset pre viterbi error count */
-	ret =
-	    af9005_write_register_bits(state->d, xd_p_fec_vtb_ber_rst,
-				       fec_vtb_ber_rst_pos, fec_vtb_ber_rst_len,
-				       1);
-
-	return ret;
-}
-
-static int af9005_reset_post_viterbi(struct dvb_frontend *fe)
-{
-	struct af9005_fe_state *state = fe->demodulator_priv;
-	int ret;
-
-	/* set packet unit */
-	ret =
-	    af9005_write_ofdm_register(state->d, xd_p_fec_rsd_packet_unit_7_0,
-				       10000 & 0xff);
-	if (ret)
-		return ret;
-	ret =
-	    af9005_write_ofdm_register(state->d, xd_p_fec_rsd_packet_unit_15_8,
-				       10000 >> 8);
-	if (ret)
-		return ret;
-	/* reset post viterbi error count */
-	ret =
-	    af9005_write_register_bits(state->d, xd_p_fec_rsd_ber_rst,
-				       fec_rsd_ber_rst_pos, fec_rsd_ber_rst_len,
-				       1);
-
-	return ret;
-}
-
-static int af9005_get_statistic(struct dvb_frontend *fe)
-{
-	struct af9005_fe_state *state = fe->demodulator_priv;
-	int ret, fecavailable;
-	u64 numerator, denominator;
-
-	deb_info("GET STATISTIC\n");
-	ret = af9005_is_fecmon_available(fe, &fecavailable);
-	if (ret)
-		return ret;
-	if (!fecavailable) {
-		deb_info("fecmon not available\n");
-		return 0;
-	}
-
-	ret = af9005_get_pre_vit_err_bit_count(fe, &state->pre_vit_error_count,
-					       &state->pre_vit_bit_count);
-	if (ret == 0) {
-		af9005_reset_pre_viterbi(fe);
-		if (state->pre_vit_bit_count > 0) {
-			/* according to v 0.0.4 of the dvb api ber should be a multiple
-			   of 10E-9 so we have to multiply the error count by
-			   10E9=1000000000 */
-			numerator =
-			    (u64) state->pre_vit_error_count * (u64) 1000000000;
-			denominator = (u64) state->pre_vit_bit_count;
-			state->ber = do_div(numerator, denominator);
-		} else {
-			state->ber = 0xffffffff;
-		}
-	}
-
-	ret = af9005_get_post_vit_ber(fe, &state->post_vit_error_count,
-				      &state->post_vit_bit_count,
-				      &state->abort_count);
-	if (ret == 0) {
-		ret = af9005_reset_post_viterbi(fe);
-		state->unc += state->abort_count;
-		if (ret)
-			return ret;
-	}
-	return 0;
-}
-
-static int af9005_fe_refresh_state(struct dvb_frontend *fe)
-{
-	struct af9005_fe_state *state = fe->demodulator_priv;
-	if (time_after(jiffies, state->next_status_check)) {
-		deb_info("REFRESH STATE\n");
-
-		/* statistics */
-		if (af9005_get_statistic(fe))
-			err("get_statistic_failed");
-		state->next_status_check = jiffies + 250 * HZ / 1000;
-	}
-	return 0;
-}
-
-static int af9005_fe_read_status(struct dvb_frontend *fe,
-				 enum fe_status *stat)
-{
-	struct af9005_fe_state *state = fe->demodulator_priv;
-	u8 temp;
-	int ret;
-
-	if (fe->ops.tuner_ops.release == NULL)
-		return -ENODEV;
-
-	*stat = 0;
-	ret = af9005_read_register_bits(state->d, xd_p_agc_lock,
-					agc_lock_pos, agc_lock_len, &temp);
-	if (ret)
-		return ret;
-	if (temp)
-		*stat |= FE_HAS_SIGNAL;
-
-	ret = af9005_read_register_bits(state->d, xd_p_fd_tpsd_lock,
-					fd_tpsd_lock_pos, fd_tpsd_lock_len,
-					&temp);
-	if (ret)
-		return ret;
-	if (temp)
-		*stat |= FE_HAS_CARRIER;
-
-	ret = af9005_read_register_bits(state->d,
-					xd_r_mp2if_sync_byte_locked,
-					mp2if_sync_byte_locked_pos,
-					mp2if_sync_byte_locked_pos, &temp);
-	if (ret)
-		return ret;
-	if (temp)
-		*stat |= FE_HAS_SYNC | FE_HAS_VITERBI | FE_HAS_LOCK;
-	if (state->opened)
-		af9005_led_control(state->d, *stat & FE_HAS_LOCK);
-
-	ret =
-	    af9005_read_register_bits(state->d, xd_p_reg_strong_sginal_detected,
-				      reg_strong_sginal_detected_pos,
-				      reg_strong_sginal_detected_len, &temp);
-	if (ret)
-		return ret;
-	if (temp != state->strong) {
-		deb_info("adjust for strong signal %d\n", temp);
-		state->strong = temp;
-	}
-	return 0;
-}
-
-static int af9005_fe_read_ber(struct dvb_frontend *fe, u32 * ber)
-{
-	struct af9005_fe_state *state = fe->demodulator_priv;
-	if (fe->ops.tuner_ops.release  == NULL)
-		return -ENODEV;
-	af9005_fe_refresh_state(fe);
-	*ber = state->ber;
-	return 0;
-}
-
-static int af9005_fe_read_unc_blocks(struct dvb_frontend *fe, u32 * unc)
-{
-	struct af9005_fe_state *state = fe->demodulator_priv;
-	if (fe->ops.tuner_ops.release == NULL)
-		return -ENODEV;
-	af9005_fe_refresh_state(fe);
-	*unc = state->unc;
-	return 0;
-}
-
-static int af9005_fe_read_signal_strength(struct dvb_frontend *fe,
-					  u16 * strength)
-{
-	struct af9005_fe_state *state = fe->demodulator_priv;
-	int ret;
-	u8 if_gain, rf_gain;
-
-	if (fe->ops.tuner_ops.release == NULL)
-		return -ENODEV;
-	ret =
-	    af9005_read_ofdm_register(state->d, xd_r_reg_aagc_rf_gain,
-				      &rf_gain);
-	if (ret)
-		return ret;
-	ret =
-	    af9005_read_ofdm_register(state->d, xd_r_reg_aagc_if_gain,
-				      &if_gain);
-	if (ret)
-		return ret;
-	/* this value has no real meaning, but i don't have the tables that relate
-	   the rf and if gain with the dbm, so I just scale the value */
-	*strength = (512 - rf_gain - if_gain) << 7;
-	return 0;
-}
-
-static int af9005_fe_read_snr(struct dvb_frontend *fe, u16 * snr)
-{
-	/* the snr can be derived from the ber and the modulation
-	   but I don't think this kind of complex calculations belong
-	   in the driver. I may be wrong.... */
-	return -ENOSYS;
-}
-
-static int af9005_fe_program_cfoe(struct dvb_usb_device *d, u32 bw)
-{
-	u8 temp0, temp1, temp2, temp3, buf[4];
-	int ret;
-	u32 NS_coeff1_2048Nu;
-	u32 NS_coeff1_8191Nu;
-	u32 NS_coeff1_8192Nu;
-	u32 NS_coeff1_8193Nu;
-	u32 NS_coeff2_2k;
-	u32 NS_coeff2_8k;
-
-	switch (bw) {
-	case 6000000:
-		NS_coeff1_2048Nu = 0x2ADB6DC;
-		NS_coeff1_8191Nu = 0xAB7313;
-		NS_coeff1_8192Nu = 0xAB6DB7;
-		NS_coeff1_8193Nu = 0xAB685C;
-		NS_coeff2_2k = 0x156DB6E;
-		NS_coeff2_8k = 0x55B6DC;
-		break;
-
-	case 7000000:
-		NS_coeff1_2048Nu = 0x3200001;
-		NS_coeff1_8191Nu = 0xC80640;
-		NS_coeff1_8192Nu = 0xC80000;
-		NS_coeff1_8193Nu = 0xC7F9C0;
-		NS_coeff2_2k = 0x1900000;
-		NS_coeff2_8k = 0x640000;
-		break;
-
-	case 8000000:
-		NS_coeff1_2048Nu = 0x3924926;
-		NS_coeff1_8191Nu = 0xE4996E;
-		NS_coeff1_8192Nu = 0xE49249;
-		NS_coeff1_8193Nu = 0xE48B25;
-		NS_coeff2_2k = 0x1C92493;
-		NS_coeff2_8k = 0x724925;
-		break;
-	default:
-		err("Invalid bandwidth %d.", bw);
-		return -EINVAL;
-	}
-
-	/*
-	 *  write NS_coeff1_2048Nu
-	 */
-
-	temp0 = (u8) (NS_coeff1_2048Nu & 0x000000FF);
-	temp1 = (u8) ((NS_coeff1_2048Nu & 0x0000FF00) >> 8);
-	temp2 = (u8) ((NS_coeff1_2048Nu & 0x00FF0000) >> 16);
-	temp3 = (u8) ((NS_coeff1_2048Nu & 0x03000000) >> 24);
-
-	/*  big endian to make 8051 happy */
-	buf[0] = temp3;
-	buf[1] = temp2;
-	buf[2] = temp1;
-	buf[3] = temp0;
-
-	/*  cfoe_NS_2k_coeff1_25_24 */
-	ret = af9005_write_ofdm_register(d, 0xAE00, buf[0]);
-	if (ret)
-		return ret;
-
-	/*  cfoe_NS_2k_coeff1_23_16 */
-	ret = af9005_write_ofdm_register(d, 0xAE01, buf[1]);
-	if (ret)
-		return ret;
-
-	/*  cfoe_NS_2k_coeff1_15_8 */
-	ret = af9005_write_ofdm_register(d, 0xAE02, buf[2]);
-	if (ret)
-		return ret;
-
-	/*  cfoe_NS_2k_coeff1_7_0 */
-	ret = af9005_write_ofdm_register(d, 0xAE03, buf[3]);
-	if (ret)
-		return ret;
-
-	/*
-	 *  write NS_coeff2_2k
-	 */
-
-	temp0 = (u8) ((NS_coeff2_2k & 0x0000003F));
-	temp1 = (u8) ((NS_coeff2_2k & 0x00003FC0) >> 6);
-	temp2 = (u8) ((NS_coeff2_2k & 0x003FC000) >> 14);
-	temp3 = (u8) ((NS_coeff2_2k & 0x01C00000) >> 22);
-
-	/*  big endian to make 8051 happy */
-	buf[0] = temp3;
-	buf[1] = temp2;
-	buf[2] = temp1;
-	buf[3] = temp0;
-
-	ret = af9005_write_ofdm_register(d, 0xAE04, buf[0]);
-	if (ret)
-		return ret;
-
-	ret = af9005_write_ofdm_register(d, 0xAE05, buf[1]);
-	if (ret)
-		return ret;
-
-	ret = af9005_write_ofdm_register(d, 0xAE06, buf[2]);
-	if (ret)
-		return ret;
-
-	ret = af9005_write_ofdm_register(d, 0xAE07, buf[3]);
-	if (ret)
-		return ret;
-
-	/*
-	 *  write NS_coeff1_8191Nu
-	 */
-
-	temp0 = (u8) ((NS_coeff1_8191Nu & 0x000000FF));
-	temp1 = (u8) ((NS_coeff1_8191Nu & 0x0000FF00) >> 8);
-	temp2 = (u8) ((NS_coeff1_8191Nu & 0x00FFC000) >> 16);
-	temp3 = (u8) ((NS_coeff1_8191Nu & 0x03000000) >> 24);
-
-	/*  big endian to make 8051 happy */
-	buf[0] = temp3;
-	buf[1] = temp2;
-	buf[2] = temp1;
-	buf[3] = temp0;
-
-	ret = af9005_write_ofdm_register(d, 0xAE08, buf[0]);
-	if (ret)
-		return ret;
-
-	ret = af9005_write_ofdm_register(d, 0xAE09, buf[1]);
-	if (ret)
-		return ret;
-
-	ret = af9005_write_ofdm_register(d, 0xAE0A, buf[2]);
-	if (ret)
-		return ret;
-
-	ret = af9005_write_ofdm_register(d, 0xAE0B, buf[3]);
-	if (ret)
-		return ret;
-
-	/*
-	 *  write NS_coeff1_8192Nu
-	 */
-
-	temp0 = (u8) (NS_coeff1_8192Nu & 0x000000FF);
-	temp1 = (u8) ((NS_coeff1_8192Nu & 0x0000FF00) >> 8);
-	temp2 = (u8) ((NS_coeff1_8192Nu & 0x00FFC000) >> 16);
-	temp3 = (u8) ((NS_coeff1_8192Nu & 0x03000000) >> 24);
-
-	/*  big endian to make 8051 happy */
-	buf[0] = temp3;
-	buf[1] = temp2;
-	buf[2] = temp1;
-	buf[3] = temp0;
-
-	ret = af9005_write_ofdm_register(d, 0xAE0C, buf[0]);
-	if (ret)
-		return ret;
-
-	ret = af9005_write_ofdm_register(d, 0xAE0D, buf[1]);
-	if (ret)
-		return ret;
-
-	ret = af9005_write_ofdm_register(d, 0xAE0E, buf[2]);
-	if (ret)
-		return ret;
-
-	ret = af9005_write_ofdm_register(d, 0xAE0F, buf[3]);
-	if (ret)
-		return ret;
-
-	/*
-	 *  write NS_coeff1_8193Nu
-	 */
-
-	temp0 = (u8) ((NS_coeff1_8193Nu & 0x000000FF));
-	temp1 = (u8) ((NS_coeff1_8193Nu & 0x0000FF00) >> 8);
-	temp2 = (u8) ((NS_coeff1_8193Nu & 0x00FFC000) >> 16);
-	temp3 = (u8) ((NS_coeff1_8193Nu & 0x03000000) >> 24);
-
-	/*  big endian to make 8051 happy */
-	buf[0] = temp3;
-	buf[1] = temp2;
-	buf[2] = temp1;
-	buf[3] = temp0;
-
-	ret = af9005_write_ofdm_register(d, 0xAE10, buf[0]);
-	if (ret)
-		return ret;
-
-	ret = af9005_write_ofdm_register(d, 0xAE11, buf[1]);
-	if (ret)
-		return ret;
-
-	ret = af9005_write_ofdm_register(d, 0xAE12, buf[2]);
-	if (ret)
-		return ret;
-
-	ret = af9005_write_ofdm_register(d, 0xAE13, buf[3]);
-	if (ret)
-		return ret;
-
-	/*
-	 *  write NS_coeff2_8k
-	 */
-
-	temp0 = (u8) ((NS_coeff2_8k & 0x0000003F));
-	temp1 = (u8) ((NS_coeff2_8k & 0x00003FC0) >> 6);
-	temp2 = (u8) ((NS_coeff2_8k & 0x003FC000) >> 14);
-	temp3 = (u8) ((NS_coeff2_8k & 0x01C00000) >> 22);
-
-	/*  big endian to make 8051 happy */
-	buf[0] = temp3;
-	buf[1] = temp2;
-	buf[2] = temp1;
-	buf[3] = temp0;
-
-	ret = af9005_write_ofdm_register(d, 0xAE14, buf[0]);
-	if (ret)
-		return ret;
-
-	ret = af9005_write_ofdm_register(d, 0xAE15, buf[1]);
-	if (ret)
-		return ret;
-
-	ret = af9005_write_ofdm_register(d, 0xAE16, buf[2]);
-	if (ret)
-		return ret;
-
-	ret = af9005_write_ofdm_register(d, 0xAE17, buf[3]);
-	return ret;
-
-}
-
-static int af9005_fe_select_bw(struct dvb_usb_device *d, u32 bw)
-{
-	u8 temp;
-	switch (bw) {
-	case 6000000:
-		temp = 0;
-		break;
-	case 7000000:
-		temp = 1;
-		break;
-	case 8000000:
-		temp = 2;
-		break;
-	default:
-		err("Invalid bandwidth %d.", bw);
-		return -EINVAL;
-	}
-	return af9005_write_register_bits(d, xd_g_reg_bw, reg_bw_pos,
-					  reg_bw_len, temp);
-}
-
-static int af9005_fe_power(struct dvb_frontend *fe, int on)
-{
-	struct af9005_fe_state *state = fe->demodulator_priv;
-	u8 temp = on;
-	int ret;
-	deb_info("power %s tuner\n", on ? "on" : "off");
-	ret = af9005_send_command(state->d, 0x03, &temp, 1, NULL, 0);
-	return ret;
-}
-
-static struct mt2060_config af9005_mt2060_config = {
-	0xC0
-};
-
-static struct qt1010_config af9005_qt1010_config = {
-	0xC4
-};
-
-static int af9005_fe_init(struct dvb_frontend *fe)
-{
-	struct af9005_fe_state *state = fe->demodulator_priv;
-	struct dvb_usb_adapter *adap = fe->dvb->priv;
-	int ret, i, scriptlen;
-	u8 temp, temp0 = 0, temp1 = 0, temp2 = 0;
-	u8 buf[2];
-	u16 if1;
-
-	deb_info("in af9005_fe_init\n");
-
-	/* reset */
-	deb_info("reset\n");
-	if ((ret =
-	     af9005_write_register_bits(state->d, xd_I2C_reg_ofdm_rst_en,
-					4, 1, 0x01)))
-		return ret;
-	if ((ret = af9005_write_ofdm_register(state->d, APO_REG_RESET, 0)))
-		return ret;
-	/* clear ofdm reset */
-	deb_info("clear ofdm reset\n");
-	for (i = 0; i < 150; i++) {
-		if ((ret =
-		     af9005_read_ofdm_register(state->d,
-					       xd_I2C_reg_ofdm_rst, &temp)))
-			return ret;
-		if (temp & (regmask[reg_ofdm_rst_len - 1] << reg_ofdm_rst_pos))
-			break;
-		msleep(10);
-	}
-	if (i == 150)
-		return -ETIMEDOUT;
-
-	/*FIXME in the dump
-	   write B200 A9
-	   write xd_g_reg_ofsm_clk 7
-	   read eepr c6 (2)
-	   read eepr c7 (2)
-	   misc ctrl 3 -> 1
-	   read eepr ca (6)
-	   write xd_g_reg_ofsm_clk 0
-	   write B200 a1
-	 */
-	ret = af9005_write_ofdm_register(state->d, 0xb200, 0xa9);
-	if (ret)
-		return ret;
-	ret = af9005_write_ofdm_register(state->d, xd_g_reg_ofsm_clk, 0x07);
-	if (ret)
-		return ret;
-	temp = 0x01;
-	ret = af9005_send_command(state->d, 0x03, &temp, 1, NULL, 0);
-	if (ret)
-		return ret;
-	ret = af9005_write_ofdm_register(state->d, xd_g_reg_ofsm_clk, 0x00);
-	if (ret)
-		return ret;
-	ret = af9005_write_ofdm_register(state->d, 0xb200, 0xa1);
-	if (ret)
-		return ret;
-
-	temp = regmask[reg_ofdm_rst_len - 1] << reg_ofdm_rst_pos;
-	if ((ret =
-	     af9005_write_register_bits(state->d, xd_I2C_reg_ofdm_rst,
-					reg_ofdm_rst_pos, reg_ofdm_rst_len, 1)))
-		return ret;
-	ret = af9005_write_register_bits(state->d, xd_I2C_reg_ofdm_rst,
-					 reg_ofdm_rst_pos, reg_ofdm_rst_len, 0);
-
-	if (ret)
-		return ret;
-	/* don't know what register aefc is, but this is what the windows driver does */
-	ret = af9005_write_ofdm_register(state->d, 0xaefc, 0);
-	if (ret)
-		return ret;
-
-	/* set stand alone chip */
-	deb_info("set stand alone chip\n");
-	if ((ret =
-	     af9005_write_register_bits(state->d, xd_p_reg_dca_stand_alone,
-					reg_dca_stand_alone_pos,
-					reg_dca_stand_alone_len, 1)))
-		return ret;
-
-	/* set dca upper & lower chip */
-	deb_info("set dca upper & lower chip\n");
-	if ((ret =
-	     af9005_write_register_bits(state->d, xd_p_reg_dca_upper_chip,
-					reg_dca_upper_chip_pos,
-					reg_dca_upper_chip_len, 0)))
-		return ret;
-	if ((ret =
-	     af9005_write_register_bits(state->d, xd_p_reg_dca_lower_chip,
-					reg_dca_lower_chip_pos,
-					reg_dca_lower_chip_len, 0)))
-		return ret;
-
-	/* set 2wire master clock to 0x14 (for 60KHz) */
-	deb_info("set 2wire master clock to 0x14 (for 60KHz)\n");
-	if ((ret =
-	     af9005_write_ofdm_register(state->d, xd_I2C_i2c_m_period, 0x14)))
-		return ret;
-
-	/* clear dca enable chip */
-	deb_info("clear dca enable chip\n");
-	if ((ret =
-	     af9005_write_register_bits(state->d, xd_p_reg_dca_en,
-					reg_dca_en_pos, reg_dca_en_len, 0)))
-		return ret;
-	/* FIXME these are register bits, but I don't know which ones */
-	ret = af9005_write_ofdm_register(state->d, 0xa16c, 1);
-	if (ret)
-		return ret;
-	ret = af9005_write_ofdm_register(state->d, 0xa3c1, 0);
-	if (ret)
-		return ret;
-
-	/* init other parameters: program cfoe and select bandwidth */
-	deb_info("program cfoe\n");
-	ret = af9005_fe_program_cfoe(state->d, 6000000);
-	if (ret)
-		return ret;
-	/* set read-update bit for modulation */
-	deb_info("set read-update bit for modulation\n");
-	if ((ret =
-	     af9005_write_register_bits(state->d, xd_p_reg_feq_read_update,
-					reg_feq_read_update_pos,
-					reg_feq_read_update_len, 1)))
-		return ret;
-
-	/* sample code has a set MPEG TS code here
-	   but sniffing reveals that it doesn't do it */
-
-	/* set read-update bit to 1 for DCA modulation */
-	deb_info("set read-update bit 1 for DCA modulation\n");
-	if ((ret =
-	     af9005_write_register_bits(state->d, xd_p_reg_dca_read_update,
-					reg_dca_read_update_pos,
-					reg_dca_read_update_len, 1)))
-		return ret;
-
-	/* enable fec monitor */
-	deb_info("enable fec monitor\n");
-	if ((ret =
-	     af9005_write_register_bits(state->d, xd_p_fec_vtb_rsd_mon_en,
-					fec_vtb_rsd_mon_en_pos,
-					fec_vtb_rsd_mon_en_len, 1)))
-		return ret;
-
-	/* FIXME should be register bits, I don't know which ones */
-	ret = af9005_write_ofdm_register(state->d, 0xa601, 0);
-
-	/* set api_retrain_never_freeze */
-	deb_info("set api_retrain_never_freeze\n");
-	if ((ret = af9005_write_ofdm_register(state->d, 0xaefb, 0x01)))
-		return ret;
-
-	/* load init script */
-	deb_info("load init script\n");
-	scriptlen = sizeof(script) / sizeof(RegDesc);
-	for (i = 0; i < scriptlen; i++) {
-		if ((ret =
-		     af9005_write_register_bits(state->d, script[i].reg,
-						script[i].pos,
-						script[i].len, script[i].val)))
-			return ret;
-		/* save 3 bytes of original fcw */
-		if (script[i].reg == 0xae18)
-			temp2 = script[i].val;
-		if (script[i].reg == 0xae19)
-			temp1 = script[i].val;
-		if (script[i].reg == 0xae1a)
-			temp0 = script[i].val;
-
-		/* save original unplug threshold */
-		if (script[i].reg == xd_p_reg_unplug_th)
-			state->original_if_unplug_th = script[i].val;
-		if (script[i].reg == xd_p_reg_unplug_rf_gain_th)
-			state->original_rf_unplug_th = script[i].val;
-		if (script[i].reg == xd_p_reg_unplug_dtop_if_gain_th)
-			state->original_dtop_if_unplug_th = script[i].val;
-		if (script[i].reg == xd_p_reg_unplug_dtop_rf_gain_th)
-			state->original_dtop_rf_unplug_th = script[i].val;
-
-	}
-	state->original_fcw =
-	    ((u32) temp2 << 16) + ((u32) temp1 << 8) + (u32) temp0;
-
-
-	/* save original TOPs */
-	deb_info("save original TOPs\n");
-
-	/*  RF TOP */
-	ret =
-	    af9005_read_word_agc(state->d,
-				 xd_p_reg_aagc_rf_top_numerator_9_8,
-				 xd_p_reg_aagc_rf_top_numerator_7_0, 0, 2,
-				 &state->original_rf_top);
-	if (ret)
-		return ret;
-
-	/*  IF TOP */
-	ret =
-	    af9005_read_word_agc(state->d,
-				 xd_p_reg_aagc_if_top_numerator_9_8,
-				 xd_p_reg_aagc_if_top_numerator_7_0, 0, 2,
-				 &state->original_if_top);
-	if (ret)
-		return ret;
-
-	/*  ACI 0 IF TOP */
-	ret =
-	    af9005_read_word_agc(state->d, 0xA60E, 0xA60A, 4, 2,
-				 &state->original_aci0_if_top);
-	if (ret)
-		return ret;
-
-	/*  ACI 1 IF TOP */
-	ret =
-	    af9005_read_word_agc(state->d, 0xA60E, 0xA60B, 6, 2,
-				 &state->original_aci1_if_top);
-	if (ret)
-		return ret;
-
-	/* attach tuner and init */
-	if (fe->ops.tuner_ops.release == NULL) {
-		/* read tuner and board id from eeprom */
-		ret = af9005_read_eeprom(adap->dev, 0xc6, buf, 2);
-		if (ret) {
-			err("Impossible to read EEPROM\n");
-			return ret;
-		}
-		deb_info("Tuner id %d, board id %d\n", buf[0], buf[1]);
-		switch (buf[0]) {
-		case 2:	/* MT2060 */
-			/* read if1 from eeprom */
-			ret = af9005_read_eeprom(adap->dev, 0xc8, buf, 2);
-			if (ret) {
-				err("Impossible to read EEPROM\n");
-				return ret;
-			}
-			if1 = (u16) (buf[0] << 8) + buf[1];
-			if (dvb_attach(mt2060_attach, fe, &adap->dev->i2c_adap,
-					 &af9005_mt2060_config, if1) == NULL) {
-				deb_info("MT2060 attach failed\n");
-				return -ENODEV;
-			}
-			break;
-		case 3:	/* QT1010 */
-		case 9:	/* QT1010B */
-			if (dvb_attach(qt1010_attach, fe, &adap->dev->i2c_adap,
-					&af9005_qt1010_config) ==NULL) {
-				deb_info("QT1010 attach failed\n");
-				return -ENODEV;
-			}
-			break;
-		default:
-			err("Unsupported tuner type %d", buf[0]);
-			return -ENODEV;
-		}
-		ret = fe->ops.tuner_ops.init(fe);
-		if (ret)
-			return ret;
-	}
-
-	deb_info("profit!\n");
-	return 0;
-}
-
-static int af9005_fe_sleep(struct dvb_frontend *fe)
-{
-	return af9005_fe_power(fe, 0);
-}
-
-static int af9005_ts_bus_ctrl(struct dvb_frontend *fe, int acquire)
-{
-	struct af9005_fe_state *state = fe->demodulator_priv;
-
-	if (acquire) {
-		state->opened++;
-	} else {
-
-		state->opened--;
-		if (!state->opened)
-			af9005_led_control(state->d, 0);
-	}
-	return 0;
-}
-
-static int af9005_fe_set_frontend(struct dvb_frontend *fe)
-{
-	struct dtv_frontend_properties *fep = &fe->dtv_property_cache;
-	struct af9005_fe_state *state = fe->demodulator_priv;
-	int ret;
-	u8 temp, temp0, temp1, temp2;
-
-	deb_info("af9005_fe_set_frontend freq %d bw %d\n", fep->frequency,
-		 fep->bandwidth_hz);
-	if (fe->ops.tuner_ops.release == NULL) {
-		err("Tuner not attached");
-		return -ENODEV;
-	}
-
-	deb_info("turn off led\n");
-	/* not in the log */
-	ret = af9005_led_control(state->d, 0);
-	if (ret)
-		return ret;
-	/* not sure about the bits */
-	ret = af9005_write_register_bits(state->d, XD_MP2IF_MISC, 2, 1, 0);
-	if (ret)
-		return ret;
-
-	/* set FCW to default value */
-	deb_info("set FCW to default value\n");
-	temp0 = (u8) (state->original_fcw & 0x000000ff);
-	temp1 = (u8) ((state->original_fcw & 0x0000ff00) >> 8);
-	temp2 = (u8) ((state->original_fcw & 0x00ff0000) >> 16);
-	ret = af9005_write_ofdm_register(state->d, 0xae1a, temp0);
-	if (ret)
-		return ret;
-	ret = af9005_write_ofdm_register(state->d, 0xae19, temp1);
-	if (ret)
-		return ret;
-	ret = af9005_write_ofdm_register(state->d, 0xae18, temp2);
-	if (ret)
-		return ret;
-
-	/* restore original TOPs */
-	deb_info("restore original TOPs\n");
-	ret =
-	    af9005_write_word_agc(state->d,
-				  xd_p_reg_aagc_rf_top_numerator_9_8,
-				  xd_p_reg_aagc_rf_top_numerator_7_0, 0, 2,
-				  state->original_rf_top);
-	if (ret)
-		return ret;
-	ret =
-	    af9005_write_word_agc(state->d,
-				  xd_p_reg_aagc_if_top_numerator_9_8,
-				  xd_p_reg_aagc_if_top_numerator_7_0, 0, 2,
-				  state->original_if_top);
-	if (ret)
-		return ret;
-	ret =
-	    af9005_write_word_agc(state->d, 0xA60E, 0xA60A, 4, 2,
-				  state->original_aci0_if_top);
-	if (ret)
-		return ret;
-	ret =
-	    af9005_write_word_agc(state->d, 0xA60E, 0xA60B, 6, 2,
-				  state->original_aci1_if_top);
-	if (ret)
-		return ret;
-
-	/* select bandwidth */
-	deb_info("select bandwidth");
-	ret = af9005_fe_select_bw(state->d, fep->bandwidth_hz);
-	if (ret)
-		return ret;
-	ret = af9005_fe_program_cfoe(state->d, fep->bandwidth_hz);
-	if (ret)
-		return ret;
-
-	/* clear easy mode flag */
-	deb_info("clear easy mode flag\n");
-	ret = af9005_write_ofdm_register(state->d, 0xaefd, 0);
-	if (ret)
-		return ret;
-
-	/* set unplug threshold to original value */
-	deb_info("set unplug threshold to original value\n");
-	ret =
-	    af9005_write_ofdm_register(state->d, xd_p_reg_unplug_th,
-				       state->original_if_unplug_th);
-	if (ret)
-		return ret;
-	/* set tuner */
-	deb_info("set tuner\n");
-	ret = fe->ops.tuner_ops.set_params(fe);
-	if (ret)
-		return ret;
-
-	/* trigger ofsm */
-	deb_info("trigger ofsm\n");
-	temp = 0;
-	ret = af9005_write_tuner_registers(state->d, 0xffff, &temp, 1);
-	if (ret)
-		return ret;
-
-	/* clear retrain and freeze flag */
-	deb_info("clear retrain and freeze flag\n");
-	ret =
-	    af9005_write_register_bits(state->d,
-				       xd_p_reg_api_retrain_request,
-				       reg_api_retrain_request_pos, 2, 0);
-	if (ret)
-		return ret;
-
-	/* reset pre viterbi and post viterbi registers and statistics */
-	af9005_reset_pre_viterbi(fe);
-	af9005_reset_post_viterbi(fe);
-	state->pre_vit_error_count = 0;
-	state->pre_vit_bit_count = 0;
-	state->ber = 0;
-	state->post_vit_error_count = 0;
-	/* state->unc = 0; commented out since it should be ever increasing */
-	state->abort_count = 0;
-
-	state->next_status_check = jiffies;
-	state->strong = -1;
-
-	return 0;
-}
-
-static int af9005_fe_get_frontend(struct dvb_frontend *fe,
-				  struct dtv_frontend_properties *fep)
-{
-	struct af9005_fe_state *state = fe->demodulator_priv;
-	int ret;
-	u8 temp;
-
-	/* mode */
-	ret =
-	    af9005_read_register_bits(state->d, xd_g_reg_tpsd_const,
-				      reg_tpsd_const_pos, reg_tpsd_const_len,
-				      &temp);
-	if (ret)
-		return ret;
-	deb_info("===== fe_get_frontend_legacy = =============\n");
-	deb_info("CONSTELLATION ");
-	switch (temp) {
-	case 0:
-		fep->modulation = QPSK;
-		deb_info("QPSK\n");
-		break;
-	case 1:
-		fep->modulation = QAM_16;
-		deb_info("QAM_16\n");
-		break;
-	case 2:
-		fep->modulation = QAM_64;
-		deb_info("QAM_64\n");
-		break;
-	}
-
-	/* tps hierarchy and alpha value */
-	ret =
-	    af9005_read_register_bits(state->d, xd_g_reg_tpsd_hier,
-				      reg_tpsd_hier_pos, reg_tpsd_hier_len,
-				      &temp);
-	if (ret)
-		return ret;
-	deb_info("HIERARCHY ");
-	switch (temp) {
-	case 0:
-		fep->hierarchy = HIERARCHY_NONE;
-		deb_info("NONE\n");
-		break;
-	case 1:
-		fep->hierarchy = HIERARCHY_1;
-		deb_info("1\n");
-		break;
-	case 2:
-		fep->hierarchy = HIERARCHY_2;
-		deb_info("2\n");
-		break;
-	case 3:
-		fep->hierarchy = HIERARCHY_4;
-		deb_info("4\n");
-		break;
-	}
-
-	/*  high/low priority     */
-	ret =
-	    af9005_read_register_bits(state->d, xd_g_reg_dec_pri,
-				      reg_dec_pri_pos, reg_dec_pri_len, &temp);
-	if (ret)
-		return ret;
-	/* if temp is set = high priority */
-	deb_info("PRIORITY %s\n", temp ? "high" : "low");
-
-	/* high coderate */
-	ret =
-	    af9005_read_register_bits(state->d, xd_g_reg_tpsd_hpcr,
-				      reg_tpsd_hpcr_pos, reg_tpsd_hpcr_len,
-				      &temp);
-	if (ret)
-		return ret;
-	deb_info("CODERATE HP ");
-	switch (temp) {
-	case 0:
-		fep->code_rate_HP = FEC_1_2;
-		deb_info("FEC_1_2\n");
-		break;
-	case 1:
-		fep->code_rate_HP = FEC_2_3;
-		deb_info("FEC_2_3\n");
-		break;
-	case 2:
-		fep->code_rate_HP = FEC_3_4;
-		deb_info("FEC_3_4\n");
-		break;
-	case 3:
-		fep->code_rate_HP = FEC_5_6;
-		deb_info("FEC_5_6\n");
-		break;
-	case 4:
-		fep->code_rate_HP = FEC_7_8;
-		deb_info("FEC_7_8\n");
-		break;
-	}
-
-	/* low coderate */
-	ret =
-	    af9005_read_register_bits(state->d, xd_g_reg_tpsd_lpcr,
-				      reg_tpsd_lpcr_pos, reg_tpsd_lpcr_len,
-				      &temp);
-	if (ret)
-		return ret;
-	deb_info("CODERATE LP ");
-	switch (temp) {
-	case 0:
-		fep->code_rate_LP = FEC_1_2;
-		deb_info("FEC_1_2\n");
-		break;
-	case 1:
-		fep->code_rate_LP = FEC_2_3;
-		deb_info("FEC_2_3\n");
-		break;
-	case 2:
-		fep->code_rate_LP = FEC_3_4;
-		deb_info("FEC_3_4\n");
-		break;
-	case 3:
-		fep->code_rate_LP = FEC_5_6;
-		deb_info("FEC_5_6\n");
-		break;
-	case 4:
-		fep->code_rate_LP = FEC_7_8;
-		deb_info("FEC_7_8\n");
-		break;
-	}
-
-	/* guard interval */
-	ret =
-	    af9005_read_register_bits(state->d, xd_g_reg_tpsd_gi,
-				      reg_tpsd_gi_pos, reg_tpsd_gi_len, &temp);
-	if (ret)
-		return ret;
-	deb_info("GUARD INTERVAL ");
-	switch (temp) {
-	case 0:
-		fep->guard_interval = GUARD_INTERVAL_1_32;
-		deb_info("1_32\n");
-		break;
-	case 1:
-		fep->guard_interval = GUARD_INTERVAL_1_16;
-		deb_info("1_16\n");
-		break;
-	case 2:
-		fep->guard_interval = GUARD_INTERVAL_1_8;
-		deb_info("1_8\n");
-		break;
-	case 3:
-		fep->guard_interval = GUARD_INTERVAL_1_4;
-		deb_info("1_4\n");
-		break;
-	}
-
-	/* fft */
-	ret =
-	    af9005_read_register_bits(state->d, xd_g_reg_tpsd_txmod,
-				      reg_tpsd_txmod_pos, reg_tpsd_txmod_len,
-				      &temp);
-	if (ret)
-		return ret;
-	deb_info("TRANSMISSION MODE ");
-	switch (temp) {
-	case 0:
-		fep->transmission_mode = TRANSMISSION_MODE_2K;
-		deb_info("2K\n");
-		break;
-	case 1:
-		fep->transmission_mode = TRANSMISSION_MODE_8K;
-		deb_info("8K\n");
-		break;
-	}
-
-	/* bandwidth      */
-	ret =
-	    af9005_read_register_bits(state->d, xd_g_reg_bw, reg_bw_pos,
-				      reg_bw_len, &temp);
-	deb_info("BANDWIDTH ");
-	switch (temp) {
-	case 0:
-		fep->bandwidth_hz = 6000000;
-		deb_info("6\n");
-		break;
-	case 1:
-		fep->bandwidth_hz = 7000000;
-		deb_info("7\n");
-		break;
-	case 2:
-		fep->bandwidth_hz = 8000000;
-		deb_info("8\n");
-		break;
-	}
-	return 0;
-}
-
-static void af9005_fe_release(struct dvb_frontend *fe)
-{
-	struct af9005_fe_state *state =
-	    (struct af9005_fe_state *)fe->demodulator_priv;
-	kfree(state);
-}
-
-static const struct dvb_frontend_ops af9005_fe_ops;
-
-struct dvb_frontend *af9005_fe_attach(struct dvb_usb_device *d)
-{
-	struct af9005_fe_state *state = NULL;
-
-	/* allocate memory for the internal state */
-	state = kzalloc(sizeof(struct af9005_fe_state), GFP_KERNEL);
-	if (state == NULL)
-		goto error;
-
-	deb_info("attaching frontend af9005\n");
-
-	state->d = d;
-	state->opened = 0;
-
-	memcpy(&state->frontend.ops, &af9005_fe_ops,
-	       sizeof(struct dvb_frontend_ops));
-	state->frontend.demodulator_priv = state;
-
-	return &state->frontend;
-      error:
-	return NULL;
-}
-
-static const struct dvb_frontend_ops af9005_fe_ops = {
-	.delsys = { SYS_DVBT },
-	.info = {
-		 .name = "AF9005 USB DVB-T",
-		 .frequency_min = 44250000,
-		 .frequency_max = 867250000,
-		 .frequency_stepsize = 250000,
-		 .caps = FE_CAN_INVERSION_AUTO |
-		 FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
-		 FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
-		 FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 |
-		 FE_CAN_QAM_AUTO | FE_CAN_TRANSMISSION_MODE_AUTO |
-		 FE_CAN_GUARD_INTERVAL_AUTO | FE_CAN_RECOVER |
-		 FE_CAN_HIERARCHY_AUTO,
-		 },
-
-	.release = af9005_fe_release,
-
-	.init = af9005_fe_init,
-	.sleep = af9005_fe_sleep,
-	.ts_bus_ctrl = af9005_ts_bus_ctrl,
-
-	.set_frontend = af9005_fe_set_frontend,
-	.get_frontend = af9005_fe_get_frontend,
-
-	.read_status = af9005_fe_read_status,
-	.read_ber = af9005_fe_read_ber,
-	.read_signal_strength = af9005_fe_read_signal_strength,
-	.read_snr = af9005_fe_read_snr,
-	.read_ucblocks = af9005_fe_read_unc_blocks,
-};
diff -ruN ../linux-4.14.336/drivers/media/usb/dvb-usb/af9005-remote.c ./drivers/media/usb/dvb-usb/af9005-remote.c
--- linux-4.14.336/../linux-4.14.336/drivers/media/usb/dvb-usb/af9005-remote.c	2024-01-10 14:45:41.000000000 +0100
+++ linux-4.14.336/./drivers/media/usb/dvb-usb/af9005-remote.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,153 +0,0 @@
-/* DVB USB compliant Linux driver for the Afatech 9005
- * USB1.1 DVB-T receiver.
- *
- * Standard remote decode function
- *
- * Copyright (C) 2007 Luca Olivetti (luca@ventoso.org)
- *
- * Thanks to Afatech who kindly provided information.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * see Documentation/dvb/README.dvb-usb for more information
- */
-#include "af9005.h"
-/* debug */
-static int dvb_usb_af9005_remote_debug;
-module_param_named(debug, dvb_usb_af9005_remote_debug, int, 0644);
-MODULE_PARM_DESC(debug,
-		 "enable (1) or disable (0) debug messages."
-		 DVB_USB_DEBUG_STATUS);
-
-#define deb_decode(args...)   dprintk(dvb_usb_af9005_remote_debug,0x01,args)
-
-struct rc_map_table rc_map_af9005_table[] = {
-
-	{0x01b7, KEY_POWER},
-	{0x01a7, KEY_VOLUMEUP},
-	{0x0187, KEY_CHANNELUP},
-	{0x017f, KEY_MUTE},
-	{0x01bf, KEY_VOLUMEDOWN},
-	{0x013f, KEY_CHANNELDOWN},
-	{0x01df, KEY_1},
-	{0x015f, KEY_2},
-	{0x019f, KEY_3},
-	{0x011f, KEY_4},
-	{0x01ef, KEY_5},
-	{0x016f, KEY_6},
-	{0x01af, KEY_7},
-	{0x0127, KEY_8},
-	{0x0107, KEY_9},
-	{0x01cf, KEY_ZOOM},
-	{0x014f, KEY_0},
-	{0x018f, KEY_GOTO},	/* marked jump on the remote */
-
-	{0x00bd, KEY_POWER},
-	{0x007d, KEY_VOLUMEUP},
-	{0x00fd, KEY_CHANNELUP},
-	{0x009d, KEY_MUTE},
-	{0x005d, KEY_VOLUMEDOWN},
-	{0x00dd, KEY_CHANNELDOWN},
-	{0x00ad, KEY_1},
-	{0x006d, KEY_2},
-	{0x00ed, KEY_3},
-	{0x008d, KEY_4},
-	{0x004d, KEY_5},
-	{0x00cd, KEY_6},
-	{0x00b5, KEY_7},
-	{0x0075, KEY_8},
-	{0x00f5, KEY_9},
-	{0x0095, KEY_ZOOM},
-	{0x0055, KEY_0},
-	{0x00d5, KEY_GOTO},	/* marked jump on the remote */
-};
-
-int rc_map_af9005_table_size = ARRAY_SIZE(rc_map_af9005_table);
-
-static int repeatable_keys[] = {
-	KEY_VOLUMEUP,
-	KEY_VOLUMEDOWN,
-	KEY_CHANNELUP,
-	KEY_CHANNELDOWN
-};
-
-int af9005_rc_decode(struct dvb_usb_device *d, u8 * data, int len, u32 * event,
-		     int *state)
-{
-	u16 mark, space;
-	u32 result;
-	u8 cust, dat, invdat;
-	int i;
-
-	if (len >= 6) {
-		mark = (u16) (data[0] << 8) + data[1];
-		space = (u16) (data[2] << 8) + data[3];
-		if (space * 3 < mark) {
-			for (i = 0; i < ARRAY_SIZE(repeatable_keys); i++) {
-				if (d->last_event == repeatable_keys[i]) {
-					*state = REMOTE_KEY_REPEAT;
-					*event = d->last_event;
-					deb_decode("repeat key, event %x\n",
-						   *event);
-					return 0;
-				}
-			}
-			deb_decode("repeated key ignored (non repeatable)\n");
-			return 0;
-		} else if (len >= 33 * 4) {	/*32 bits + start code */
-			result = 0;
-			for (i = 4; i < 4 + 32 * 4; i += 4) {
-				result <<= 1;
-				mark = (u16) (data[i] << 8) + data[i + 1];
-				mark >>= 1;
-				space = (u16) (data[i + 2] << 8) + data[i + 3];
-				space >>= 1;
-				if (mark * 2 > space)
-					result += 1;
-			}
-			deb_decode("key pressed, raw value %x\n", result);
-			if ((result & 0xff000000) != 0xfe000000) {
-				deb_decode
-				    ("doesn't start with 0xfe, ignored\n");
-				return 0;
-			}
-			cust = (result >> 16) & 0xff;
-			dat = (result >> 8) & 0xff;
-			invdat = (~result) & 0xff;
-			if (dat != invdat) {
-				deb_decode("code != inverted code\n");
-				return 0;
-			}
-			for (i = 0; i < rc_map_af9005_table_size; i++) {
-				if (rc5_custom(&rc_map_af9005_table[i]) == cust
-				    && rc5_data(&rc_map_af9005_table[i]) == dat) {
-					*event = rc_map_af9005_table[i].keycode;
-					*state = REMOTE_KEY_PRESSED;
-					deb_decode
-					    ("key pressed, event %x\n", *event);
-					return 0;
-				}
-			}
-			deb_decode("not found in table\n");
-		}
-	}
-	return 0;
-}
-
-EXPORT_SYMBOL(rc_map_af9005_table);
-EXPORT_SYMBOL(rc_map_af9005_table_size);
-EXPORT_SYMBOL(af9005_rc_decode);
-
-MODULE_AUTHOR("Luca Olivetti <luca@ventoso.org>");
-MODULE_DESCRIPTION
-    ("Standard remote control decoder for Afatech 9005 DVB-T USB1.1 stick");
-MODULE_VERSION("1.0");
-MODULE_LICENSE("GPL");
diff -ruN ../linux-4.14.336/drivers/media/usb/dvb-usb/af9005-script.h ./drivers/media/usb/dvb-usb/af9005-script.h
--- linux-4.14.336/../linux-4.14.336/drivers/media/usb/dvb-usb/af9005-script.h	2024-01-10 14:45:41.000000000 +0100
+++ linux-4.14.336/./drivers/media/usb/dvb-usb/af9005-script.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,204 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
-File automatically generated by createinit.py using data
-extracted from AF05BDA.sys (windows driver):
-
-dd if=AF05BDA.sys of=initsequence bs=1 skip=88316 count=1110
-python createinit.py > af9005-script.h
-
-*/
-
-typedef struct {
-	u16 reg;
-	u8 pos;
-	u8 len;
-	u8 val;
-} RegDesc;
-
-static RegDesc script[] = {
-	{0xa180, 0x0, 0x8, 0xa},
-	{0xa181, 0x0, 0x8, 0xd7},
-	{0xa182, 0x0, 0x8, 0xa3},
-	{0xa0a0, 0x0, 0x8, 0x0},
-	{0xa0a1, 0x0, 0x5, 0x0},
-	{0xa0a1, 0x5, 0x1, 0x1},
-	{0xa0c0, 0x0, 0x4, 0x1},
-	{0xa20e, 0x4, 0x4, 0xa},
-	{0xa20f, 0x0, 0x8, 0x40},
-	{0xa210, 0x0, 0x8, 0x8},
-	{0xa32a, 0x0, 0x4, 0xa},
-	{0xa32c, 0x0, 0x8, 0x20},
-	{0xa32b, 0x0, 0x8, 0x15},
-	{0xa1a0, 0x1, 0x1, 0x1},
-	{0xa000, 0x0, 0x1, 0x1},
-	{0xa000, 0x1, 0x1, 0x0},
-	{0xa001, 0x1, 0x1, 0x1},
-	{0xa001, 0x0, 0x1, 0x0},
-	{0xa001, 0x5, 0x1, 0x0},
-	{0xa00e, 0x0, 0x5, 0x10},
-	{0xa00f, 0x0, 0x3, 0x4},
-	{0xa00f, 0x3, 0x3, 0x5},
-	{0xa010, 0x0, 0x3, 0x4},
-	{0xa010, 0x3, 0x3, 0x5},
-	{0xa016, 0x4, 0x4, 0x3},
-	{0xa01f, 0x0, 0x6, 0xa},
-	{0xa020, 0x0, 0x6, 0xa},
-	{0xa2bc, 0x0, 0x1, 0x1},
-	{0xa2bc, 0x5, 0x1, 0x1},
-	{0xa015, 0x0, 0x8, 0x50},
-	{0xa016, 0x0, 0x1, 0x0},
-	{0xa02a, 0x0, 0x8, 0x50},
-	{0xa029, 0x0, 0x8, 0x4b},
-	{0xa614, 0x0, 0x8, 0x46},
-	{0xa002, 0x0, 0x5, 0x19},
-	{0xa003, 0x0, 0x5, 0x1a},
-	{0xa004, 0x0, 0x5, 0x19},
-	{0xa005, 0x0, 0x5, 0x1a},
-	{0xa008, 0x0, 0x8, 0x69},
-	{0xa009, 0x0, 0x2, 0x2},
-	{0xae1b, 0x0, 0x8, 0x69},
-	{0xae1c, 0x0, 0x8, 0x2},
-	{0xae1d, 0x0, 0x8, 0x2a},
-	{0xa022, 0x0, 0x8, 0xaa},
-	{0xa006, 0x0, 0x8, 0xc8},
-	{0xa007, 0x0, 0x2, 0x0},
-	{0xa00c, 0x0, 0x8, 0xba},
-	{0xa00d, 0x0, 0x2, 0x2},
-	{0xa608, 0x0, 0x8, 0xba},
-	{0xa60e, 0x0, 0x2, 0x2},
-	{0xa609, 0x0, 0x8, 0x80},
-	{0xa60e, 0x2, 0x2, 0x3},
-	{0xa00a, 0x0, 0x8, 0xb6},
-	{0xa00b, 0x0, 0x2, 0x0},
-	{0xa011, 0x0, 0x8, 0xb9},
-	{0xa012, 0x0, 0x2, 0x0},
-	{0xa013, 0x0, 0x8, 0xbd},
-	{0xa014, 0x0, 0x2, 0x2},
-	{0xa366, 0x0, 0x1, 0x1},
-	{0xa2bc, 0x3, 0x1, 0x0},
-	{0xa2bd, 0x0, 0x8, 0xa},
-	{0xa2be, 0x0, 0x8, 0x14},
-	{0xa2bf, 0x0, 0x8, 0x8},
-	{0xa60a, 0x0, 0x8, 0xbd},
-	{0xa60e, 0x4, 0x2, 0x2},
-	{0xa60b, 0x0, 0x8, 0x86},
-	{0xa60e, 0x6, 0x2, 0x3},
-	{0xa001, 0x2, 0x2, 0x1},
-	{0xa1c7, 0x0, 0x8, 0xf5},
-	{0xa03d, 0x0, 0x8, 0xb1},
-	{0xa616, 0x0, 0x8, 0xff},
-	{0xa617, 0x0, 0x8, 0xad},
-	{0xa618, 0x0, 0x8, 0xad},
-	{0xa61e, 0x3, 0x1, 0x1},
-	{0xae1a, 0x0, 0x8, 0x0},
-	{0xae19, 0x0, 0x8, 0xc8},
-	{0xae18, 0x0, 0x8, 0x61},
-	{0xa140, 0x0, 0x8, 0x0},
-	{0xa141, 0x0, 0x8, 0xc8},
-	{0xa142, 0x0, 0x7, 0x61},
-	{0xa023, 0x0, 0x8, 0xff},
-	{0xa021, 0x0, 0x8, 0xad},
-	{0xa026, 0x0, 0x1, 0x0},
-	{0xa024, 0x0, 0x8, 0xff},
-	{0xa025, 0x0, 0x8, 0xff},
-	{0xa1c8, 0x0, 0x8, 0xf},
-	{0xa2bc, 0x1, 0x1, 0x0},
-	{0xa60c, 0x0, 0x4, 0x5},
-	{0xa60c, 0x4, 0x4, 0x6},
-	{0xa60d, 0x0, 0x8, 0xa},
-	{0xa371, 0x0, 0x1, 0x1},
-	{0xa366, 0x1, 0x3, 0x7},
-	{0xa338, 0x0, 0x8, 0x10},
-	{0xa339, 0x0, 0x6, 0x7},
-	{0xa33a, 0x0, 0x6, 0x1f},
-	{0xa33b, 0x0, 0x8, 0xf6},
-	{0xa33c, 0x3, 0x5, 0x4},
-	{0xa33d, 0x4, 0x4, 0x0},
-	{0xa33d, 0x1, 0x1, 0x1},
-	{0xa33d, 0x2, 0x1, 0x1},
-	{0xa33d, 0x3, 0x1, 0x1},
-	{0xa16d, 0x0, 0x4, 0xf},
-	{0xa161, 0x0, 0x5, 0x5},
-	{0xa162, 0x0, 0x4, 0x5},
-	{0xa165, 0x0, 0x8, 0xff},
-	{0xa166, 0x0, 0x8, 0x9c},
-	{0xa2c3, 0x0, 0x4, 0x5},
-	{0xa61a, 0x0, 0x6, 0xf},
-	{0xb200, 0x0, 0x8, 0xa1},
-	{0xb201, 0x0, 0x8, 0x7},
-	{0xa093, 0x0, 0x1, 0x0},
-	{0xa093, 0x1, 0x5, 0xf},
-	{0xa094, 0x0, 0x8, 0xff},
-	{0xa095, 0x0, 0x8, 0xf},
-	{0xa080, 0x2, 0x5, 0x3},
-	{0xa081, 0x0, 0x4, 0x0},
-	{0xa081, 0x4, 0x4, 0x9},
-	{0xa082, 0x0, 0x5, 0x1f},
-	{0xa08d, 0x0, 0x8, 0x1},
-	{0xa083, 0x0, 0x8, 0x32},
-	{0xa084, 0x0, 0x1, 0x0},
-	{0xa08e, 0x0, 0x8, 0x3},
-	{0xa085, 0x0, 0x8, 0x32},
-	{0xa086, 0x0, 0x3, 0x0},
-	{0xa087, 0x0, 0x8, 0x6e},
-	{0xa088, 0x0, 0x5, 0x15},
-	{0xa089, 0x0, 0x8, 0x0},
-	{0xa08a, 0x0, 0x5, 0x19},
-	{0xa08b, 0x0, 0x8, 0x92},
-	{0xa08c, 0x0, 0x5, 0x1c},
-	{0xa120, 0x0, 0x8, 0x0},
-	{0xa121, 0x0, 0x5, 0x10},
-	{0xa122, 0x0, 0x8, 0x0},
-	{0xa123, 0x0, 0x7, 0x40},
-	{0xa123, 0x7, 0x1, 0x0},
-	{0xa124, 0x0, 0x8, 0x13},
-	{0xa125, 0x0, 0x7, 0x10},
-	{0xa1c0, 0x0, 0x8, 0x0},
-	{0xa1c1, 0x0, 0x5, 0x4},
-	{0xa1c2, 0x0, 0x8, 0x0},
-	{0xa1c3, 0x0, 0x5, 0x10},
-	{0xa1c3, 0x5, 0x3, 0x0},
-	{0xa1c4, 0x0, 0x6, 0x0},
-	{0xa1c5, 0x0, 0x7, 0x10},
-	{0xa100, 0x0, 0x8, 0x0},
-	{0xa101, 0x0, 0x5, 0x10},
-	{0xa102, 0x0, 0x8, 0x0},
-	{0xa103, 0x0, 0x7, 0x40},
-	{0xa103, 0x7, 0x1, 0x0},
-	{0xa104, 0x0, 0x8, 0x18},
-	{0xa105, 0x0, 0x7, 0xa},
-	{0xa106, 0x0, 0x8, 0x20},
-	{0xa107, 0x0, 0x8, 0x40},
-	{0xa108, 0x0, 0x4, 0x0},
-	{0xa38c, 0x0, 0x8, 0xfc},
-	{0xa38d, 0x0, 0x8, 0x0},
-	{0xa38e, 0x0, 0x8, 0x7e},
-	{0xa38f, 0x0, 0x8, 0x0},
-	{0xa390, 0x0, 0x8, 0x2f},
-	{0xa60f, 0x5, 0x1, 0x1},
-	{0xa170, 0x0, 0x8, 0xdc},
-	{0xa171, 0x0, 0x2, 0x0},
-	{0xa2ae, 0x0, 0x1, 0x1},
-	{0xa2ae, 0x1, 0x1, 0x1},
-	{0xa392, 0x0, 0x1, 0x1},
-	{0xa391, 0x2, 0x1, 0x0},
-	{0xabc1, 0x0, 0x8, 0xff},
-	{0xabc2, 0x0, 0x8, 0x0},
-	{0xabc8, 0x0, 0x8, 0x8},
-	{0xabca, 0x0, 0x8, 0x10},
-	{0xabcb, 0x0, 0x1, 0x0},
-	{0xabc3, 0x5, 0x3, 0x7},
-	{0xabc0, 0x6, 0x1, 0x0},
-	{0xabc0, 0x4, 0x2, 0x0},
-	{0xa344, 0x4, 0x4, 0x1},
-	{0xabc0, 0x7, 0x1, 0x1},
-	{0xabc0, 0x2, 0x1, 0x1},
-	{0xa345, 0x0, 0x8, 0x66},
-	{0xa346, 0x0, 0x8, 0x66},
-	{0xa347, 0x0, 0x4, 0x0},
-	{0xa343, 0x0, 0x4, 0xa},
-	{0xa347, 0x4, 0x4, 0x2},
-	{0xa348, 0x0, 0x4, 0xc},
-	{0xa348, 0x4, 0x4, 0x7},
-	{0xa349, 0x0, 0x6, 0x2},
-};
diff -ruN ../linux-4.14.336/drivers/media/usb/dvb-usb/af9005.c ./drivers/media/usb/dvb-usb/af9005.c
--- linux-4.14.336/../linux-4.14.336/drivers/media/usb/dvb-usb/af9005.c	2024-01-10 14:45:41.000000000 +0100
+++ linux-4.14.336/./drivers/media/usb/dvb-usb/af9005.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1151 +0,0 @@
-/* DVB USB compliant Linux driver for the Afatech 9005
- * USB1.1 DVB-T receiver.
- *
- * Copyright (C) 2007 Luca Olivetti (luca@ventoso.org)
- *
- * Thanks to Afatech who kindly provided information.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * see Documentation/dvb/README.dvb-usb for more information
- */
-#include "af9005.h"
-
-/* debug */
-int dvb_usb_af9005_debug;
-module_param_named(debug, dvb_usb_af9005_debug, int, 0644);
-MODULE_PARM_DESC(debug,
-		 "set debugging level (1=info,xfer=2,rc=4,reg=8,i2c=16,fw=32 (or-able))."
-		 DVB_USB_DEBUG_STATUS);
-/* enable obnoxious led */
-bool dvb_usb_af9005_led = true;
-module_param_named(led, dvb_usb_af9005_led, bool, 0644);
-MODULE_PARM_DESC(led, "enable led (default: 1).");
-
-/* eeprom dump */
-static int dvb_usb_af9005_dump_eeprom;
-module_param_named(dump_eeprom, dvb_usb_af9005_dump_eeprom, int, 0);
-MODULE_PARM_DESC(dump_eeprom, "dump contents of the eeprom.");
-
-DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);
-
-/* remote control decoder */
-static int (*rc_decode) (struct dvb_usb_device *d, u8 *data, int len,
-		u32 *event, int *state);
-static void *rc_keys;
-static int *rc_keys_size;
-
-u8 regmask[8] = { 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff };
-
-struct af9005_device_state {
-	u8 sequence;
-	int led_state;
-	unsigned char data[256];
-};
-
-static int af9005_generic_read_write(struct dvb_usb_device *d, u16 reg,
-			      int readwrite, int type, u8 * values, int len)
-{
-	struct af9005_device_state *st = d->priv;
-	u8 command, seq;
-	int i, ret;
-
-	if (len < 1) {
-		err("generic read/write, less than 1 byte. Makes no sense.");
-		return -EINVAL;
-	}
-	if (len > 8) {
-		err("generic read/write, more than 8 bytes. Not supported.");
-		return -EINVAL;
-	}
-
-	mutex_lock(&d->data_mutex);
-	st->data[0] = 14;		/* rest of buffer length low */
-	st->data[1] = 0;		/* rest of buffer length high */
-
-	st->data[2] = AF9005_REGISTER_RW;	/* register operation */
-	st->data[3] = 12;		/* rest of buffer length */
-
-	st->data[4] = seq = st->sequence++;	/* sequence number */
-
-	st->data[5] = (u8) (reg >> 8);	/* register address */
-	st->data[6] = (u8) (reg & 0xff);
-
-	if (type == AF9005_OFDM_REG) {
-		command = AF9005_CMD_OFDM_REG;
-	} else {
-		command = AF9005_CMD_TUNER;
-	}
-
-	if (len > 1)
-		command |=
-		    AF9005_CMD_BURST | AF9005_CMD_AUTOINC | (len - 1) << 3;
-	command |= readwrite;
-	if (readwrite == AF9005_CMD_WRITE)
-		for (i = 0; i < len; i++)
-			st->data[8 + i] = values[i];
-	else if (type == AF9005_TUNER_REG)
-		/* read command for tuner, the first byte contains the i2c address */
-		st->data[8] = values[0];
-	st->data[7] = command;
-
-	ret = dvb_usb_generic_rw(d, st->data, 16, st->data, 17, 0);
-	if (ret)
-		goto ret;
-
-	/* sanity check */
-	if (st->data[2] != AF9005_REGISTER_RW_ACK) {
-		err("generic read/write, wrong reply code.");
-		ret = -EIO;
-		goto ret;
-	}
-	if (st->data[3] != 0x0d) {
-		err("generic read/write, wrong length in reply.");
-		ret = -EIO;
-		goto ret;
-	}
-	if (st->data[4] != seq) {
-		err("generic read/write, wrong sequence in reply.");
-		ret = -EIO;
-		goto ret;
-	}
-	/*
-	 * In thesis, both input and output buffers should have
-	 * identical values for st->data[5] to st->data[8].
-	 * However, windows driver doesn't check these fields, in fact
-	 * sometimes the register in the reply is different that what
-	 * has been sent
-	 */
-	if (st->data[16] != 0x01) {
-		err("generic read/write wrong status code in reply.");
-		ret = -EIO;
-		goto ret;
-	}
-
-	if (readwrite == AF9005_CMD_READ)
-		for (i = 0; i < len; i++)
-			values[i] = st->data[8 + i];
-
-ret:
-	mutex_unlock(&d->data_mutex);
-	return ret;
-
-}
-
-int af9005_read_ofdm_register(struct dvb_usb_device *d, u16 reg, u8 * value)
-{
-	int ret;
-	deb_reg("read register %x ", reg);
-	ret = af9005_generic_read_write(d, reg,
-					AF9005_CMD_READ, AF9005_OFDM_REG,
-					value, 1);
-	if (ret)
-		deb_reg("failed\n");
-	else
-		deb_reg("value %x\n", *value);
-	return ret;
-}
-
-int af9005_read_ofdm_registers(struct dvb_usb_device *d, u16 reg,
-			       u8 * values, int len)
-{
-	int ret;
-	deb_reg("read %d registers %x ", len, reg);
-	ret = af9005_generic_read_write(d, reg,
-					AF9005_CMD_READ, AF9005_OFDM_REG,
-					values, len);
-	if (ret)
-		deb_reg("failed\n");
-	else
-		debug_dump(values, len, deb_reg);
-	return ret;
-}
-
-int af9005_write_ofdm_register(struct dvb_usb_device *d, u16 reg, u8 value)
-{
-	int ret;
-	u8 temp = value;
-	deb_reg("write register %x value %x ", reg, value);
-	ret = af9005_generic_read_write(d, reg,
-					AF9005_CMD_WRITE, AF9005_OFDM_REG,
-					&temp, 1);
-	if (ret)
-		deb_reg("failed\n");
-	else
-		deb_reg("ok\n");
-	return ret;
-}
-
-int af9005_write_ofdm_registers(struct dvb_usb_device *d, u16 reg,
-				u8 * values, int len)
-{
-	int ret;
-	deb_reg("write %d registers %x values ", len, reg);
-	debug_dump(values, len, deb_reg);
-
-	ret = af9005_generic_read_write(d, reg,
-					AF9005_CMD_WRITE, AF9005_OFDM_REG,
-					values, len);
-	if (ret)
-		deb_reg("failed\n");
-	else
-		deb_reg("ok\n");
-	return ret;
-}
-
-int af9005_read_register_bits(struct dvb_usb_device *d, u16 reg, u8 pos,
-			      u8 len, u8 * value)
-{
-	u8 temp;
-	int ret;
-	deb_reg("read bits %x %x %x", reg, pos, len);
-	ret = af9005_read_ofdm_register(d, reg, &temp);
-	if (ret) {
-		deb_reg(" failed\n");
-		return ret;
-	}
-	*value = (temp >> pos) & regmask[len - 1];
-	deb_reg(" value %x\n", *value);
-	return 0;
-
-}
-
-int af9005_write_register_bits(struct dvb_usb_device *d, u16 reg, u8 pos,
-			       u8 len, u8 value)
-{
-	u8 temp, mask;
-	int ret;
-	deb_reg("write bits %x %x %x value %x\n", reg, pos, len, value);
-	if (pos == 0 && len == 8)
-		return af9005_write_ofdm_register(d, reg, value);
-	ret = af9005_read_ofdm_register(d, reg, &temp);
-	if (ret)
-		return ret;
-	mask = regmask[len - 1] << pos;
-	temp = (temp & ~mask) | ((value << pos) & mask);
-	return af9005_write_ofdm_register(d, reg, temp);
-
-}
-
-static int af9005_usb_read_tuner_registers(struct dvb_usb_device *d,
-					   u16 reg, u8 * values, int len)
-{
-	return af9005_generic_read_write(d, reg,
-					 AF9005_CMD_READ, AF9005_TUNER_REG,
-					 values, len);
-}
-
-static int af9005_usb_write_tuner_registers(struct dvb_usb_device *d,
-					    u16 reg, u8 * values, int len)
-{
-	return af9005_generic_read_write(d, reg,
-					 AF9005_CMD_WRITE,
-					 AF9005_TUNER_REG, values, len);
-}
-
-int af9005_write_tuner_registers(struct dvb_usb_device *d, u16 reg,
-				 u8 * values, int len)
-{
-	/* don't let the name of this function mislead you: it's just used
-	   as an interface from the firmware to the i2c bus. The actual
-	   i2c addresses are contained in the data */
-	int ret, i, done = 0, fail = 0;
-	u8 temp;
-	ret = af9005_usb_write_tuner_registers(d, reg, values, len);
-	if (ret)
-		return ret;
-	if (reg != 0xffff) {
-		/* check if write done (0xa40d bit 1) or fail (0xa40d bit 2) */
-		for (i = 0; i < 200; i++) {
-			ret =
-			    af9005_read_ofdm_register(d,
-						      xd_I2C_i2c_m_status_wdat_done,
-						      &temp);
-			if (ret)
-				return ret;
-			done = temp & (regmask[i2c_m_status_wdat_done_len - 1]
-				       << i2c_m_status_wdat_done_pos);
-			if (done)
-				break;
-			fail = temp & (regmask[i2c_m_status_wdat_fail_len - 1]
-				       << i2c_m_status_wdat_fail_pos);
-			if (fail)
-				break;
-			msleep(50);
-		}
-		if (i == 200)
-			return -ETIMEDOUT;
-		if (fail) {
-			/* clear write fail bit */
-			af9005_write_register_bits(d,
-						   xd_I2C_i2c_m_status_wdat_fail,
-						   i2c_m_status_wdat_fail_pos,
-						   i2c_m_status_wdat_fail_len,
-						   1);
-			return -EIO;
-		}
-		/* clear write done bit */
-		ret =
-		    af9005_write_register_bits(d,
-					       xd_I2C_i2c_m_status_wdat_fail,
-					       i2c_m_status_wdat_done_pos,
-					       i2c_m_status_wdat_done_len, 1);
-		if (ret)
-			return ret;
-	}
-	return 0;
-}
-
-int af9005_read_tuner_registers(struct dvb_usb_device *d, u16 reg, u8 addr,
-				u8 * values, int len)
-{
-	/* don't let the name of this function mislead you: it's just used
-	   as an interface from the firmware to the i2c bus. The actual
-	   i2c addresses are contained in the data */
-	int ret, i;
-	u8 temp, buf[2];
-
-	buf[0] = addr;		/* tuner i2c address */
-	buf[1] = values[0];	/* tuner register */
-
-	values[0] = addr + 0x01;	/* i2c read address */
-
-	if (reg == APO_REG_I2C_RW_SILICON_TUNER) {
-		/* write tuner i2c address to tuner, 0c00c0 undocumented, found by sniffing */
-		ret = af9005_write_tuner_registers(d, 0x00c0, buf, 2);
-		if (ret)
-			return ret;
-	}
-
-	/* send read command to ofsm */
-	ret = af9005_usb_read_tuner_registers(d, reg, values, 1);
-	if (ret)
-		return ret;
-
-	/* check if read done */
-	for (i = 0; i < 200; i++) {
-		ret = af9005_read_ofdm_register(d, 0xa408, &temp);
-		if (ret)
-			return ret;
-		if (temp & 0x01)
-			break;
-		msleep(50);
-	}
-	if (i == 200)
-		return -ETIMEDOUT;
-
-	/* clear read done bit (by writing 1) */
-	ret = af9005_write_ofdm_register(d, xd_I2C_i2c_m_data8, 1);
-	if (ret)
-		return ret;
-
-	/* get read data (available from 0xa400) */
-	for (i = 0; i < len; i++) {
-		ret = af9005_read_ofdm_register(d, 0xa400 + i, &temp);
-		if (ret)
-			return ret;
-		values[i] = temp;
-	}
-	return 0;
-}
-
-static int af9005_i2c_write(struct dvb_usb_device *d, u8 i2caddr, u8 reg,
-			    u8 * data, int len)
-{
-	int ret, i;
-	u8 buf[3];
-	deb_i2c("i2c_write i2caddr %x, reg %x, len %d data ", i2caddr,
-		reg, len);
-	debug_dump(data, len, deb_i2c);
-
-	for (i = 0; i < len; i++) {
-		buf[0] = i2caddr;
-		buf[1] = reg + (u8) i;
-		buf[2] = data[i];
-		ret =
-		    af9005_write_tuner_registers(d,
-						 APO_REG_I2C_RW_SILICON_TUNER,
-						 buf, 3);
-		if (ret) {
-			deb_i2c("i2c_write failed\n");
-			return ret;
-		}
-	}
-	deb_i2c("i2c_write ok\n");
-	return 0;
-}
-
-static int af9005_i2c_read(struct dvb_usb_device *d, u8 i2caddr, u8 reg,
-			   u8 * data, int len)
-{
-	int ret, i;
-	u8 temp;
-	deb_i2c("i2c_read i2caddr %x, reg %x, len %d\n ", i2caddr, reg, len);
-	for (i = 0; i < len; i++) {
-		temp = reg + i;
-		ret =
-		    af9005_read_tuner_registers(d,
-						APO_REG_I2C_RW_SILICON_TUNER,
-						i2caddr, &temp, 1);
-		if (ret) {
-			deb_i2c("i2c_read failed\n");
-			return ret;
-		}
-		data[i] = temp;
-	}
-	deb_i2c("i2c data read: ");
-	debug_dump(data, len, deb_i2c);
-	return 0;
-}
-
-static int af9005_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[],
-			   int num)
-{
-	/* only implements what the mt2060 module does, don't know how
-	   to make it really generic */
-	struct dvb_usb_device *d = i2c_get_adapdata(adap);
-	int ret;
-	u8 reg, addr;
-	u8 *value;
-
-	if (mutex_lock_interruptible(&d->i2c_mutex) < 0)
-		return -EAGAIN;
-
-	if (num > 2)
-		warn("more than 2 i2c messages at a time is not handled yet. TODO.");
-
-	if (num == 2) {
-		/* reads a single register */
-		reg = *msg[0].buf;
-		addr = msg[0].addr;
-		value = msg[1].buf;
-		ret = af9005_i2c_read(d, addr, reg, value, 1);
-		if (ret == 0)
-			ret = 2;
-	} else {
-		if (msg[0].len < 2) {
-			ret = -EOPNOTSUPP;
-			goto unlock;
-		}
-		/* write one or more registers */
-		reg = msg[0].buf[0];
-		addr = msg[0].addr;
-		value = &msg[0].buf[1];
-		ret = af9005_i2c_write(d, addr, reg, value, msg[0].len - 1);
-		if (ret == 0)
-			ret = 1;
-	}
-
-unlock:
-	mutex_unlock(&d->i2c_mutex);
-	return ret;
-}
-
-static u32 af9005_i2c_func(struct i2c_adapter *adapter)
-{
-	return I2C_FUNC_I2C;
-}
-
-static struct i2c_algorithm af9005_i2c_algo = {
-	.master_xfer = af9005_i2c_xfer,
-	.functionality = af9005_i2c_func,
-};
-
-int af9005_send_command(struct dvb_usb_device *d, u8 command, u8 * wbuf,
-			int wlen, u8 * rbuf, int rlen)
-{
-	struct af9005_device_state *st = d->priv;
-
-	int ret, i, packet_len;
-	u8 seq;
-
-	if (wlen < 0) {
-		err("send command, wlen less than 0 bytes. Makes no sense.");
-		return -EINVAL;
-	}
-	if (wlen > 54) {
-		err("send command, wlen more than 54 bytes. Not supported.");
-		return -EINVAL;
-	}
-	if (rlen > 54) {
-		err("send command, rlen more than 54 bytes. Not supported.");
-		return -EINVAL;
-	}
-	packet_len = wlen + 5;
-
-	mutex_lock(&d->data_mutex);
-
-	st->data[0] = (u8) (packet_len & 0xff);
-	st->data[1] = (u8) ((packet_len & 0xff00) >> 8);
-
-	st->data[2] = 0x26;		/* packet type */
-	st->data[3] = wlen + 3;
-	st->data[4] = seq = st->sequence++;
-	st->data[5] = command;
-	st->data[6] = wlen;
-	for (i = 0; i < wlen; i++)
-		st->data[7 + i] = wbuf[i];
-	ret = dvb_usb_generic_rw(d, st->data, wlen + 7, st->data, rlen + 7, 0);
-	if (st->data[2] != 0x27) {
-		err("send command, wrong reply code.");
-		ret = -EIO;
-	} else if (st->data[4] != seq) {
-		err("send command, wrong sequence in reply.");
-		ret = -EIO;
-	} else if (st->data[5] != 0x01) {
-		err("send command, wrong status code in reply.");
-		ret = -EIO;
-	} else if (st->data[6] != rlen) {
-		err("send command, invalid data length in reply.");
-		ret = -EIO;
-	}
-	if (!ret) {
-		for (i = 0; i < rlen; i++)
-			rbuf[i] = st->data[i + 7];
-	}
-
-	mutex_unlock(&d->data_mutex);
-	return ret;
-}
-
-int af9005_read_eeprom(struct dvb_usb_device *d, u8 address, u8 * values,
-		       int len)
-{
-	struct af9005_device_state *st = d->priv;
-	u8 seq;
-	int ret, i;
-
-	mutex_lock(&d->data_mutex);
-
-	memset(st->data, 0, sizeof(st->data));
-
-	st->data[0] = 14;		/* length of rest of packet low */
-	st->data[1] = 0;		/* length of rest of packer high */
-
-	st->data[2] = 0x2a;		/* read/write eeprom */
-
-	st->data[3] = 12;		/* size */
-
-	st->data[4] = seq = st->sequence++;
-
-	st->data[5] = 0;		/* read */
-
-	st->data[6] = len;
-	st->data[7] = address;
-	ret = dvb_usb_generic_rw(d, st->data, 16, st->data, 14, 0);
-	if (st->data[2] != 0x2b) {
-		err("Read eeprom, invalid reply code");
-		ret = -EIO;
-	} else if (st->data[3] != 10) {
-		err("Read eeprom, invalid reply length");
-		ret = -EIO;
-	} else if (st->data[4] != seq) {
-		err("Read eeprom, wrong sequence in reply ");
-		ret = -EIO;
-	} else if (st->data[5] != 1) {
-		err("Read eeprom, wrong status in reply ");
-		ret = -EIO;
-	}
-
-	if (!ret) {
-		for (i = 0; i < len; i++)
-			values[i] = st->data[6 + i];
-	}
-	mutex_unlock(&d->data_mutex);
-
-	return ret;
-}
-
-static int af9005_boot_packet(struct usb_device *udev, int type, u8 *reply,
-			      u8 *buf, int size)
-{
-	u16 checksum;
-	int act_len = 0, i, ret;
-
-	memset(buf, 0, size);
-	buf[0] = (u8) (FW_BULKOUT_SIZE & 0xff);
-	buf[1] = (u8) ((FW_BULKOUT_SIZE >> 8) & 0xff);
-	switch (type) {
-	case FW_CONFIG:
-		buf[2] = 0x11;
-		buf[3] = 0x04;
-		buf[4] = 0x00;	/* sequence number, original driver doesn't increment it here */
-		buf[5] = 0x03;
-		checksum = buf[4] + buf[5];
-		buf[6] = (u8) ((checksum >> 8) & 0xff);
-		buf[7] = (u8) (checksum & 0xff);
-		break;
-	case FW_CONFIRM:
-		buf[2] = 0x11;
-		buf[3] = 0x04;
-		buf[4] = 0x00;	/* sequence number, original driver doesn't increment it here */
-		buf[5] = 0x01;
-		checksum = buf[4] + buf[5];
-		buf[6] = (u8) ((checksum >> 8) & 0xff);
-		buf[7] = (u8) (checksum & 0xff);
-		break;
-	case FW_BOOT:
-		buf[2] = 0x10;
-		buf[3] = 0x08;
-		buf[4] = 0x00;	/* sequence number, original driver doesn't increment it here */
-		buf[5] = 0x97;
-		buf[6] = 0xaa;
-		buf[7] = 0x55;
-		buf[8] = 0xa5;
-		buf[9] = 0x5a;
-		checksum = 0;
-		for (i = 4; i <= 9; i++)
-			checksum += buf[i];
-		buf[10] = (u8) ((checksum >> 8) & 0xff);
-		buf[11] = (u8) (checksum & 0xff);
-		break;
-	default:
-		err("boot packet invalid boot packet type");
-		return -EINVAL;
-	}
-	deb_fw(">>> ");
-	debug_dump(buf, FW_BULKOUT_SIZE + 2, deb_fw);
-
-	ret = usb_bulk_msg(udev,
-			   usb_sndbulkpipe(udev, 0x02),
-			   buf, FW_BULKOUT_SIZE + 2, &act_len, 2000);
-	if (ret)
-		err("boot packet bulk message failed: %d (%d/%d)", ret,
-		    FW_BULKOUT_SIZE + 2, act_len);
-	else
-		ret = act_len != FW_BULKOUT_SIZE + 2 ? -1 : 0;
-	if (ret)
-		return ret;
-	memset(buf, 0, 9);
-	ret = usb_bulk_msg(udev,
-			   usb_rcvbulkpipe(udev, 0x01), buf, 9, &act_len, 2000);
-	if (ret) {
-		err("boot packet recv bulk message failed: %d", ret);
-		return ret;
-	}
-	deb_fw("<<< ");
-	debug_dump(buf, act_len, deb_fw);
-	checksum = 0;
-	switch (type) {
-	case FW_CONFIG:
-		if (buf[2] != 0x11) {
-			err("boot bad config header.");
-			return -EIO;
-		}
-		if (buf[3] != 0x05) {
-			err("boot bad config size.");
-			return -EIO;
-		}
-		if (buf[4] != 0x00) {
-			err("boot bad config sequence.");
-			return -EIO;
-		}
-		if (buf[5] != 0x04) {
-			err("boot bad config subtype.");
-			return -EIO;
-		}
-		for (i = 4; i <= 6; i++)
-			checksum += buf[i];
-		if (buf[7] * 256 + buf[8] != checksum) {
-			err("boot bad config checksum.");
-			return -EIO;
-		}
-		*reply = buf[6];
-		break;
-	case FW_CONFIRM:
-		if (buf[2] != 0x11) {
-			err("boot bad confirm header.");
-			return -EIO;
-		}
-		if (buf[3] != 0x05) {
-			err("boot bad confirm size.");
-			return -EIO;
-		}
-		if (buf[4] != 0x00) {
-			err("boot bad confirm sequence.");
-			return -EIO;
-		}
-		if (buf[5] != 0x02) {
-			err("boot bad confirm subtype.");
-			return -EIO;
-		}
-		for (i = 4; i <= 6; i++)
-			checksum += buf[i];
-		if (buf[7] * 256 + buf[8] != checksum) {
-			err("boot bad confirm checksum.");
-			return -EIO;
-		}
-		*reply = buf[6];
-		break;
-	case FW_BOOT:
-		if (buf[2] != 0x10) {
-			err("boot bad boot header.");
-			return -EIO;
-		}
-		if (buf[3] != 0x05) {
-			err("boot bad boot size.");
-			return -EIO;
-		}
-		if (buf[4] != 0x00) {
-			err("boot bad boot sequence.");
-			return -EIO;
-		}
-		if (buf[5] != 0x01) {
-			err("boot bad boot pattern 01.");
-			return -EIO;
-		}
-		if (buf[6] != 0x10) {
-			err("boot bad boot pattern 10.");
-			return -EIO;
-		}
-		for (i = 4; i <= 6; i++)
-			checksum += buf[i];
-		if (buf[7] * 256 + buf[8] != checksum) {
-			err("boot bad boot checksum.");
-			return -EIO;
-		}
-		break;
-
-	}
-
-	return 0;
-}
-
-static int af9005_download_firmware(struct usb_device *udev, const struct firmware *fw)
-{
-	int i, packets, ret, act_len;
-
-	u8 *buf;
-	u8 reply;
-
-	buf = kmalloc(FW_BULKOUT_SIZE + 2, GFP_KERNEL);
-	if (!buf)
-		return -ENOMEM;
-
-	ret = af9005_boot_packet(udev, FW_CONFIG, &reply, buf,
-				 FW_BULKOUT_SIZE + 2);
-	if (ret)
-		goto err;
-	if (reply != 0x01) {
-		err("before downloading firmware, FW_CONFIG expected 0x01, received 0x%x", reply);
-		ret = -EIO;
-		goto err;
-	}
-	packets = fw->size / FW_BULKOUT_SIZE;
-	buf[0] = (u8) (FW_BULKOUT_SIZE & 0xff);
-	buf[1] = (u8) ((FW_BULKOUT_SIZE >> 8) & 0xff);
-	for (i = 0; i < packets; i++) {
-		memcpy(&buf[2], fw->data + i * FW_BULKOUT_SIZE,
-		       FW_BULKOUT_SIZE);
-		deb_fw(">>> ");
-		debug_dump(buf, FW_BULKOUT_SIZE + 2, deb_fw);
-		ret = usb_bulk_msg(udev,
-				   usb_sndbulkpipe(udev, 0x02),
-				   buf, FW_BULKOUT_SIZE + 2, &act_len, 1000);
-		if (ret) {
-			err("firmware download failed at packet %d with code %d", i, ret);
-			goto err;
-		}
-	}
-	ret = af9005_boot_packet(udev, FW_CONFIRM, &reply,
-				 buf, FW_BULKOUT_SIZE + 2);
-	if (ret)
-		goto err;
-	if (reply != (u8) (packets & 0xff)) {
-		err("after downloading firmware, FW_CONFIRM expected 0x%x, received 0x%x", packets & 0xff, reply);
-		ret = -EIO;
-		goto err;
-	}
-	ret = af9005_boot_packet(udev, FW_BOOT, &reply, buf,
-				 FW_BULKOUT_SIZE + 2);
-	if (ret)
-		goto err;
-	ret = af9005_boot_packet(udev, FW_CONFIG, &reply, buf,
-				 FW_BULKOUT_SIZE + 2);
-	if (ret)
-		goto err;
-	if (reply != 0x02) {
-		err("after downloading firmware, FW_CONFIG expected 0x02, received 0x%x", reply);
-		ret = -EIO;
-		goto err;
-	}
-
-err:
-	kfree(buf);
-	return ret;
-
-}
-
-int af9005_led_control(struct dvb_usb_device *d, int onoff)
-{
-	struct af9005_device_state *st = d->priv;
-	int temp, ret;
-
-	if (onoff && dvb_usb_af9005_led)
-		temp = 1;
-	else
-		temp = 0;
-	if (st->led_state != temp) {
-		ret =
-		    af9005_write_register_bits(d, xd_p_reg_top_locken1,
-					       reg_top_locken1_pos,
-					       reg_top_locken1_len, temp);
-		if (ret)
-			return ret;
-		ret =
-		    af9005_write_register_bits(d, xd_p_reg_top_lock1,
-					       reg_top_lock1_pos,
-					       reg_top_lock1_len, temp);
-		if (ret)
-			return ret;
-		st->led_state = temp;
-	}
-	return 0;
-}
-
-static int af9005_frontend_attach(struct dvb_usb_adapter *adap)
-{
-	u8 buf[8];
-	int i;
-
-	/* without these calls the first commands after downloading
-	   the firmware fail. I put these calls here to simulate
-	   what it is done in dvb-usb-init.c.
-	 */
-	struct usb_device *udev = adap->dev->udev;
-	usb_clear_halt(udev, usb_sndbulkpipe(udev, 2));
-	usb_clear_halt(udev, usb_rcvbulkpipe(udev, 1));
-	if (dvb_usb_af9005_dump_eeprom) {
-		printk("EEPROM DUMP\n");
-		for (i = 0; i < 255; i += 8) {
-			af9005_read_eeprom(adap->dev, i, buf, 8);
-			debug_dump(buf, 8, printk);
-		}
-	}
-	adap->fe_adap[0].fe = af9005_fe_attach(adap->dev);
-	return 0;
-}
-
-static int af9005_rc_query(struct dvb_usb_device *d, u32 * event, int *state)
-{
-	struct af9005_device_state *st = d->priv;
-	int ret, len;
-	u8 seq;
-
-	*state = REMOTE_NO_KEY_PRESSED;
-	if (rc_decode == NULL) {
-		/* it shouldn't never come here */
-		return 0;
-	}
-
-	mutex_lock(&d->data_mutex);
-
-	/* deb_info("rc_query\n"); */
-	st->data[0] = 3;		/* rest of packet length low */
-	st->data[1] = 0;		/* rest of packet lentgh high */
-	st->data[2] = 0x40;		/* read remote */
-	st->data[3] = 1;		/* rest of packet length */
-	st->data[4] = seq = st->sequence++;	/* sequence number */
-	ret = dvb_usb_generic_rw(d, st->data, 5, st->data, 256, 0);
-	if (ret) {
-		err("rc query failed");
-		goto ret;
-	}
-	if (st->data[2] != 0x41) {
-		err("rc query bad header.");
-		ret = -EIO;
-		goto ret;
-	} else if (st->data[4] != seq) {
-		err("rc query bad sequence.");
-		ret = -EIO;
-		goto ret;
-	}
-	len = st->data[5];
-	if (len > 246) {
-		err("rc query invalid length");
-		ret = -EIO;
-		goto ret;
-	}
-	if (len > 0) {
-		deb_rc("rc data (%d) ", len);
-		debug_dump((st->data + 6), len, deb_rc);
-		ret = rc_decode(d, &st->data[6], len, event, state);
-		if (ret) {
-			err("rc_decode failed");
-			goto ret;
-		} else {
-			deb_rc("rc_decode state %x event %x\n", *state, *event);
-			if (*state == REMOTE_KEY_REPEAT)
-				*event = d->last_event;
-		}
-	}
-
-ret:
-	mutex_unlock(&d->data_mutex);
-	return ret;
-}
-
-static int af9005_power_ctrl(struct dvb_usb_device *d, int onoff)
-{
-
-	return 0;
-}
-
-static int af9005_pid_filter_control(struct dvb_usb_adapter *adap, int onoff)
-{
-	int ret;
-	deb_info("pid filter control  onoff %d\n", onoff);
-	if (onoff) {
-		ret =
-		    af9005_write_ofdm_register(adap->dev, XD_MP2IF_DMX_CTRL, 1);
-		if (ret)
-			return ret;
-		ret =
-		    af9005_write_register_bits(adap->dev,
-					       XD_MP2IF_DMX_CTRL, 1, 1, 1);
-		if (ret)
-			return ret;
-		ret =
-		    af9005_write_ofdm_register(adap->dev, XD_MP2IF_DMX_CTRL, 1);
-	} else
-		ret =
-		    af9005_write_ofdm_register(adap->dev, XD_MP2IF_DMX_CTRL, 0);
-	if (ret)
-		return ret;
-	deb_info("pid filter control ok\n");
-	return 0;
-}
-
-static int af9005_pid_filter(struct dvb_usb_adapter *adap, int index,
-			     u16 pid, int onoff)
-{
-	u8 cmd = index & 0x1f;
-	int ret;
-	deb_info("set pid filter, index %d, pid %x, onoff %d\n", index,
-		 pid, onoff);
-	if (onoff) {
-		/* cannot use it as pid_filter_ctrl since it has to be done
-		   before setting the first pid */
-		if (adap->feedcount == 1) {
-			deb_info("first pid set, enable pid table\n");
-			ret = af9005_pid_filter_control(adap, onoff);
-			if (ret)
-				return ret;
-		}
-		ret =
-		    af9005_write_ofdm_register(adap->dev,
-					       XD_MP2IF_PID_DATA_L,
-					       (u8) (pid & 0xff));
-		if (ret)
-			return ret;
-		ret =
-		    af9005_write_ofdm_register(adap->dev,
-					       XD_MP2IF_PID_DATA_H,
-					       (u8) (pid >> 8));
-		if (ret)
-			return ret;
-		cmd |= 0x20 | 0x40;
-	} else {
-		if (adap->feedcount == 0) {
-			deb_info("last pid unset, disable pid table\n");
-			ret = af9005_pid_filter_control(adap, onoff);
-			if (ret)
-				return ret;
-		}
-	}
-	ret = af9005_write_ofdm_register(adap->dev, XD_MP2IF_PID_IDX, cmd);
-	if (ret)
-		return ret;
-	deb_info("set pid ok\n");
-	return 0;
-}
-
-static int af9005_identify_state(struct usb_device *udev,
-				 struct dvb_usb_device_properties *props,
-				 struct dvb_usb_device_description **desc,
-				 int *cold)
-{
-	int ret;
-	u8 reply, *buf;
-
-	buf = kmalloc(FW_BULKOUT_SIZE + 2, GFP_KERNEL);
-	if (!buf)
-		return -ENOMEM;
-
-	ret = af9005_boot_packet(udev, FW_CONFIG, &reply,
-				 buf, FW_BULKOUT_SIZE + 2);
-	if (ret)
-		goto err;
-	deb_info("result of FW_CONFIG in identify state %d\n", reply);
-	if (reply == 0x01)
-		*cold = 1;
-	else if (reply == 0x02)
-		*cold = 0;
-	else
-		ret = -EIO;
-	if (!ret)
-		deb_info("Identify state cold = %d\n", *cold);
-
-err:
-	kfree(buf);
-	return ret;
-}
-
-static struct dvb_usb_device_properties af9005_properties;
-
-static int af9005_usb_probe(struct usb_interface *intf,
-			    const struct usb_device_id *id)
-{
-	return dvb_usb_device_init(intf, &af9005_properties,
-				  THIS_MODULE, NULL, adapter_nr);
-}
-
-enum af9005_usb_table_entry {
-	AFATECH_AF9005,
-	TERRATEC_AF9005,
-	ANSONIC_AF9005,
-};
-
-static struct usb_device_id af9005_usb_table[] = {
-	[AFATECH_AF9005] = {USB_DEVICE(USB_VID_AFATECH,
-				USB_PID_AFATECH_AF9005)},
-	[TERRATEC_AF9005] = {USB_DEVICE(USB_VID_TERRATEC,
-				USB_PID_TERRATEC_CINERGY_T_USB_XE)},
-	[ANSONIC_AF9005] = {USB_DEVICE(USB_VID_ANSONIC,
-				USB_PID_ANSONIC_DVBT_USB)},
-	{ }
-};
-
-MODULE_DEVICE_TABLE(usb, af9005_usb_table);
-
-static struct dvb_usb_device_properties af9005_properties = {
-	.caps = DVB_USB_IS_AN_I2C_ADAPTER,
-
-	.usb_ctrl = DEVICE_SPECIFIC,
-	.firmware = "af9005.fw",
-	.download_firmware = af9005_download_firmware,
-	.no_reconnect = 1,
-
-	.size_of_priv = sizeof(struct af9005_device_state),
-
-	.num_adapters = 1,
-	.adapter = {
-		    {
-		    .num_frontends = 1,
-		    .fe = {{
-		     .caps =
-		     DVB_USB_ADAP_HAS_PID_FILTER |
-		     DVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,
-		     .pid_filter_count = 32,
-		     .pid_filter = af9005_pid_filter,
-		     /* .pid_filter_ctrl = af9005_pid_filter_control, */
-		     .frontend_attach = af9005_frontend_attach,
-		     /* .tuner_attach     = af9005_tuner_attach, */
-		     /* parameter for the MPEG2-data transfer */
-		     .stream = {
-				.type = USB_BULK,
-				.count = 10,
-				.endpoint = 0x04,
-				.u = {
-				      .bulk = {
-					       .buffersize = 4096,	/* actual size seen is 3948 */
-					       }
-				      }
-				},
-		     }},
-		     }
-		    },
-	.power_ctrl = af9005_power_ctrl,
-	.identify_state = af9005_identify_state,
-
-	.i2c_algo = &af9005_i2c_algo,
-
-	.rc.legacy = {
-		.rc_interval = 200,
-		.rc_map_table = NULL,
-		.rc_map_size = 0,
-		.rc_query = af9005_rc_query,
-	},
-
-	.generic_bulk_ctrl_endpoint          = 2,
-	.generic_bulk_ctrl_endpoint_response = 1,
-
-	.num_device_descs = 3,
-	.devices = {
-		    {.name = "Afatech DVB-T USB1.1 stick",
-		     .cold_ids = {&af9005_usb_table[AFATECH_AF9005], NULL},
-		     .warm_ids = {NULL},
-		     },
-		    {.name = "TerraTec Cinergy T USB XE",
-		     .cold_ids = {&af9005_usb_table[TERRATEC_AF9005], NULL},
-		     .warm_ids = {NULL},
-		     },
-		    {.name = "Ansonic DVB-T USB1.1 stick",
-		     .cold_ids = {&af9005_usb_table[ANSONIC_AF9005], NULL},
-		     .warm_ids = {NULL},
-		     },
-		    {NULL},
-		    }
-};
-
-/* usb specific object needed to register this driver with the usb subsystem */
-static struct usb_driver af9005_usb_driver = {
-	.name = "dvb_usb_af9005",
-	.probe = af9005_usb_probe,
-	.disconnect = dvb_usb_device_exit,
-	.id_table = af9005_usb_table,
-};
-
-/* module stuff */
-static int __init af9005_usb_module_init(void)
-{
-	int result;
-	if ((result = usb_register(&af9005_usb_driver))) {
-		err("usb_register failed. (%d)", result);
-		return result;
-	}
-#if IS_MODULE(CONFIG_DVB_USB_AF9005) || defined(CONFIG_DVB_USB_AF9005_REMOTE)
-	/* FIXME: convert to todays kernel IR infrastructure */
-	rc_decode = symbol_request(af9005_rc_decode);
-	rc_keys = symbol_request(rc_map_af9005_table);
-	rc_keys_size = symbol_request(rc_map_af9005_table_size);
-#endif
-	if (rc_decode == NULL || rc_keys == NULL || rc_keys_size == NULL) {
-		err("af9005_rc_decode function not found, disabling remote");
-		af9005_properties.rc.legacy.rc_query = NULL;
-	} else {
-		af9005_properties.rc.legacy.rc_map_table = rc_keys;
-		af9005_properties.rc.legacy.rc_map_size = *rc_keys_size;
-	}
-
-	return 0;
-}
-
-static void __exit af9005_usb_module_exit(void)
-{
-	/* release rc decode symbols */
-	if (rc_decode != NULL)
-		symbol_put(af9005_rc_decode);
-	if (rc_keys != NULL)
-		symbol_put(rc_map_af9005_table);
-	if (rc_keys_size != NULL)
-		symbol_put(rc_map_af9005_table_size);
-	/* deregister this driver from the USB subsystem */
-	usb_deregister(&af9005_usb_driver);
-}
-
-module_init(af9005_usb_module_init);
-module_exit(af9005_usb_module_exit);
-
-MODULE_AUTHOR("Luca Olivetti <luca@ventoso.org>");
-MODULE_DESCRIPTION("Driver for Afatech 9005 DVB-T USB1.1 stick");
-MODULE_VERSION("1.0");
-MODULE_LICENSE("GPL");
diff -ruN ../linux-4.14.336/drivers/media/usb/dvb-usb/af9005.h ./drivers/media/usb/dvb-usb/af9005.h
--- linux-4.14.336/../linux-4.14.336/drivers/media/usb/dvb-usb/af9005.h	2024-01-10 14:45:41.000000000 +0100
+++ linux-4.14.336/./drivers/media/usb/dvb-usb/af9005.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,3492 +0,0 @@
-/* Common header-file of the Linux driver for the Afatech 9005
- * USB1.1 DVB-T receiver.
- *
- * Copyright (C) 2007 Luca Olivetti (luca@ventoso.org)
- *
- * Thanks to Afatech who kindly provided information.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * see Documentation/dvb/README.dvb-usb for more information
- */
-#ifndef _DVB_USB_AF9005_H_
-#define _DVB_USB_AF9005_H_
-
-#define DVB_USB_LOG_PREFIX "af9005"
-#include "dvb-usb.h"
-
-extern int dvb_usb_af9005_debug;
-#define deb_info(args...) dprintk(dvb_usb_af9005_debug,0x01,args)
-#define deb_xfer(args...) dprintk(dvb_usb_af9005_debug,0x02,args)
-#define deb_rc(args...)   dprintk(dvb_usb_af9005_debug,0x04,args)
-#define deb_reg(args...)  dprintk(dvb_usb_af9005_debug,0x08,args)
-#define deb_i2c(args...)  dprintk(dvb_usb_af9005_debug,0x10,args)
-#define deb_fw(args...)   dprintk(dvb_usb_af9005_debug,0x20,args)
-
-extern bool dvb_usb_af9005_led;
-
-/* firmware */
-#define FW_BULKOUT_SIZE 250
-enum {
-	FW_CONFIG,
-	FW_CONFIRM,
-	FW_BOOT
-};
-
-/* af9005 commands */
-#define AF9005_OFDM_REG  0
-#define AF9005_TUNER_REG 1
-
-#define AF9005_REGISTER_RW     0x20
-#define AF9005_REGISTER_RW_ACK 0x21
-
-#define AF9005_CMD_OFDM_REG 0x00
-#define AF9005_CMD_TUNER    0x80
-#define AF9005_CMD_BURST    0x02
-#define AF9005_CMD_AUTOINC  0x04
-#define AF9005_CMD_READ     0x00
-#define AF9005_CMD_WRITE    0x01
-
-/* af9005 registers */
-#define APO_REG_RESET					0xAEFF
-
-#define APO_REG_I2C_RW_CAN_TUNER            0xF000
-#define APO_REG_I2C_RW_SILICON_TUNER        0xF001
-#define APO_REG_GPIO_RW_SILICON_TUNER       0xFFFE	/*  also for OFSM */
-#define APO_REG_TRIGGER_OFSM                0xFFFF	/*  also for OFSM */
-
-/***********************************************************************
- *  Apollo Registers from VLSI					       *
- ***********************************************************************/
-#define xd_p_reg_aagc_inverted_agc	0xA000
-#define	reg_aagc_inverted_agc_pos 0
-#define	reg_aagc_inverted_agc_len 1
-#define	reg_aagc_inverted_agc_lsb 0
-#define xd_p_reg_aagc_sign_only	0xA000
-#define	reg_aagc_sign_only_pos 1
-#define	reg_aagc_sign_only_len 1
-#define	reg_aagc_sign_only_lsb 0
-#define xd_p_reg_aagc_slow_adc_en	0xA000
-#define	reg_aagc_slow_adc_en_pos 2
-#define	reg_aagc_slow_adc_en_len 1
-#define	reg_aagc_slow_adc_en_lsb 0
-#define xd_p_reg_aagc_slow_adc_scale	0xA000
-#define	reg_aagc_slow_adc_scale_pos 3
-#define	reg_aagc_slow_adc_scale_len 5
-#define	reg_aagc_slow_adc_scale_lsb 0
-#define xd_p_reg_aagc_check_slow_adc_lock	0xA001
-#define	reg_aagc_check_slow_adc_lock_pos 0
-#define	reg_aagc_check_slow_adc_lock_len 1
-#define	reg_aagc_check_slow_adc_lock_lsb 0
-#define xd_p_reg_aagc_init_control	0xA001
-#define	reg_aagc_init_control_pos 1
-#define	reg_aagc_init_control_len 1
-#define	reg_aagc_init_control_lsb 0
-#define xd_p_reg_aagc_total_gain_sel	0xA001
-#define	reg_aagc_total_gain_sel_pos 2
-#define	reg_aagc_total_gain_sel_len 2
-#define	reg_aagc_total_gain_sel_lsb 0
-#define xd_p_reg_aagc_out_inv	0xA001
-#define	reg_aagc_out_inv_pos 5
-#define	reg_aagc_out_inv_len 1
-#define	reg_aagc_out_inv_lsb 0
-#define xd_p_reg_aagc_int_en	0xA001
-#define	reg_aagc_int_en_pos 6
-#define	reg_aagc_int_en_len 1
-#define	reg_aagc_int_en_lsb 0
-#define xd_p_reg_aagc_lock_change_flag	0xA001
-#define	reg_aagc_lock_change_flag_pos 7
-#define	reg_aagc_lock_change_flag_len 1
-#define	reg_aagc_lock_change_flag_lsb 0
-#define xd_p_reg_aagc_rf_loop_bw_scale_acquire	0xA002
-#define	reg_aagc_rf_loop_bw_scale_acquire_pos 0
-#define	reg_aagc_rf_loop_bw_scale_acquire_len 5
-#define	reg_aagc_rf_loop_bw_scale_acquire_lsb 0
-#define xd_p_reg_aagc_rf_loop_bw_scale_track	0xA003
-#define	reg_aagc_rf_loop_bw_scale_track_pos 0
-#define	reg_aagc_rf_loop_bw_scale_track_len 5
-#define	reg_aagc_rf_loop_bw_scale_track_lsb 0
-#define xd_p_reg_aagc_if_loop_bw_scale_acquire	0xA004
-#define	reg_aagc_if_loop_bw_scale_acquire_pos 0
-#define	reg_aagc_if_loop_bw_scale_acquire_len 5
-#define	reg_aagc_if_loop_bw_scale_acquire_lsb 0
-#define xd_p_reg_aagc_if_loop_bw_scale_track	0xA005
-#define	reg_aagc_if_loop_bw_scale_track_pos 0
-#define	reg_aagc_if_loop_bw_scale_track_len 5
-#define	reg_aagc_if_loop_bw_scale_track_lsb 0
-#define xd_p_reg_aagc_max_rf_agc_7_0	0xA006
-#define	reg_aagc_max_rf_agc_7_0_pos 0
-#define	reg_aagc_max_rf_agc_7_0_len 8
-#define	reg_aagc_max_rf_agc_7_0_lsb 0
-#define xd_p_reg_aagc_max_rf_agc_9_8	0xA007
-#define	reg_aagc_max_rf_agc_9_8_pos 0
-#define	reg_aagc_max_rf_agc_9_8_len 2
-#define	reg_aagc_max_rf_agc_9_8_lsb 8
-#define xd_p_reg_aagc_min_rf_agc_7_0	0xA008
-#define	reg_aagc_min_rf_agc_7_0_pos 0
-#define	reg_aagc_min_rf_agc_7_0_len 8
-#define	reg_aagc_min_rf_agc_7_0_lsb 0
-#define xd_p_reg_aagc_min_rf_agc_9_8	0xA009
-#define	reg_aagc_min_rf_agc_9_8_pos 0
-#define	reg_aagc_min_rf_agc_9_8_len 2
-#define	reg_aagc_min_rf_agc_9_8_lsb 8
-#define xd_p_reg_aagc_max_if_agc_7_0	0xA00A
-#define	reg_aagc_max_if_agc_7_0_pos 0
-#define	reg_aagc_max_if_agc_7_0_len 8
-#define	reg_aagc_max_if_agc_7_0_lsb 0
-#define xd_p_reg_aagc_max_if_agc_9_8	0xA00B
-#define	reg_aagc_max_if_agc_9_8_pos 0
-#define	reg_aagc_max_if_agc_9_8_len 2
-#define	reg_aagc_max_if_agc_9_8_lsb 8
-#define xd_p_reg_aagc_min_if_agc_7_0	0xA00C
-#define	reg_aagc_min_if_agc_7_0_pos 0
-#define	reg_aagc_min_if_agc_7_0_len 8
-#define	reg_aagc_min_if_agc_7_0_lsb 0
-#define xd_p_reg_aagc_min_if_agc_9_8	0xA00D
-#define	reg_aagc_min_if_agc_9_8_pos 0
-#define	reg_aagc_min_if_agc_9_8_len 2
-#define	reg_aagc_min_if_agc_9_8_lsb 8
-#define xd_p_reg_aagc_lock_sample_scale	0xA00E
-#define	reg_aagc_lock_sample_scale_pos 0
-#define	reg_aagc_lock_sample_scale_len 5
-#define	reg_aagc_lock_sample_scale_lsb 0
-#define xd_p_reg_aagc_rf_agc_lock_scale_acquire	0xA00F
-#define	reg_aagc_rf_agc_lock_scale_acquire_pos 0
-#define	reg_aagc_rf_agc_lock_scale_acquire_len 3
-#define	reg_aagc_rf_agc_lock_scale_acquire_lsb 0
-#define xd_p_reg_aagc_rf_agc_lock_scale_track	0xA00F
-#define	reg_aagc_rf_agc_lock_scale_track_pos 3
-#define	reg_aagc_rf_agc_lock_scale_track_len 3
-#define	reg_aagc_rf_agc_lock_scale_track_lsb 0
-#define xd_p_reg_aagc_if_agc_lock_scale_acquire	0xA010
-#define	reg_aagc_if_agc_lock_scale_acquire_pos 0
-#define	reg_aagc_if_agc_lock_scale_acquire_len 3
-#define	reg_aagc_if_agc_lock_scale_acquire_lsb 0
-#define xd_p_reg_aagc_if_agc_lock_scale_track	0xA010
-#define	reg_aagc_if_agc_lock_scale_track_pos 3
-#define	reg_aagc_if_agc_lock_scale_track_len 3
-#define	reg_aagc_if_agc_lock_scale_track_lsb 0
-#define xd_p_reg_aagc_rf_top_numerator_7_0	0xA011
-#define	reg_aagc_rf_top_numerator_7_0_pos 0
-#define	reg_aagc_rf_top_numerator_7_0_len 8
-#define	reg_aagc_rf_top_numerator_7_0_lsb 0
-#define xd_p_reg_aagc_rf_top_numerator_9_8	0xA012
-#define	reg_aagc_rf_top_numerator_9_8_pos 0
-#define	reg_aagc_rf_top_numerator_9_8_len 2
-#define	reg_aagc_rf_top_numerator_9_8_lsb 8
-#define xd_p_reg_aagc_if_top_numerator_7_0	0xA013
-#define	reg_aagc_if_top_numerator_7_0_pos 0
-#define	reg_aagc_if_top_numerator_7_0_len 8
-#define	reg_aagc_if_top_numerator_7_0_lsb 0
-#define xd_p_reg_aagc_if_top_numerator_9_8	0xA014
-#define	reg_aagc_if_top_numerator_9_8_pos 0
-#define	reg_aagc_if_top_numerator_9_8_len 2
-#define	reg_aagc_if_top_numerator_9_8_lsb 8
-#define xd_p_reg_aagc_adc_out_desired_7_0	0xA015
-#define	reg_aagc_adc_out_desired_7_0_pos 0
-#define	reg_aagc_adc_out_desired_7_0_len 8
-#define	reg_aagc_adc_out_desired_7_0_lsb 0
-#define xd_p_reg_aagc_adc_out_desired_8	0xA016
-#define	reg_aagc_adc_out_desired_8_pos 0
-#define	reg_aagc_adc_out_desired_8_len 1
-#define	reg_aagc_adc_out_desired_8_lsb 0
-#define xd_p_reg_aagc_fixed_gain	0xA016
-#define	reg_aagc_fixed_gain_pos 3
-#define	reg_aagc_fixed_gain_len 1
-#define	reg_aagc_fixed_gain_lsb 0
-#define xd_p_reg_aagc_lock_count_th	0xA016
-#define	reg_aagc_lock_count_th_pos 4
-#define	reg_aagc_lock_count_th_len 4
-#define	reg_aagc_lock_count_th_lsb 0
-#define xd_p_reg_aagc_fixed_rf_agc_control_7_0	0xA017
-#define	reg_aagc_fixed_rf_agc_control_7_0_pos 0
-#define	reg_aagc_fixed_rf_agc_control_7_0_len 8
-#define	reg_aagc_fixed_rf_agc_control_7_0_lsb 0
-#define xd_p_reg_aagc_fixed_rf_agc_control_15_8	0xA018
-#define	reg_aagc_fixed_rf_agc_control_15_8_pos 0
-#define	reg_aagc_fixed_rf_agc_control_15_8_len 8
-#define	reg_aagc_fixed_rf_agc_control_15_8_lsb 8
-#define xd_p_reg_aagc_fixed_rf_agc_control_23_16	0xA019
-#define	reg_aagc_fixed_rf_agc_control_23_16_pos 0
-#define	reg_aagc_fixed_rf_agc_control_23_16_len 8
-#define	reg_aagc_fixed_rf_agc_control_23_16_lsb 16
-#define xd_p_reg_aagc_fixed_rf_agc_control_30_24	0xA01A
-#define	reg_aagc_fixed_rf_agc_control_30_24_pos 0
-#define	reg_aagc_fixed_rf_agc_control_30_24_len 7
-#define	reg_aagc_fixed_rf_agc_control_30_24_lsb 24
-#define xd_p_reg_aagc_fixed_if_agc_control_7_0	0xA01B
-#define	reg_aagc_fixed_if_agc_control_7_0_pos 0
-#define	reg_aagc_fixed_if_agc_control_7_0_len 8
-#define	reg_aagc_fixed_if_agc_control_7_0_lsb 0
-#define xd_p_reg_aagc_fixed_if_agc_control_15_8	0xA01C
-#define	reg_aagc_fixed_if_agc_control_15_8_pos 0
-#define	reg_aagc_fixed_if_agc_control_15_8_len 8
-#define	reg_aagc_fixed_if_agc_control_15_8_lsb 8
-#define xd_p_reg_aagc_fixed_if_agc_control_23_16	0xA01D
-#define	reg_aagc_fixed_if_agc_control_23_16_pos 0
-#define	reg_aagc_fixed_if_agc_control_23_16_len 8
-#define	reg_aagc_fixed_if_agc_control_23_16_lsb 16
-#define xd_p_reg_aagc_fixed_if_agc_control_30_24	0xA01E
-#define	reg_aagc_fixed_if_agc_control_30_24_pos 0
-#define	reg_aagc_fixed_if_agc_control_30_24_len 7
-#define	reg_aagc_fixed_if_agc_control_30_24_lsb 24
-#define xd_p_reg_aagc_rf_agc_unlock_numerator	0xA01F
-#define	reg_aagc_rf_agc_unlock_numerator_pos 0
-#define	reg_aagc_rf_agc_unlock_numerator_len 6
-#define	reg_aagc_rf_agc_unlock_numerator_lsb 0
-#define xd_p_reg_aagc_if_agc_unlock_numerator	0xA020
-#define	reg_aagc_if_agc_unlock_numerator_pos 0
-#define	reg_aagc_if_agc_unlock_numerator_len 6
-#define	reg_aagc_if_agc_unlock_numerator_lsb 0
-#define xd_p_reg_unplug_th	0xA021
-#define	reg_unplug_th_pos 0
-#define	reg_unplug_th_len 8
-#define	reg_aagc_rf_x0_lsb 0
-#define xd_p_reg_weak_signal_rfagc_thr 0xA022
-#define	reg_weak_signal_rfagc_thr_pos 0
-#define	reg_weak_signal_rfagc_thr_len 8
-#define	reg_weak_signal_rfagc_thr_lsb 0
-#define xd_p_reg_unplug_rf_gain_th 0xA023
-#define	reg_unplug_rf_gain_th_pos 0
-#define	reg_unplug_rf_gain_th_len 8
-#define	reg_unplug_rf_gain_th_lsb 0
-#define xd_p_reg_unplug_dtop_rf_gain_th 0xA024
-#define	reg_unplug_dtop_rf_gain_th_pos 0
-#define	reg_unplug_dtop_rf_gain_th_len 8
-#define	reg_unplug_dtop_rf_gain_th_lsb 0
-#define xd_p_reg_unplug_dtop_if_gain_th 0xA025
-#define	reg_unplug_dtop_if_gain_th_pos 0
-#define	reg_unplug_dtop_if_gain_th_len 8
-#define	reg_unplug_dtop_if_gain_th_lsb 0
-#define xd_p_reg_top_recover_at_unplug_en 0xA026
-#define	reg_top_recover_at_unplug_en_pos 0
-#define	reg_top_recover_at_unplug_en_len 1
-#define	reg_top_recover_at_unplug_en_lsb 0
-#define xd_p_reg_aagc_rf_x6	0xA027
-#define	reg_aagc_rf_x6_pos 0
-#define	reg_aagc_rf_x6_len 8
-#define	reg_aagc_rf_x6_lsb 0
-#define xd_p_reg_aagc_rf_x7	0xA028
-#define	reg_aagc_rf_x7_pos 0
-#define	reg_aagc_rf_x7_len 8
-#define	reg_aagc_rf_x7_lsb 0
-#define xd_p_reg_aagc_rf_x8	0xA029
-#define	reg_aagc_rf_x8_pos 0
-#define	reg_aagc_rf_x8_len 8
-#define	reg_aagc_rf_x8_lsb 0
-#define xd_p_reg_aagc_rf_x9	0xA02A
-#define	reg_aagc_rf_x9_pos 0
-#define	reg_aagc_rf_x9_len 8
-#define	reg_aagc_rf_x9_lsb 0
-#define xd_p_reg_aagc_rf_x10	0xA02B
-#define	reg_aagc_rf_x10_pos 0
-#define	reg_aagc_rf_x10_len 8
-#define	reg_aagc_rf_x10_lsb 0
-#define xd_p_reg_aagc_rf_x11	0xA02C
-#define	reg_aagc_rf_x11_pos 0
-#define	reg_aagc_rf_x11_len 8
-#define	reg_aagc_rf_x11_lsb 0
-#define xd_p_reg_aagc_rf_x12	0xA02D
-#define	reg_aagc_rf_x12_pos 0
-#define	reg_aagc_rf_x12_len 8
-#define	reg_aagc_rf_x12_lsb 0
-#define xd_p_reg_aagc_rf_x13	0xA02E
-#define	reg_aagc_rf_x13_pos 0
-#define	reg_aagc_rf_x13_len 8
-#define	reg_aagc_rf_x13_lsb 0
-#define xd_p_reg_aagc_if_x0	0xA02F
-#define	reg_aagc_if_x0_pos 0
-#define	reg_aagc_if_x0_len 8
-#define	reg_aagc_if_x0_lsb 0
-#define xd_p_reg_aagc_if_x1	0xA030
-#define	reg_aagc_if_x1_pos 0
-#define	reg_aagc_if_x1_len 8
-#define	reg_aagc_if_x1_lsb 0
-#define xd_p_reg_aagc_if_x2	0xA031
-#define	reg_aagc_if_x2_pos 0
-#define	reg_aagc_if_x2_len 8
-#define	reg_aagc_if_x2_lsb 0
-#define xd_p_reg_aagc_if_x3	0xA032
-#define	reg_aagc_if_x3_pos 0
-#define	reg_aagc_if_x3_len 8
-#define	reg_aagc_if_x3_lsb 0
-#define xd_p_reg_aagc_if_x4	0xA033
-#define	reg_aagc_if_x4_pos 0
-#define	reg_aagc_if_x4_len 8
-#define	reg_aagc_if_x4_lsb 0
-#define xd_p_reg_aagc_if_x5	0xA034
-#define	reg_aagc_if_x5_pos 0
-#define	reg_aagc_if_x5_len 8
-#define	reg_aagc_if_x5_lsb 0
-#define xd_p_reg_aagc_if_x6	0xA035
-#define	reg_aagc_if_x6_pos 0
-#define	reg_aagc_if_x6_len 8
-#define	reg_aagc_if_x6_lsb 0
-#define xd_p_reg_aagc_if_x7	0xA036
-#define	reg_aagc_if_x7_pos 0
-#define	reg_aagc_if_x7_len 8
-#define	reg_aagc_if_x7_lsb 0
-#define xd_p_reg_aagc_if_x8	0xA037
-#define	reg_aagc_if_x8_pos 0
-#define	reg_aagc_if_x8_len 8
-#define	reg_aagc_if_x8_lsb 0
-#define xd_p_reg_aagc_if_x9	0xA038
-#define	reg_aagc_if_x9_pos 0
-#define	reg_aagc_if_x9_len 8
-#define	reg_aagc_if_x9_lsb 0
-#define xd_p_reg_aagc_if_x10	0xA039
-#define	reg_aagc_if_x10_pos 0
-#define	reg_aagc_if_x10_len 8
-#define	reg_aagc_if_x10_lsb 0
-#define xd_p_reg_aagc_if_x11	0xA03A
-#define	reg_aagc_if_x11_pos 0
-#define	reg_aagc_if_x11_len 8
-#define	reg_aagc_if_x11_lsb 0
-#define xd_p_reg_aagc_if_x12	0xA03B
-#define	reg_aagc_if_x12_pos 0
-#define	reg_aagc_if_x12_len 8
-#define	reg_aagc_if_x12_lsb 0
-#define xd_p_reg_aagc_if_x13	0xA03C
-#define	reg_aagc_if_x13_pos 0
-#define	reg_aagc_if_x13_len 8
-#define	reg_aagc_if_x13_lsb 0
-#define xd_p_reg_aagc_min_rf_ctl_8bit_for_dca	0xA03D
-#define	reg_aagc_min_rf_ctl_8bit_for_dca_pos 0
-#define	reg_aagc_min_rf_ctl_8bit_for_dca_len 8
-#define	reg_aagc_min_rf_ctl_8bit_for_dca_lsb 0
-#define xd_p_reg_aagc_min_if_ctl_8bit_for_dca	0xA03E
-#define	reg_aagc_min_if_ctl_8bit_for_dca_pos 0
-#define	reg_aagc_min_if_ctl_8bit_for_dca_len 8
-#define	reg_aagc_min_if_ctl_8bit_for_dca_lsb 0
-#define xd_r_reg_aagc_total_gain_7_0	0xA070
-#define	reg_aagc_total_gain_7_0_pos 0
-#define	reg_aagc_total_gain_7_0_len 8
-#define	reg_aagc_total_gain_7_0_lsb 0
-#define xd_r_reg_aagc_total_gain_15_8	0xA071
-#define	reg_aagc_total_gain_15_8_pos 0
-#define	reg_aagc_total_gain_15_8_len 8
-#define	reg_aagc_total_gain_15_8_lsb 8
-#define xd_p_reg_aagc_in_sat_cnt_7_0	0xA074
-#define	reg_aagc_in_sat_cnt_7_0_pos 0
-#define	reg_aagc_in_sat_cnt_7_0_len 8
-#define	reg_aagc_in_sat_cnt_7_0_lsb 0
-#define xd_p_reg_aagc_in_sat_cnt_15_8	0xA075
-#define	reg_aagc_in_sat_cnt_15_8_pos 0
-#define	reg_aagc_in_sat_cnt_15_8_len 8
-#define	reg_aagc_in_sat_cnt_15_8_lsb 8
-#define xd_p_reg_aagc_in_sat_cnt_23_16	0xA076
-#define	reg_aagc_in_sat_cnt_23_16_pos 0
-#define	reg_aagc_in_sat_cnt_23_16_len 8
-#define	reg_aagc_in_sat_cnt_23_16_lsb 16
-#define xd_p_reg_aagc_in_sat_cnt_31_24	0xA077
-#define	reg_aagc_in_sat_cnt_31_24_pos 0
-#define	reg_aagc_in_sat_cnt_31_24_len 8
-#define	reg_aagc_in_sat_cnt_31_24_lsb 24
-#define xd_r_reg_aagc_digital_rf_volt_7_0	0xA078
-#define	reg_aagc_digital_rf_volt_7_0_pos 0
-#define	reg_aagc_digital_rf_volt_7_0_len 8
-#define	reg_aagc_digital_rf_volt_7_0_lsb 0
-#define xd_r_reg_aagc_digital_rf_volt_9_8	0xA079
-#define	reg_aagc_digital_rf_volt_9_8_pos 0
-#define	reg_aagc_digital_rf_volt_9_8_len 2
-#define	reg_aagc_digital_rf_volt_9_8_lsb 8
-#define xd_r_reg_aagc_digital_if_volt_7_0	0xA07A
-#define	reg_aagc_digital_if_volt_7_0_pos 0
-#define	reg_aagc_digital_if_volt_7_0_len 8
-#define	reg_aagc_digital_if_volt_7_0_lsb 0
-#define xd_r_reg_aagc_digital_if_volt_9_8	0xA07B
-#define	reg_aagc_digital_if_volt_9_8_pos 0
-#define	reg_aagc_digital_if_volt_9_8_len 2
-#define	reg_aagc_digital_if_volt_9_8_lsb 8
-#define xd_r_reg_aagc_rf_gain	0xA07C
-#define	reg_aagc_rf_gain_pos 0
-#define	reg_aagc_rf_gain_len 8
-#define	reg_aagc_rf_gain_lsb 0
-#define xd_r_reg_aagc_if_gain	0xA07D
-#define	reg_aagc_if_gain_pos 0
-#define	reg_aagc_if_gain_len 8
-#define	reg_aagc_if_gain_lsb 0
-#define xd_p_tinr_imp_indicator	0xA080
-#define	tinr_imp_indicator_pos 0
-#define	tinr_imp_indicator_len 2
-#define	tinr_imp_indicator_lsb 0
-#define xd_p_reg_tinr_fifo_size	0xA080
-#define	reg_tinr_fifo_size_pos 2
-#define	reg_tinr_fifo_size_len 5
-#define	reg_tinr_fifo_size_lsb 0
-#define xd_p_reg_tinr_saturation_cnt_th	0xA081
-#define	reg_tinr_saturation_cnt_th_pos 0
-#define	reg_tinr_saturation_cnt_th_len 4
-#define	reg_tinr_saturation_cnt_th_lsb 0
-#define xd_p_reg_tinr_saturation_th_3_0	0xA081
-#define	reg_tinr_saturation_th_3_0_pos 4
-#define	reg_tinr_saturation_th_3_0_len 4
-#define	reg_tinr_saturation_th_3_0_lsb 0
-#define xd_p_reg_tinr_saturation_th_8_4	0xA082
-#define	reg_tinr_saturation_th_8_4_pos 0
-#define	reg_tinr_saturation_th_8_4_len 5
-#define	reg_tinr_saturation_th_8_4_lsb 4
-#define xd_p_reg_tinr_imp_duration_th_2k_7_0	0xA083
-#define	reg_tinr_imp_duration_th_2k_7_0_pos 0
-#define	reg_tinr_imp_duration_th_2k_7_0_len 8
-#define	reg_tinr_imp_duration_th_2k_7_0_lsb 0
-#define xd_p_reg_tinr_imp_duration_th_2k_8	0xA084
-#define	reg_tinr_imp_duration_th_2k_8_pos 0
-#define	reg_tinr_imp_duration_th_2k_8_len 1
-#define	reg_tinr_imp_duration_th_2k_8_lsb 0
-#define xd_p_reg_tinr_imp_duration_th_8k_7_0	0xA085
-#define	reg_tinr_imp_duration_th_8k_7_0_pos 0
-#define	reg_tinr_imp_duration_th_8k_7_0_len 8
-#define	reg_tinr_imp_duration_th_8k_7_0_lsb 0
-#define xd_p_reg_tinr_imp_duration_th_8k_10_8	0xA086
-#define	reg_tinr_imp_duration_th_8k_10_8_pos 0
-#define	reg_tinr_imp_duration_th_8k_10_8_len 3
-#define	reg_tinr_imp_duration_th_8k_10_8_lsb 8
-#define xd_p_reg_tinr_freq_ratio_6m_7_0	0xA087
-#define	reg_tinr_freq_ratio_6m_7_0_pos 0
-#define	reg_tinr_freq_ratio_6m_7_0_len 8
-#define	reg_tinr_freq_ratio_6m_7_0_lsb 0
-#define xd_p_reg_tinr_freq_ratio_6m_12_8	0xA088
-#define	reg_tinr_freq_ratio_6m_12_8_pos 0
-#define	reg_tinr_freq_ratio_6m_12_8_len 5
-#define	reg_tinr_freq_ratio_6m_12_8_lsb 8
-#define xd_p_reg_tinr_freq_ratio_7m_7_0	0xA089
-#define	reg_tinr_freq_ratio_7m_7_0_pos 0
-#define	reg_tinr_freq_ratio_7m_7_0_len 8
-#define	reg_tinr_freq_ratio_7m_7_0_lsb 0
-#define xd_p_reg_tinr_freq_ratio_7m_12_8	0xA08A
-#define	reg_tinr_freq_ratio_7m_12_8_pos 0
-#define	reg_tinr_freq_ratio_7m_12_8_len 5
-#define	reg_tinr_freq_ratio_7m_12_8_lsb 8
-#define xd_p_reg_tinr_freq_ratio_8m_7_0	0xA08B
-#define	reg_tinr_freq_ratio_8m_7_0_pos 0
-#define	reg_tinr_freq_ratio_8m_7_0_len 8
-#define	reg_tinr_freq_ratio_8m_7_0_lsb 0
-#define xd_p_reg_tinr_freq_ratio_8m_12_8	0xA08C
-#define	reg_tinr_freq_ratio_8m_12_8_pos 0
-#define	reg_tinr_freq_ratio_8m_12_8_len 5
-#define	reg_tinr_freq_ratio_8m_12_8_lsb 8
-#define xd_p_reg_tinr_imp_duration_th_low_2k	0xA08D
-#define	reg_tinr_imp_duration_th_low_2k_pos 0
-#define	reg_tinr_imp_duration_th_low_2k_len 8
-#define	reg_tinr_imp_duration_th_low_2k_lsb 0
-#define xd_p_reg_tinr_imp_duration_th_low_8k	0xA08E
-#define	reg_tinr_imp_duration_th_low_8k_pos 0
-#define	reg_tinr_imp_duration_th_low_8k_len 8
-#define	reg_tinr_imp_duration_th_low_8k_lsb 0
-#define xd_r_reg_tinr_counter_7_0	0xA090
-#define	reg_tinr_counter_7_0_pos 0
-#define	reg_tinr_counter_7_0_len 8
-#define	reg_tinr_counter_7_0_lsb 0
-#define xd_r_reg_tinr_counter_15_8	0xA091
-#define	reg_tinr_counter_15_8_pos 0
-#define	reg_tinr_counter_15_8_len 8
-#define	reg_tinr_counter_15_8_lsb 8
-#define xd_p_reg_tinr_adative_tinr_en	0xA093
-#define	reg_tinr_adative_tinr_en_pos 0
-#define	reg_tinr_adative_tinr_en_len 1
-#define	reg_tinr_adative_tinr_en_lsb 0
-#define xd_p_reg_tinr_peak_fifo_size	0xA093
-#define	reg_tinr_peak_fifo_size_pos 1
-#define	reg_tinr_peak_fifo_size_len 5
-#define	reg_tinr_peak_fifo_size_lsb 0
-#define xd_p_reg_tinr_counter_rst	0xA093
-#define	reg_tinr_counter_rst_pos 6
-#define	reg_tinr_counter_rst_len 1
-#define	reg_tinr_counter_rst_lsb 0
-#define xd_p_reg_tinr_search_period_7_0	0xA094
-#define	reg_tinr_search_period_7_0_pos 0
-#define	reg_tinr_search_period_7_0_len 8
-#define	reg_tinr_search_period_7_0_lsb 0
-#define xd_p_reg_tinr_search_period_15_8	0xA095
-#define	reg_tinr_search_period_15_8_pos 0
-#define	reg_tinr_search_period_15_8_len 8
-#define	reg_tinr_search_period_15_8_lsb 8
-#define xd_p_reg_ccifs_fcw_7_0	0xA0A0
-#define	reg_ccifs_fcw_7_0_pos 0
-#define	reg_ccifs_fcw_7_0_len 8
-#define	reg_ccifs_fcw_7_0_lsb 0
-#define xd_p_reg_ccifs_fcw_12_8	0xA0A1
-#define	reg_ccifs_fcw_12_8_pos 0
-#define	reg_ccifs_fcw_12_8_len 5
-#define	reg_ccifs_fcw_12_8_lsb 8
-#define xd_p_reg_ccifs_spec_inv	0xA0A1
-#define	reg_ccifs_spec_inv_pos 5
-#define	reg_ccifs_spec_inv_len 1
-#define	reg_ccifs_spec_inv_lsb 0
-#define xd_p_reg_gp_trigger	0xA0A2
-#define	reg_gp_trigger_pos 0
-#define	reg_gp_trigger_len 1
-#define	reg_gp_trigger_lsb 0
-#define xd_p_reg_trigger_sel	0xA0A2
-#define	reg_trigger_sel_pos 1
-#define	reg_trigger_sel_len 2
-#define	reg_trigger_sel_lsb 0
-#define xd_p_reg_debug_ofdm	0xA0A2
-#define	reg_debug_ofdm_pos 3
-#define	reg_debug_ofdm_len 2
-#define	reg_debug_ofdm_lsb 0
-#define xd_p_reg_trigger_module_sel	0xA0A3
-#define	reg_trigger_module_sel_pos 0
-#define	reg_trigger_module_sel_len 6
-#define	reg_trigger_module_sel_lsb 0
-#define xd_p_reg_trigger_set_sel	0xA0A4
-#define	reg_trigger_set_sel_pos 0
-#define	reg_trigger_set_sel_len 6
-#define	reg_trigger_set_sel_lsb 0
-#define xd_p_reg_fw_int_mask_n	0xA0A4
-#define	reg_fw_int_mask_n_pos 6
-#define	reg_fw_int_mask_n_len 1
-#define	reg_fw_int_mask_n_lsb 0
-#define xd_p_reg_debug_group	0xA0A5
-#define	reg_debug_group_pos 0
-#define	reg_debug_group_len 4
-#define	reg_debug_group_lsb 0
-#define xd_p_reg_odbg_clk_sel	0xA0A5
-#define	reg_odbg_clk_sel_pos 4
-#define	reg_odbg_clk_sel_len 2
-#define	reg_odbg_clk_sel_lsb 0
-#define xd_p_reg_ccif_sc	0xA0C0
-#define	reg_ccif_sc_pos 0
-#define	reg_ccif_sc_len 4
-#define	reg_ccif_sc_lsb 0
-#define xd_r_reg_ccif_saturate	0xA0C1
-#define	reg_ccif_saturate_pos 0
-#define	reg_ccif_saturate_len 2
-#define	reg_ccif_saturate_lsb 0
-#define xd_r_reg_antif_saturate	0xA0C1
-#define	reg_antif_saturate_pos 2
-#define	reg_antif_saturate_len 4
-#define	reg_antif_saturate_lsb 0
-#define xd_r_reg_acif_saturate	0xA0C2
-#define	reg_acif_saturate_pos 0
-#define	reg_acif_saturate_len 8
-#define	reg_acif_saturate_lsb 0
-#define xd_p_reg_tmr_timer0_threshold_7_0	0xA0C8
-#define	reg_tmr_timer0_threshold_7_0_pos 0
-#define	reg_tmr_timer0_threshold_7_0_len 8
-#define	reg_tmr_timer0_threshold_7_0_lsb 0
-#define xd_p_reg_tmr_timer0_threshold_15_8	0xA0C9
-#define	reg_tmr_timer0_threshold_15_8_pos 0
-#define	reg_tmr_timer0_threshold_15_8_len 8
-#define	reg_tmr_timer0_threshold_15_8_lsb 8
-#define xd_p_reg_tmr_timer0_enable	0xA0CA
-#define	reg_tmr_timer0_enable_pos 0
-#define	reg_tmr_timer0_enable_len 1
-#define	reg_tmr_timer0_enable_lsb 0
-#define xd_p_reg_tmr_timer0_clk_sel	0xA0CA
-#define	reg_tmr_timer0_clk_sel_pos 1
-#define	reg_tmr_timer0_clk_sel_len 1
-#define	reg_tmr_timer0_clk_sel_lsb 0
-#define xd_p_reg_tmr_timer0_int	0xA0CA
-#define	reg_tmr_timer0_int_pos 2
-#define	reg_tmr_timer0_int_len 1
-#define	reg_tmr_timer0_int_lsb 0
-#define xd_p_reg_tmr_timer0_rst	0xA0CA
-#define	reg_tmr_timer0_rst_pos 3
-#define	reg_tmr_timer0_rst_len 1
-#define	reg_tmr_timer0_rst_lsb 0
-#define xd_r_reg_tmr_timer0_count_7_0	0xA0CB
-#define	reg_tmr_timer0_count_7_0_pos 0
-#define	reg_tmr_timer0_count_7_0_len 8
-#define	reg_tmr_timer0_count_7_0_lsb 0
-#define xd_r_reg_tmr_timer0_count_15_8	0xA0CC
-#define	reg_tmr_timer0_count_15_8_pos 0
-#define	reg_tmr_timer0_count_15_8_len 8
-#define	reg_tmr_timer0_count_15_8_lsb 8
-#define xd_p_reg_suspend	0xA0CD
-#define	reg_suspend_pos 0
-#define	reg_suspend_len 1
-#define	reg_suspend_lsb 0
-#define xd_p_reg_suspend_rdy	0xA0CD
-#define	reg_suspend_rdy_pos 1
-#define	reg_suspend_rdy_len 1
-#define	reg_suspend_rdy_lsb 0
-#define xd_p_reg_resume	0xA0CD
-#define	reg_resume_pos 2
-#define	reg_resume_len 1
-#define	reg_resume_lsb 0
-#define xd_p_reg_resume_rdy	0xA0CD
-#define	reg_resume_rdy_pos 3
-#define	reg_resume_rdy_len 1
-#define	reg_resume_rdy_lsb 0
-#define xd_p_reg_fmf	0xA0CE
-#define	reg_fmf_pos 0
-#define	reg_fmf_len 8
-#define	reg_fmf_lsb 0
-#define xd_p_ccid_accumulate_num_2k_7_0	0xA100
-#define	ccid_accumulate_num_2k_7_0_pos 0
-#define	ccid_accumulate_num_2k_7_0_len 8
-#define	ccid_accumulate_num_2k_7_0_lsb 0
-#define xd_p_ccid_accumulate_num_2k_12_8	0xA101
-#define	ccid_accumulate_num_2k_12_8_pos 0
-#define	ccid_accumulate_num_2k_12_8_len 5
-#define	ccid_accumulate_num_2k_12_8_lsb 8
-#define xd_p_ccid_accumulate_num_8k_7_0	0xA102
-#define	ccid_accumulate_num_8k_7_0_pos 0
-#define	ccid_accumulate_num_8k_7_0_len 8
-#define	ccid_accumulate_num_8k_7_0_lsb 0
-#define xd_p_ccid_accumulate_num_8k_14_8	0xA103
-#define	ccid_accumulate_num_8k_14_8_pos 0
-#define	ccid_accumulate_num_8k_14_8_len 7
-#define	ccid_accumulate_num_8k_14_8_lsb 8
-#define xd_p_ccid_desired_level_0	0xA103
-#define	ccid_desired_level_0_pos 7
-#define	ccid_desired_level_0_len 1
-#define	ccid_desired_level_0_lsb 0
-#define xd_p_ccid_desired_level_8_1	0xA104
-#define	ccid_desired_level_8_1_pos 0
-#define	ccid_desired_level_8_1_len 8
-#define	ccid_desired_level_8_1_lsb 1
-#define xd_p_ccid_apply_delay	0xA105
-#define	ccid_apply_delay_pos 0
-#define	ccid_apply_delay_len 7
-#define	ccid_apply_delay_lsb 0
-#define xd_p_ccid_CCID_Threshold1	0xA106
-#define	ccid_CCID_Threshold1_pos 0
-#define	ccid_CCID_Threshold1_len 8
-#define	ccid_CCID_Threshold1_lsb 0
-#define xd_p_ccid_CCID_Threshold2	0xA107
-#define	ccid_CCID_Threshold2_pos 0
-#define	ccid_CCID_Threshold2_len 8
-#define	ccid_CCID_Threshold2_lsb 0
-#define xd_p_reg_ccid_gain_scale	0xA108
-#define	reg_ccid_gain_scale_pos 0
-#define	reg_ccid_gain_scale_len 4
-#define	reg_ccid_gain_scale_lsb 0
-#define xd_p_reg_ccid2_passband_gain_set	0xA108
-#define	reg_ccid2_passband_gain_set_pos 4
-#define	reg_ccid2_passband_gain_set_len 4
-#define	reg_ccid2_passband_gain_set_lsb 0
-#define xd_r_ccid_multiplier_7_0	0xA109
-#define	ccid_multiplier_7_0_pos 0
-#define	ccid_multiplier_7_0_len 8
-#define	ccid_multiplier_7_0_lsb 0
-#define xd_r_ccid_multiplier_15_8	0xA10A
-#define	ccid_multiplier_15_8_pos 0
-#define	ccid_multiplier_15_8_len 8
-#define	ccid_multiplier_15_8_lsb 8
-#define xd_r_ccid_right_shift_bits	0xA10B
-#define	ccid_right_shift_bits_pos 0
-#define	ccid_right_shift_bits_len 4
-#define	ccid_right_shift_bits_lsb 0
-#define xd_r_reg_ccid_sx_7_0	0xA10C
-#define	reg_ccid_sx_7_0_pos 0
-#define	reg_ccid_sx_7_0_len 8
-#define	reg_ccid_sx_7_0_lsb 0
-#define xd_r_reg_ccid_sx_15_8	0xA10D
-#define	reg_ccid_sx_15_8_pos 0
-#define	reg_ccid_sx_15_8_len 8
-#define	reg_ccid_sx_15_8_lsb 8
-#define xd_r_reg_ccid_sx_21_16	0xA10E
-#define	reg_ccid_sx_21_16_pos 0
-#define	reg_ccid_sx_21_16_len 6
-#define	reg_ccid_sx_21_16_lsb 16
-#define xd_r_reg_ccid_sy_7_0	0xA110
-#define	reg_ccid_sy_7_0_pos 0
-#define	reg_ccid_sy_7_0_len 8
-#define	reg_ccid_sy_7_0_lsb 0
-#define xd_r_reg_ccid_sy_15_8	0xA111
-#define	reg_ccid_sy_15_8_pos 0
-#define	reg_ccid_sy_15_8_len 8
-#define	reg_ccid_sy_15_8_lsb 8
-#define xd_r_reg_ccid_sy_23_16	0xA112
-#define	reg_ccid_sy_23_16_pos 0
-#define	reg_ccid_sy_23_16_len 8
-#define	reg_ccid_sy_23_16_lsb 16
-#define xd_r_reg_ccid2_sz_7_0	0xA114
-#define	reg_ccid2_sz_7_0_pos 0
-#define	reg_ccid2_sz_7_0_len 8
-#define	reg_ccid2_sz_7_0_lsb 0
-#define xd_r_reg_ccid2_sz_15_8	0xA115
-#define	reg_ccid2_sz_15_8_pos 0
-#define	reg_ccid2_sz_15_8_len 8
-#define	reg_ccid2_sz_15_8_lsb 8
-#define xd_r_reg_ccid2_sz_23_16	0xA116
-#define	reg_ccid2_sz_23_16_pos 0
-#define	reg_ccid2_sz_23_16_len 8
-#define	reg_ccid2_sz_23_16_lsb 16
-#define xd_r_reg_ccid2_sz_25_24	0xA117
-#define	reg_ccid2_sz_25_24_pos 0
-#define	reg_ccid2_sz_25_24_len 2
-#define	reg_ccid2_sz_25_24_lsb 24
-#define xd_r_reg_ccid2_sy_7_0	0xA118
-#define	reg_ccid2_sy_7_0_pos 0
-#define	reg_ccid2_sy_7_0_len 8
-#define	reg_ccid2_sy_7_0_lsb 0
-#define xd_r_reg_ccid2_sy_15_8	0xA119
-#define	reg_ccid2_sy_15_8_pos 0
-#define	reg_ccid2_sy_15_8_len 8
-#define	reg_ccid2_sy_15_8_lsb 8
-#define xd_r_reg_ccid2_sy_23_16	0xA11A
-#define	reg_ccid2_sy_23_16_pos 0
-#define	reg_ccid2_sy_23_16_len 8
-#define	reg_ccid2_sy_23_16_lsb 16
-#define xd_r_reg_ccid2_sy_25_24	0xA11B
-#define	reg_ccid2_sy_25_24_pos 0
-#define	reg_ccid2_sy_25_24_len 2
-#define	reg_ccid2_sy_25_24_lsb 24
-#define xd_p_dagc1_accumulate_num_2k_7_0	0xA120
-#define	dagc1_accumulate_num_2k_7_0_pos 0
-#define	dagc1_accumulate_num_2k_7_0_len 8
-#define	dagc1_accumulate_num_2k_7_0_lsb 0
-#define xd_p_dagc1_accumulate_num_2k_12_8	0xA121
-#define	dagc1_accumulate_num_2k_12_8_pos 0
-#define	dagc1_accumulate_num_2k_12_8_len 5
-#define	dagc1_accumulate_num_2k_12_8_lsb 8
-#define xd_p_dagc1_accumulate_num_8k_7_0	0xA122
-#define	dagc1_accumulate_num_8k_7_0_pos 0
-#define	dagc1_accumulate_num_8k_7_0_len 8
-#define	dagc1_accumulate_num_8k_7_0_lsb 0
-#define xd_p_dagc1_accumulate_num_8k_14_8	0xA123
-#define	dagc1_accumulate_num_8k_14_8_pos 0
-#define	dagc1_accumulate_num_8k_14_8_len 7
-#define	dagc1_accumulate_num_8k_14_8_lsb 8
-#define xd_p_dagc1_desired_level_0	0xA123
-#define	dagc1_desired_level_0_pos 7
-#define	dagc1_desired_level_0_len 1
-#define	dagc1_desired_level_0_lsb 0
-#define xd_p_dagc1_desired_level_8_1	0xA124
-#define	dagc1_desired_level_8_1_pos 0
-#define	dagc1_desired_level_8_1_len 8
-#define	dagc1_desired_level_8_1_lsb 1
-#define xd_p_dagc1_apply_delay	0xA125
-#define	dagc1_apply_delay_pos 0
-#define	dagc1_apply_delay_len 7
-#define	dagc1_apply_delay_lsb 0
-#define xd_p_dagc1_bypass_scale_ctl	0xA126
-#define	dagc1_bypass_scale_ctl_pos 0
-#define	dagc1_bypass_scale_ctl_len 2
-#define	dagc1_bypass_scale_ctl_lsb 0
-#define xd_p_reg_dagc1_in_sat_cnt_7_0	0xA127
-#define	reg_dagc1_in_sat_cnt_7_0_pos 0
-#define	reg_dagc1_in_sat_cnt_7_0_len 8
-#define	reg_dagc1_in_sat_cnt_7_0_lsb 0
-#define xd_p_reg_dagc1_in_sat_cnt_15_8	0xA128
-#define	reg_dagc1_in_sat_cnt_15_8_pos 0
-#define	reg_dagc1_in_sat_cnt_15_8_len 8
-#define	reg_dagc1_in_sat_cnt_15_8_lsb 8
-#define xd_p_reg_dagc1_in_sat_cnt_23_16	0xA129
-#define	reg_dagc1_in_sat_cnt_23_16_pos 0
-#define	reg_dagc1_in_sat_cnt_23_16_len 8
-#define	reg_dagc1_in_sat_cnt_23_16_lsb 16
-#define xd_p_reg_dagc1_in_sat_cnt_31_24	0xA12A
-#define	reg_dagc1_in_sat_cnt_31_24_pos 0
-#define	reg_dagc1_in_sat_cnt_31_24_len 8
-#define	reg_dagc1_in_sat_cnt_31_24_lsb 24
-#define xd_p_reg_dagc1_out_sat_cnt_7_0	0xA12B
-#define	reg_dagc1_out_sat_cnt_7_0_pos 0
-#define	reg_dagc1_out_sat_cnt_7_0_len 8
-#define	reg_dagc1_out_sat_cnt_7_0_lsb 0
-#define xd_p_reg_dagc1_out_sat_cnt_15_8	0xA12C
-#define	reg_dagc1_out_sat_cnt_15_8_pos 0
-#define	reg_dagc1_out_sat_cnt_15_8_len 8
-#define	reg_dagc1_out_sat_cnt_15_8_lsb 8
-#define xd_p_reg_dagc1_out_sat_cnt_23_16	0xA12D
-#define	reg_dagc1_out_sat_cnt_23_16_pos 0
-#define	reg_dagc1_out_sat_cnt_23_16_len 8
-#define	reg_dagc1_out_sat_cnt_23_16_lsb 16
-#define xd_p_reg_dagc1_out_sat_cnt_31_24	0xA12E
-#define	reg_dagc1_out_sat_cnt_31_24_pos 0
-#define	reg_dagc1_out_sat_cnt_31_24_len 8
-#define	reg_dagc1_out_sat_cnt_31_24_lsb 24
-#define xd_r_dagc1_multiplier_7_0	0xA136
-#define	dagc1_multiplier_7_0_pos 0
-#define	dagc1_multiplier_7_0_len 8
-#define	dagc1_multiplier_7_0_lsb 0
-#define xd_r_dagc1_multiplier_15_8	0xA137
-#define	dagc1_multiplier_15_8_pos 0
-#define	dagc1_multiplier_15_8_len 8
-#define	dagc1_multiplier_15_8_lsb 8
-#define xd_r_dagc1_right_shift_bits	0xA138
-#define	dagc1_right_shift_bits_pos 0
-#define	dagc1_right_shift_bits_len 4
-#define	dagc1_right_shift_bits_lsb 0
-#define xd_p_reg_bfs_fcw_7_0	0xA140
-#define	reg_bfs_fcw_7_0_pos 0
-#define	reg_bfs_fcw_7_0_len 8
-#define	reg_bfs_fcw_7_0_lsb 0
-#define xd_p_reg_bfs_fcw_15_8	0xA141
-#define	reg_bfs_fcw_15_8_pos 0
-#define	reg_bfs_fcw_15_8_len 8
-#define	reg_bfs_fcw_15_8_lsb 8
-#define xd_p_reg_bfs_fcw_22_16	0xA142
-#define	reg_bfs_fcw_22_16_pos 0
-#define	reg_bfs_fcw_22_16_len 7
-#define	reg_bfs_fcw_22_16_lsb 16
-#define xd_p_reg_antif_sf_7_0	0xA144
-#define	reg_antif_sf_7_0_pos 0
-#define	reg_antif_sf_7_0_len 8
-#define	reg_antif_sf_7_0_lsb 0
-#define xd_p_reg_antif_sf_11_8	0xA145
-#define	reg_antif_sf_11_8_pos 0
-#define	reg_antif_sf_11_8_len 4
-#define	reg_antif_sf_11_8_lsb 8
-#define xd_r_bfs_fcw_q_7_0	0xA150
-#define	bfs_fcw_q_7_0_pos 0
-#define	bfs_fcw_q_7_0_len 8
-#define	bfs_fcw_q_7_0_lsb 0
-#define xd_r_bfs_fcw_q_15_8	0xA151
-#define	bfs_fcw_q_15_8_pos 0
-#define	bfs_fcw_q_15_8_len 8
-#define	bfs_fcw_q_15_8_lsb 8
-#define xd_r_bfs_fcw_q_22_16	0xA152
-#define	bfs_fcw_q_22_16_pos 0
-#define	bfs_fcw_q_22_16_len 7
-#define	bfs_fcw_q_22_16_lsb 16
-#define xd_p_reg_dca_enu	0xA160
-#define	reg_dca_enu_pos 0
-#define	reg_dca_enu_len 1
-#define	reg_dca_enu_lsb 0
-#define xd_p_reg_dca_enl	0xA160
-#define	reg_dca_enl_pos 1
-#define	reg_dca_enl_len 1
-#define	reg_dca_enl_lsb 0
-#define xd_p_reg_dca_lower_chip	0xA160
-#define	reg_dca_lower_chip_pos 2
-#define	reg_dca_lower_chip_len 1
-#define	reg_dca_lower_chip_lsb 0
-#define xd_p_reg_dca_upper_chip	0xA160
-#define	reg_dca_upper_chip_pos 3
-#define	reg_dca_upper_chip_len 1
-#define	reg_dca_upper_chip_lsb 0
-#define xd_p_reg_dca_platch	0xA160
-#define	reg_dca_platch_pos 4
-#define	reg_dca_platch_len 1
-#define	reg_dca_platch_lsb 0
-#define xd_p_reg_dca_th	0xA161
-#define	reg_dca_th_pos 0
-#define	reg_dca_th_len 5
-#define	reg_dca_th_lsb 0
-#define xd_p_reg_dca_scale	0xA162
-#define	reg_dca_scale_pos 0
-#define	reg_dca_scale_len 4
-#define	reg_dca_scale_lsb 0
-#define xd_p_reg_dca_tone_7_0	0xA163
-#define	reg_dca_tone_7_0_pos 0
-#define	reg_dca_tone_7_0_len 8
-#define	reg_dca_tone_7_0_lsb 0
-#define xd_p_reg_dca_tone_12_8	0xA164
-#define	reg_dca_tone_12_8_pos 0
-#define	reg_dca_tone_12_8_len 5
-#define	reg_dca_tone_12_8_lsb 8
-#define xd_p_reg_dca_time_7_0	0xA165
-#define	reg_dca_time_7_0_pos 0
-#define	reg_dca_time_7_0_len 8
-#define	reg_dca_time_7_0_lsb 0
-#define xd_p_reg_dca_time_15_8	0xA166
-#define	reg_dca_time_15_8_pos 0
-#define	reg_dca_time_15_8_len 8
-#define	reg_dca_time_15_8_lsb 8
-#define xd_r_dcasm	0xA167
-#define	dcasm_pos 0
-#define	dcasm_len 3
-#define	dcasm_lsb 0
-#define xd_p_reg_qnt_valuew_7_0	0xA168
-#define	reg_qnt_valuew_7_0_pos 0
-#define	reg_qnt_valuew_7_0_len 8
-#define	reg_qnt_valuew_7_0_lsb 0
-#define xd_p_reg_qnt_valuew_10_8	0xA169
-#define	reg_qnt_valuew_10_8_pos 0
-#define	reg_qnt_valuew_10_8_len 3
-#define	reg_qnt_valuew_10_8_lsb 8
-#define xd_p_dca_sbx_gain_diff_7_0	0xA16A
-#define	dca_sbx_gain_diff_7_0_pos 0
-#define	dca_sbx_gain_diff_7_0_len 8
-#define	dca_sbx_gain_diff_7_0_lsb 0
-#define xd_p_dca_sbx_gain_diff_9_8	0xA16B
-#define	dca_sbx_gain_diff_9_8_pos 0
-#define	dca_sbx_gain_diff_9_8_len 2
-#define	dca_sbx_gain_diff_9_8_lsb 8
-#define xd_p_reg_dca_stand_alone	0xA16C
-#define	reg_dca_stand_alone_pos 0
-#define	reg_dca_stand_alone_len 1
-#define	reg_dca_stand_alone_lsb 0
-#define xd_p_reg_dca_upper_out_en	0xA16C
-#define	reg_dca_upper_out_en_pos 1
-#define	reg_dca_upper_out_en_len 1
-#define	reg_dca_upper_out_en_lsb 0
-#define xd_p_reg_dca_rc_en	0xA16C
-#define	reg_dca_rc_en_pos 2
-#define	reg_dca_rc_en_len 1
-#define	reg_dca_rc_en_lsb 0
-#define xd_p_reg_dca_retrain_send	0xA16C
-#define	reg_dca_retrain_send_pos 3
-#define	reg_dca_retrain_send_len 1
-#define	reg_dca_retrain_send_lsb 0
-#define xd_p_reg_dca_retrain_rec	0xA16C
-#define	reg_dca_retrain_rec_pos 4
-#define	reg_dca_retrain_rec_len 1
-#define	reg_dca_retrain_rec_lsb 0
-#define xd_p_reg_dca_api_tpsrdy	0xA16C
-#define	reg_dca_api_tpsrdy_pos 5
-#define	reg_dca_api_tpsrdy_len 1
-#define	reg_dca_api_tpsrdy_lsb 0
-#define xd_p_reg_dca_symbol_gap	0xA16D
-#define	reg_dca_symbol_gap_pos 0
-#define	reg_dca_symbol_gap_len 4
-#define	reg_dca_symbol_gap_lsb 0
-#define xd_p_reg_qnt_nfvaluew_7_0	0xA16E
-#define	reg_qnt_nfvaluew_7_0_pos 0
-#define	reg_qnt_nfvaluew_7_0_len 8
-#define	reg_qnt_nfvaluew_7_0_lsb 0
-#define xd_p_reg_qnt_nfvaluew_10_8	0xA16F
-#define	reg_qnt_nfvaluew_10_8_pos 0
-#define	reg_qnt_nfvaluew_10_8_len 3
-#define	reg_qnt_nfvaluew_10_8_lsb 8
-#define xd_p_reg_qnt_flatness_thr_7_0	0xA170
-#define	reg_qnt_flatness_thr_7_0_pos 0
-#define	reg_qnt_flatness_thr_7_0_len 8
-#define	reg_qnt_flatness_thr_7_0_lsb 0
-#define xd_p_reg_qnt_flatness_thr_9_8	0xA171
-#define	reg_qnt_flatness_thr_9_8_pos 0
-#define	reg_qnt_flatness_thr_9_8_len 2
-#define	reg_qnt_flatness_thr_9_8_lsb 8
-#define xd_p_reg_dca_tone_idx_5_0	0xA171
-#define	reg_dca_tone_idx_5_0_pos 2
-#define	reg_dca_tone_idx_5_0_len 6
-#define	reg_dca_tone_idx_5_0_lsb 0
-#define xd_p_reg_dca_tone_idx_12_6	0xA172
-#define	reg_dca_tone_idx_12_6_pos 0
-#define	reg_dca_tone_idx_12_6_len 7
-#define	reg_dca_tone_idx_12_6_lsb 6
-#define xd_p_reg_dca_data_vld	0xA173
-#define	reg_dca_data_vld_pos 0
-#define	reg_dca_data_vld_len 1
-#define	reg_dca_data_vld_lsb 0
-#define xd_p_reg_dca_read_update	0xA173
-#define	reg_dca_read_update_pos 1
-#define	reg_dca_read_update_len 1
-#define	reg_dca_read_update_lsb 0
-#define xd_r_reg_dca_data_re_5_0	0xA173
-#define	reg_dca_data_re_5_0_pos 2
-#define	reg_dca_data_re_5_0_len 6
-#define	reg_dca_data_re_5_0_lsb 0
-#define xd_r_reg_dca_data_re_10_6	0xA174
-#define	reg_dca_data_re_10_6_pos 0
-#define	reg_dca_data_re_10_6_len 5
-#define	reg_dca_data_re_10_6_lsb 6
-#define xd_r_reg_dca_data_im_7_0	0xA175
-#define	reg_dca_data_im_7_0_pos 0
-#define	reg_dca_data_im_7_0_len 8
-#define	reg_dca_data_im_7_0_lsb 0
-#define xd_r_reg_dca_data_im_10_8	0xA176
-#define	reg_dca_data_im_10_8_pos 0
-#define	reg_dca_data_im_10_8_len 3
-#define	reg_dca_data_im_10_8_lsb 8
-#define xd_r_reg_dca_data_h2_7_0	0xA178
-#define	reg_dca_data_h2_7_0_pos 0
-#define	reg_dca_data_h2_7_0_len 8
-#define	reg_dca_data_h2_7_0_lsb 0
-#define xd_r_reg_dca_data_h2_9_8	0xA179
-#define	reg_dca_data_h2_9_8_pos 0
-#define	reg_dca_data_h2_9_8_len 2
-#define	reg_dca_data_h2_9_8_lsb 8
-#define xd_p_reg_f_adc_7_0	0xA180
-#define	reg_f_adc_7_0_pos 0
-#define	reg_f_adc_7_0_len 8
-#define	reg_f_adc_7_0_lsb 0
-#define xd_p_reg_f_adc_15_8	0xA181
-#define	reg_f_adc_15_8_pos 0
-#define	reg_f_adc_15_8_len 8
-#define	reg_f_adc_15_8_lsb 8
-#define xd_p_reg_f_adc_23_16	0xA182
-#define	reg_f_adc_23_16_pos 0
-#define	reg_f_adc_23_16_len 8
-#define	reg_f_adc_23_16_lsb 16
-#define xd_r_intp_mu_7_0	0xA190
-#define	intp_mu_7_0_pos 0
-#define	intp_mu_7_0_len 8
-#define	intp_mu_7_0_lsb 0
-#define xd_r_intp_mu_15_8	0xA191
-#define	intp_mu_15_8_pos 0
-#define	intp_mu_15_8_len 8
-#define	intp_mu_15_8_lsb 8
-#define xd_r_intp_mu_19_16	0xA192
-#define	intp_mu_19_16_pos 0
-#define	intp_mu_19_16_len 4
-#define	intp_mu_19_16_lsb 16
-#define xd_p_reg_agc_rst	0xA1A0
-#define	reg_agc_rst_pos 0
-#define	reg_agc_rst_len 1
-#define	reg_agc_rst_lsb 0
-#define xd_p_rf_agc_en	0xA1A0
-#define	rf_agc_en_pos 1
-#define	rf_agc_en_len 1
-#define	rf_agc_en_lsb 0
-#define xd_p_rf_agc_dis	0xA1A0
-#define	rf_agc_dis_pos 2
-#define	rf_agc_dis_len 1
-#define	rf_agc_dis_lsb 0
-#define xd_p_if_agc_rst	0xA1A0
-#define	if_agc_rst_pos 3
-#define	if_agc_rst_len 1
-#define	if_agc_rst_lsb 0
-#define xd_p_if_agc_en	0xA1A0
-#define	if_agc_en_pos 4
-#define	if_agc_en_len 1
-#define	if_agc_en_lsb 0
-#define xd_p_if_agc_dis	0xA1A0
-#define	if_agc_dis_pos 5
-#define	if_agc_dis_len 1
-#define	if_agc_dis_lsb 0
-#define xd_p_agc_lock	0xA1A0
-#define	agc_lock_pos 6
-#define	agc_lock_len 1
-#define	agc_lock_lsb 0
-#define xd_p_reg_tinr_rst	0xA1A1
-#define	reg_tinr_rst_pos 0
-#define	reg_tinr_rst_len 1
-#define	reg_tinr_rst_lsb 0
-#define xd_p_reg_tinr_en	0xA1A1
-#define	reg_tinr_en_pos 1
-#define	reg_tinr_en_len 1
-#define	reg_tinr_en_lsb 0
-#define xd_p_reg_ccifs_en	0xA1A2
-#define	reg_ccifs_en_pos 0
-#define	reg_ccifs_en_len 1
-#define	reg_ccifs_en_lsb 0
-#define xd_p_reg_ccifs_dis	0xA1A2
-#define	reg_ccifs_dis_pos 1
-#define	reg_ccifs_dis_len 1
-#define	reg_ccifs_dis_lsb 0
-#define xd_p_reg_ccifs_rst	0xA1A2
-#define	reg_ccifs_rst_pos 2
-#define	reg_ccifs_rst_len 1
-#define	reg_ccifs_rst_lsb 0
-#define xd_p_reg_ccifs_byp	0xA1A2
-#define	reg_ccifs_byp_pos 3
-#define	reg_ccifs_byp_len 1
-#define	reg_ccifs_byp_lsb 0
-#define xd_p_reg_ccif_en	0xA1A3
-#define	reg_ccif_en_pos 0
-#define	reg_ccif_en_len 1
-#define	reg_ccif_en_lsb 0
-#define xd_p_reg_ccif_dis	0xA1A3
-#define	reg_ccif_dis_pos 1
-#define	reg_ccif_dis_len 1
-#define	reg_ccif_dis_lsb 0
-#define xd_p_reg_ccif_rst	0xA1A3
-#define	reg_ccif_rst_pos 2
-#define	reg_ccif_rst_len 1
-#define	reg_ccif_rst_lsb 0
-#define xd_p_reg_ccif_byp	0xA1A3
-#define	reg_ccif_byp_pos 3
-#define	reg_ccif_byp_len 1
-#define	reg_ccif_byp_lsb 0
-#define xd_p_dagc1_rst	0xA1A4
-#define	dagc1_rst_pos 0
-#define	dagc1_rst_len 1
-#define	dagc1_rst_lsb 0
-#define xd_p_dagc1_en	0xA1A4
-#define	dagc1_en_pos 1
-#define	dagc1_en_len 1
-#define	dagc1_en_lsb 0
-#define xd_p_dagc1_mode	0xA1A4
-#define	dagc1_mode_pos 2
-#define	dagc1_mode_len 2
-#define	dagc1_mode_lsb 0
-#define xd_p_dagc1_done	0xA1A4
-#define	dagc1_done_pos 4
-#define	dagc1_done_len 1
-#define	dagc1_done_lsb 0
-#define xd_p_ccid_rst	0xA1A5
-#define	ccid_rst_pos 0
-#define	ccid_rst_len 1
-#define	ccid_rst_lsb 0
-#define xd_p_ccid_en	0xA1A5
-#define	ccid_en_pos 1
-#define	ccid_en_len 1
-#define	ccid_en_lsb 0
-#define xd_p_ccid_mode	0xA1A5
-#define	ccid_mode_pos 2
-#define	ccid_mode_len 2
-#define	ccid_mode_lsb 0
-#define xd_p_ccid_done	0xA1A5
-#define	ccid_done_pos 4
-#define	ccid_done_len 1
-#define	ccid_done_lsb 0
-#define xd_r_ccid_deted	0xA1A5
-#define	ccid_deted_pos 5
-#define	ccid_deted_len 1
-#define	ccid_deted_lsb 0
-#define xd_p_ccid2_en	0xA1A5
-#define	ccid2_en_pos 6
-#define	ccid2_en_len 1
-#define	ccid2_en_lsb 0
-#define xd_p_ccid2_done	0xA1A5
-#define	ccid2_done_pos 7
-#define	ccid2_done_len 1
-#define	ccid2_done_lsb 0
-#define xd_p_reg_bfs_en	0xA1A6
-#define	reg_bfs_en_pos 0
-#define	reg_bfs_en_len 1
-#define	reg_bfs_en_lsb 0
-#define xd_p_reg_bfs_dis	0xA1A6
-#define	reg_bfs_dis_pos 1
-#define	reg_bfs_dis_len 1
-#define	reg_bfs_dis_lsb 0
-#define xd_p_reg_bfs_rst	0xA1A6
-#define	reg_bfs_rst_pos 2
-#define	reg_bfs_rst_len 1
-#define	reg_bfs_rst_lsb 0
-#define xd_p_reg_bfs_byp	0xA1A6
-#define	reg_bfs_byp_pos 3
-#define	reg_bfs_byp_len 1
-#define	reg_bfs_byp_lsb 0
-#define xd_p_reg_antif_en	0xA1A7
-#define	reg_antif_en_pos 0
-#define	reg_antif_en_len 1
-#define	reg_antif_en_lsb 0
-#define xd_p_reg_antif_dis	0xA1A7
-#define	reg_antif_dis_pos 1
-#define	reg_antif_dis_len 1
-#define	reg_antif_dis_lsb 0
-#define xd_p_reg_antif_rst	0xA1A7
-#define	reg_antif_rst_pos 2
-#define	reg_antif_rst_len 1
-#define	reg_antif_rst_lsb 0
-#define xd_p_reg_antif_byp	0xA1A7
-#define	reg_antif_byp_pos 3
-#define	reg_antif_byp_len 1
-#define	reg_antif_byp_lsb 0
-#define xd_p_intp_en	0xA1A8
-#define	intp_en_pos 0
-#define	intp_en_len 1
-#define	intp_en_lsb 0
-#define xd_p_intp_dis	0xA1A8
-#define	intp_dis_pos 1
-#define	intp_dis_len 1
-#define	intp_dis_lsb 0
-#define xd_p_intp_rst	0xA1A8
-#define	intp_rst_pos 2
-#define	intp_rst_len 1
-#define	intp_rst_lsb 0
-#define xd_p_intp_byp	0xA1A8
-#define	intp_byp_pos 3
-#define	intp_byp_len 1
-#define	intp_byp_lsb 0
-#define xd_p_reg_acif_en	0xA1A9
-#define	reg_acif_en_pos 0
-#define	reg_acif_en_len 1
-#define	reg_acif_en_lsb 0
-#define xd_p_reg_acif_dis	0xA1A9
-#define	reg_acif_dis_pos 1
-#define	reg_acif_dis_len 1
-#define	reg_acif_dis_lsb 0
-#define xd_p_reg_acif_rst	0xA1A9
-#define	reg_acif_rst_pos 2
-#define	reg_acif_rst_len 1
-#define	reg_acif_rst_lsb 0
-#define xd_p_reg_acif_byp	0xA1A9
-#define	reg_acif_byp_pos 3
-#define	reg_acif_byp_len 1
-#define	reg_acif_byp_lsb 0
-#define xd_p_reg_acif_sync_mode	0xA1A9
-#define	reg_acif_sync_mode_pos 4
-#define	reg_acif_sync_mode_len 1
-#define	reg_acif_sync_mode_lsb 0
-#define xd_p_dagc2_rst	0xA1AA
-#define	dagc2_rst_pos 0
-#define	dagc2_rst_len 1
-#define	dagc2_rst_lsb 0
-#define xd_p_dagc2_en	0xA1AA
-#define	dagc2_en_pos 1
-#define	dagc2_en_len 1
-#define	dagc2_en_lsb 0
-#define xd_p_dagc2_mode	0xA1AA
-#define	dagc2_mode_pos 2
-#define	dagc2_mode_len 2
-#define	dagc2_mode_lsb 0
-#define xd_p_dagc2_done	0xA1AA
-#define	dagc2_done_pos 4
-#define	dagc2_done_len 1
-#define	dagc2_done_lsb 0
-#define xd_p_reg_dca_en	0xA1AB
-#define	reg_dca_en_pos 0
-#define	reg_dca_en_len 1
-#define	reg_dca_en_lsb 0
-#define xd_p_dagc2_accumulate_num_2k_7_0	0xA1C0
-#define	dagc2_accumulate_num_2k_7_0_pos 0
-#define	dagc2_accumulate_num_2k_7_0_len 8
-#define	dagc2_accumulate_num_2k_7_0_lsb 0
-#define xd_p_dagc2_accumulate_num_2k_12_8	0xA1C1
-#define	dagc2_accumulate_num_2k_12_8_pos 0
-#define	dagc2_accumulate_num_2k_12_8_len 5
-#define	dagc2_accumulate_num_2k_12_8_lsb 8
-#define xd_p_dagc2_accumulate_num_8k_7_0	0xA1C2
-#define	dagc2_accumulate_num_8k_7_0_pos 0
-#define	dagc2_accumulate_num_8k_7_0_len 8
-#define	dagc2_accumulate_num_8k_7_0_lsb 0
-#define xd_p_dagc2_accumulate_num_8k_12_8	0xA1C3
-#define	dagc2_accumulate_num_8k_12_8_pos 0
-#define	dagc2_accumulate_num_8k_12_8_len 5
-#define	dagc2_accumulate_num_8k_12_8_lsb 8
-#define xd_p_dagc2_desired_level_2_0	0xA1C3
-#define	dagc2_desired_level_2_0_pos 5
-#define	dagc2_desired_level_2_0_len 3
-#define	dagc2_desired_level_2_0_lsb 0
-#define xd_p_dagc2_desired_level_8_3	0xA1C4
-#define	dagc2_desired_level_8_3_pos 0
-#define	dagc2_desired_level_8_3_len 6
-#define	dagc2_desired_level_8_3_lsb 3
-#define xd_p_dagc2_apply_delay	0xA1C5
-#define	dagc2_apply_delay_pos 0
-#define	dagc2_apply_delay_len 7
-#define	dagc2_apply_delay_lsb 0
-#define xd_p_dagc2_bypass_scale_ctl	0xA1C6
-#define	dagc2_bypass_scale_ctl_pos 0
-#define	dagc2_bypass_scale_ctl_len 3
-#define	dagc2_bypass_scale_ctl_lsb 0
-#define xd_p_dagc2_programmable_shift1	0xA1C7
-#define	dagc2_programmable_shift1_pos 0
-#define	dagc2_programmable_shift1_len 8
-#define	dagc2_programmable_shift1_lsb 0
-#define xd_p_dagc2_programmable_shift2	0xA1C8
-#define	dagc2_programmable_shift2_pos 0
-#define	dagc2_programmable_shift2_len 8
-#define	dagc2_programmable_shift2_lsb 0
-#define xd_p_reg_dagc2_in_sat_cnt_7_0	0xA1C9
-#define	reg_dagc2_in_sat_cnt_7_0_pos 0
-#define	reg_dagc2_in_sat_cnt_7_0_len 8
-#define	reg_dagc2_in_sat_cnt_7_0_lsb 0
-#define xd_p_reg_dagc2_in_sat_cnt_15_8	0xA1CA
-#define	reg_dagc2_in_sat_cnt_15_8_pos 0
-#define	reg_dagc2_in_sat_cnt_15_8_len 8
-#define	reg_dagc2_in_sat_cnt_15_8_lsb 8
-#define xd_p_reg_dagc2_in_sat_cnt_23_16	0xA1CB
-#define	reg_dagc2_in_sat_cnt_23_16_pos 0
-#define	reg_dagc2_in_sat_cnt_23_16_len 8
-#define	reg_dagc2_in_sat_cnt_23_16_lsb 16
-#define xd_p_reg_dagc2_in_sat_cnt_31_24	0xA1CC
-#define	reg_dagc2_in_sat_cnt_31_24_pos 0
-#define	reg_dagc2_in_sat_cnt_31_24_len 8
-#define	reg_dagc2_in_sat_cnt_31_24_lsb 24
-#define xd_p_reg_dagc2_out_sat_cnt_7_0	0xA1CD
-#define	reg_dagc2_out_sat_cnt_7_0_pos 0
-#define	reg_dagc2_out_sat_cnt_7_0_len 8
-#define	reg_dagc2_out_sat_cnt_7_0_lsb 0
-#define xd_p_reg_dagc2_out_sat_cnt_15_8	0xA1CE
-#define	reg_dagc2_out_sat_cnt_15_8_pos 0
-#define	reg_dagc2_out_sat_cnt_15_8_len 8
-#define	reg_dagc2_out_sat_cnt_15_8_lsb 8
-#define xd_p_reg_dagc2_out_sat_cnt_23_16	0xA1CF
-#define	reg_dagc2_out_sat_cnt_23_16_pos 0
-#define	reg_dagc2_out_sat_cnt_23_16_len 8
-#define	reg_dagc2_out_sat_cnt_23_16_lsb 16
-#define xd_p_reg_dagc2_out_sat_cnt_31_24	0xA1D0
-#define	reg_dagc2_out_sat_cnt_31_24_pos 0
-#define	reg_dagc2_out_sat_cnt_31_24_len 8
-#define	reg_dagc2_out_sat_cnt_31_24_lsb 24
-#define xd_r_dagc2_multiplier_7_0	0xA1D6
-#define	dagc2_multiplier_7_0_pos 0
-#define	dagc2_multiplier_7_0_len 8
-#define	dagc2_multiplier_7_0_lsb 0
-#define xd_r_dagc2_multiplier_15_8	0xA1D7
-#define	dagc2_multiplier_15_8_pos 0
-#define	dagc2_multiplier_15_8_len 8
-#define	dagc2_multiplier_15_8_lsb 8
-#define xd_r_dagc2_right_shift_bits	0xA1D8
-#define	dagc2_right_shift_bits_pos 0
-#define	dagc2_right_shift_bits_len 4
-#define	dagc2_right_shift_bits_lsb 0
-#define xd_p_cfoe_NS_coeff1_7_0	0xA200
-#define	cfoe_NS_coeff1_7_0_pos 0
-#define	cfoe_NS_coeff1_7_0_len 8
-#define	cfoe_NS_coeff1_7_0_lsb 0
-#define xd_p_cfoe_NS_coeff1_15_8	0xA201
-#define	cfoe_NS_coeff1_15_8_pos 0
-#define	cfoe_NS_coeff1_15_8_len 8
-#define	cfoe_NS_coeff1_15_8_lsb 8
-#define xd_p_cfoe_NS_coeff1_23_16	0xA202
-#define	cfoe_NS_coeff1_23_16_pos 0
-#define	cfoe_NS_coeff1_23_16_len 8
-#define	cfoe_NS_coeff1_23_16_lsb 16
-#define xd_p_cfoe_NS_coeff1_25_24	0xA203
-#define	cfoe_NS_coeff1_25_24_pos 0
-#define	cfoe_NS_coeff1_25_24_len 2
-#define	cfoe_NS_coeff1_25_24_lsb 24
-#define xd_p_cfoe_NS_coeff2_5_0	0xA203
-#define	cfoe_NS_coeff2_5_0_pos 2
-#define	cfoe_NS_coeff2_5_0_len 6
-#define	cfoe_NS_coeff2_5_0_lsb 0
-#define xd_p_cfoe_NS_coeff2_13_6	0xA204
-#define	cfoe_NS_coeff2_13_6_pos 0
-#define	cfoe_NS_coeff2_13_6_len 8
-#define	cfoe_NS_coeff2_13_6_lsb 6
-#define xd_p_cfoe_NS_coeff2_21_14	0xA205
-#define	cfoe_NS_coeff2_21_14_pos 0
-#define	cfoe_NS_coeff2_21_14_len 8
-#define	cfoe_NS_coeff2_21_14_lsb 14
-#define xd_p_cfoe_NS_coeff2_24_22	0xA206
-#define	cfoe_NS_coeff2_24_22_pos 0
-#define	cfoe_NS_coeff2_24_22_len 3
-#define	cfoe_NS_coeff2_24_22_lsb 22
-#define xd_p_cfoe_lf_c1_4_0	0xA206
-#define	cfoe_lf_c1_4_0_pos 3
-#define	cfoe_lf_c1_4_0_len 5
-#define	cfoe_lf_c1_4_0_lsb 0
-#define xd_p_cfoe_lf_c1_12_5	0xA207
-#define	cfoe_lf_c1_12_5_pos 0
-#define	cfoe_lf_c1_12_5_len 8
-#define	cfoe_lf_c1_12_5_lsb 5
-#define xd_p_cfoe_lf_c1_20_13	0xA208
-#define	cfoe_lf_c1_20_13_pos 0
-#define	cfoe_lf_c1_20_13_len 8
-#define	cfoe_lf_c1_20_13_lsb 13
-#define xd_p_cfoe_lf_c1_25_21	0xA209
-#define	cfoe_lf_c1_25_21_pos 0
-#define	cfoe_lf_c1_25_21_len 5
-#define	cfoe_lf_c1_25_21_lsb 21
-#define xd_p_cfoe_lf_c2_2_0	0xA209
-#define	cfoe_lf_c2_2_0_pos 5
-#define	cfoe_lf_c2_2_0_len 3
-#define	cfoe_lf_c2_2_0_lsb 0
-#define xd_p_cfoe_lf_c2_10_3	0xA20A
-#define	cfoe_lf_c2_10_3_pos 0
-#define	cfoe_lf_c2_10_3_len 8
-#define	cfoe_lf_c2_10_3_lsb 3
-#define xd_p_cfoe_lf_c2_18_11	0xA20B
-#define	cfoe_lf_c2_18_11_pos 0
-#define	cfoe_lf_c2_18_11_len 8
-#define	cfoe_lf_c2_18_11_lsb 11
-#define xd_p_cfoe_lf_c2_25_19	0xA20C
-#define	cfoe_lf_c2_25_19_pos 0
-#define	cfoe_lf_c2_25_19_len 7
-#define	cfoe_lf_c2_25_19_lsb 19
-#define xd_p_cfoe_ifod_7_0	0xA20D
-#define	cfoe_ifod_7_0_pos 0
-#define	cfoe_ifod_7_0_len 8
-#define	cfoe_ifod_7_0_lsb 0
-#define xd_p_cfoe_ifod_10_8	0xA20E
-#define	cfoe_ifod_10_8_pos 0
-#define	cfoe_ifod_10_8_len 3
-#define	cfoe_ifod_10_8_lsb 8
-#define xd_p_cfoe_Divg_ctr_th	0xA20E
-#define	cfoe_Divg_ctr_th_pos 4
-#define	cfoe_Divg_ctr_th_len 4
-#define	cfoe_Divg_ctr_th_lsb 0
-#define xd_p_cfoe_FOT_divg_th	0xA20F
-#define	cfoe_FOT_divg_th_pos 0
-#define	cfoe_FOT_divg_th_len 8
-#define	cfoe_FOT_divg_th_lsb 0
-#define xd_p_cfoe_FOT_cnvg_th	0xA210
-#define	cfoe_FOT_cnvg_th_pos 0
-#define	cfoe_FOT_cnvg_th_len 8
-#define	cfoe_FOT_cnvg_th_lsb 0
-#define xd_p_reg_cfoe_offset_7_0	0xA211
-#define	reg_cfoe_offset_7_0_pos 0
-#define	reg_cfoe_offset_7_0_len 8
-#define	reg_cfoe_offset_7_0_lsb 0
-#define xd_p_reg_cfoe_offset_9_8	0xA212
-#define	reg_cfoe_offset_9_8_pos 0
-#define	reg_cfoe_offset_9_8_len 2
-#define	reg_cfoe_offset_9_8_lsb 8
-#define xd_p_reg_cfoe_ifoe_sign_corr	0xA212
-#define	reg_cfoe_ifoe_sign_corr_pos 2
-#define	reg_cfoe_ifoe_sign_corr_len 1
-#define	reg_cfoe_ifoe_sign_corr_lsb 0
-#define xd_r_cfoe_fot_LF_output_7_0	0xA218
-#define	cfoe_fot_LF_output_7_0_pos 0
-#define	cfoe_fot_LF_output_7_0_len 8
-#define	cfoe_fot_LF_output_7_0_lsb 0
-#define xd_r_cfoe_fot_LF_output_15_8	0xA219
-#define	cfoe_fot_LF_output_15_8_pos 0
-#define	cfoe_fot_LF_output_15_8_len 8
-#define	cfoe_fot_LF_output_15_8_lsb 8
-#define xd_r_cfoe_ifo_metric_7_0	0xA21A
-#define	cfoe_ifo_metric_7_0_pos 0
-#define	cfoe_ifo_metric_7_0_len 8
-#define	cfoe_ifo_metric_7_0_lsb 0
-#define xd_r_cfoe_ifo_metric_15_8	0xA21B
-#define	cfoe_ifo_metric_15_8_pos 0
-#define	cfoe_ifo_metric_15_8_len 8
-#define	cfoe_ifo_metric_15_8_lsb 8
-#define xd_r_cfoe_ifo_metric_23_16	0xA21C
-#define	cfoe_ifo_metric_23_16_pos 0
-#define	cfoe_ifo_metric_23_16_len 8
-#define	cfoe_ifo_metric_23_16_lsb 16
-#define xd_p_ste_Nu	0xA220
-#define	ste_Nu_pos 0
-#define	ste_Nu_len 2
-#define	ste_Nu_lsb 0
-#define xd_p_ste_GI	0xA220
-#define	ste_GI_pos 2
-#define	ste_GI_len 3
-#define	ste_GI_lsb 0
-#define xd_p_ste_symbol_num	0xA221
-#define	ste_symbol_num_pos 0
-#define	ste_symbol_num_len 2
-#define	ste_symbol_num_lsb 0
-#define xd_p_ste_sample_num	0xA221
-#define	ste_sample_num_pos 2
-#define	ste_sample_num_len 2
-#define	ste_sample_num_lsb 0
-#define xd_p_reg_ste_buf_en	0xA221
-#define	reg_ste_buf_en_pos 7
-#define	reg_ste_buf_en_len 1
-#define	reg_ste_buf_en_lsb 0
-#define xd_p_ste_FFT_offset_7_0	0xA222
-#define	ste_FFT_offset_7_0_pos 0
-#define	ste_FFT_offset_7_0_len 8
-#define	ste_FFT_offset_7_0_lsb 0
-#define xd_p_ste_FFT_offset_11_8	0xA223
-#define	ste_FFT_offset_11_8_pos 0
-#define	ste_FFT_offset_11_8_len 4
-#define	ste_FFT_offset_11_8_lsb 8
-#define xd_p_reg_ste_tstmod	0xA223
-#define	reg_ste_tstmod_pos 5
-#define	reg_ste_tstmod_len 1
-#define	reg_ste_tstmod_lsb 0
-#define xd_p_ste_adv_start_7_0	0xA224
-#define	ste_adv_start_7_0_pos 0
-#define	ste_adv_start_7_0_len 8
-#define	ste_adv_start_7_0_lsb 0
-#define xd_p_ste_adv_start_10_8	0xA225
-#define	ste_adv_start_10_8_pos 0
-#define	ste_adv_start_10_8_len 3
-#define	ste_adv_start_10_8_lsb 8
-#define xd_p_ste_adv_stop	0xA226
-#define	ste_adv_stop_pos 0
-#define	ste_adv_stop_len 8
-#define	ste_adv_stop_lsb 0
-#define xd_r_ste_P_value_7_0	0xA228
-#define	ste_P_value_7_0_pos 0
-#define	ste_P_value_7_0_len 8
-#define	ste_P_value_7_0_lsb 0
-#define xd_r_ste_P_value_10_8	0xA229
-#define	ste_P_value_10_8_pos 0
-#define	ste_P_value_10_8_len 3
-#define	ste_P_value_10_8_lsb 8
-#define xd_r_ste_M_value_7_0	0xA22A
-#define	ste_M_value_7_0_pos 0
-#define	ste_M_value_7_0_len 8
-#define	ste_M_value_7_0_lsb 0
-#define xd_r_ste_M_value_10_8	0xA22B
-#define	ste_M_value_10_8_pos 0
-#define	ste_M_value_10_8_len 3
-#define	ste_M_value_10_8_lsb 8
-#define xd_r_ste_H1	0xA22C
-#define	ste_H1_pos 0
-#define	ste_H1_len 7
-#define	ste_H1_lsb 0
-#define xd_r_ste_H2	0xA22D
-#define	ste_H2_pos 0
-#define	ste_H2_len 7
-#define	ste_H2_lsb 0
-#define xd_r_ste_H3	0xA22E
-#define	ste_H3_pos 0
-#define	ste_H3_len 7
-#define	ste_H3_lsb 0
-#define xd_r_ste_H4	0xA22F
-#define	ste_H4_pos 0
-#define	ste_H4_len 7
-#define	ste_H4_lsb 0
-#define xd_r_ste_Corr_value_I_7_0	0xA230
-#define	ste_Corr_value_I_7_0_pos 0
-#define	ste_Corr_value_I_7_0_len 8
-#define	ste_Corr_value_I_7_0_lsb 0
-#define xd_r_ste_Corr_value_I_15_8	0xA231
-#define	ste_Corr_value_I_15_8_pos 0
-#define	ste_Corr_value_I_15_8_len 8
-#define	ste_Corr_value_I_15_8_lsb 8
-#define xd_r_ste_Corr_value_I_23_16	0xA232
-#define	ste_Corr_value_I_23_16_pos 0
-#define	ste_Corr_value_I_23_16_len 8
-#define	ste_Corr_value_I_23_16_lsb 16
-#define xd_r_ste_Corr_value_I_27_24	0xA233
-#define	ste_Corr_value_I_27_24_pos 0
-#define	ste_Corr_value_I_27_24_len 4
-#define	ste_Corr_value_I_27_24_lsb 24
-#define xd_r_ste_Corr_value_Q_7_0	0xA234
-#define	ste_Corr_value_Q_7_0_pos 0
-#define	ste_Corr_value_Q_7_0_len 8
-#define	ste_Corr_value_Q_7_0_lsb 0
-#define xd_r_ste_Corr_value_Q_15_8	0xA235
-#define	ste_Corr_value_Q_15_8_pos 0
-#define	ste_Corr_value_Q_15_8_len 8
-#define	ste_Corr_value_Q_15_8_lsb 8
-#define xd_r_ste_Corr_value_Q_23_16	0xA236
-#define	ste_Corr_value_Q_23_16_pos 0
-#define	ste_Corr_value_Q_23_16_len 8
-#define	ste_Corr_value_Q_23_16_lsb 16
-#define xd_r_ste_Corr_value_Q_27_24	0xA237
-#define	ste_Corr_value_Q_27_24_pos 0
-#define	ste_Corr_value_Q_27_24_len 4
-#define	ste_Corr_value_Q_27_24_lsb 24
-#define xd_r_ste_J_num_7_0	0xA238
-#define	ste_J_num_7_0_pos 0
-#define	ste_J_num_7_0_len 8
-#define	ste_J_num_7_0_lsb 0
-#define xd_r_ste_J_num_15_8	0xA239
-#define	ste_J_num_15_8_pos 0
-#define	ste_J_num_15_8_len 8
-#define	ste_J_num_15_8_lsb 8
-#define xd_r_ste_J_num_23_16	0xA23A
-#define	ste_J_num_23_16_pos 0
-#define	ste_J_num_23_16_len 8
-#define	ste_J_num_23_16_lsb 16
-#define xd_r_ste_J_num_31_24	0xA23B
-#define	ste_J_num_31_24_pos 0
-#define	ste_J_num_31_24_len 8
-#define	ste_J_num_31_24_lsb 24
-#define xd_r_ste_J_den_7_0	0xA23C
-#define	ste_J_den_7_0_pos 0
-#define	ste_J_den_7_0_len 8
-#define	ste_J_den_7_0_lsb 0
-#define xd_r_ste_J_den_15_8	0xA23D
-#define	ste_J_den_15_8_pos 0
-#define	ste_J_den_15_8_len 8
-#define	ste_J_den_15_8_lsb 8
-#define xd_r_ste_J_den_18_16	0xA23E
-#define	ste_J_den_18_16_pos 0
-#define	ste_J_den_18_16_len 3
-#define	ste_J_den_18_16_lsb 16
-#define xd_r_ste_Beacon_Indicator	0xA23E
-#define	ste_Beacon_Indicator_pos 4
-#define	ste_Beacon_Indicator_len 1
-#define	ste_Beacon_Indicator_lsb 0
-#define xd_r_tpsd_Frame_Num	0xA250
-#define	tpsd_Frame_Num_pos 0
-#define	tpsd_Frame_Num_len 2
-#define	tpsd_Frame_Num_lsb 0
-#define xd_r_tpsd_Constel	0xA250
-#define	tpsd_Constel_pos 2
-#define	tpsd_Constel_len 2
-#define	tpsd_Constel_lsb 0
-#define xd_r_tpsd_GI	0xA250
-#define	tpsd_GI_pos 4
-#define	tpsd_GI_len 2
-#define	tpsd_GI_lsb 0
-#define xd_r_tpsd_Mode	0xA250
-#define	tpsd_Mode_pos 6
-#define	tpsd_Mode_len 2
-#define	tpsd_Mode_lsb 0
-#define xd_r_tpsd_CR_HP	0xA251
-#define	tpsd_CR_HP_pos 0
-#define	tpsd_CR_HP_len 3
-#define	tpsd_CR_HP_lsb 0
-#define xd_r_tpsd_CR_LP	0xA251
-#define	tpsd_CR_LP_pos 3
-#define	tpsd_CR_LP_len 3
-#define	tpsd_CR_LP_lsb 0
-#define xd_r_tpsd_Hie	0xA252
-#define	tpsd_Hie_pos 0
-#define	tpsd_Hie_len 3
-#define	tpsd_Hie_lsb 0
-#define xd_r_tpsd_Res_Bits	0xA252
-#define	tpsd_Res_Bits_pos 3
-#define	tpsd_Res_Bits_len 5
-#define	tpsd_Res_Bits_lsb 0
-#define xd_r_tpsd_Res_Bits_0	0xA253
-#define	tpsd_Res_Bits_0_pos 0
-#define	tpsd_Res_Bits_0_len 1
-#define	tpsd_Res_Bits_0_lsb 0
-#define xd_r_tpsd_LengthInd	0xA253
-#define	tpsd_LengthInd_pos 1
-#define	tpsd_LengthInd_len 6
-#define	tpsd_LengthInd_lsb 0
-#define xd_r_tpsd_Cell_Id_7_0	0xA254
-#define	tpsd_Cell_Id_7_0_pos 0
-#define	tpsd_Cell_Id_7_0_len 8
-#define	tpsd_Cell_Id_7_0_lsb 0
-#define xd_r_tpsd_Cell_Id_15_8	0xA255
-#define	tpsd_Cell_Id_15_8_pos 0
-#define	tpsd_Cell_Id_15_8_len 8
-#define	tpsd_Cell_Id_15_8_lsb 0
-#define xd_p_reg_fft_mask_tone0_7_0	0xA260
-#define	reg_fft_mask_tone0_7_0_pos 0
-#define	reg_fft_mask_tone0_7_0_len 8
-#define	reg_fft_mask_tone0_7_0_lsb 0
-#define xd_p_reg_fft_mask_tone0_12_8	0xA261
-#define	reg_fft_mask_tone0_12_8_pos 0
-#define	reg_fft_mask_tone0_12_8_len 5
-#define	reg_fft_mask_tone0_12_8_lsb 8
-#define xd_p_reg_fft_mask_tone1_7_0	0xA262
-#define	reg_fft_mask_tone1_7_0_pos 0
-#define	reg_fft_mask_tone1_7_0_len 8
-#define	reg_fft_mask_tone1_7_0_lsb 0
-#define xd_p_reg_fft_mask_tone1_12_8	0xA263
-#define	reg_fft_mask_tone1_12_8_pos 0
-#define	reg_fft_mask_tone1_12_8_len 5
-#define	reg_fft_mask_tone1_12_8_lsb 8
-#define xd_p_reg_fft_mask_tone2_7_0	0xA264
-#define	reg_fft_mask_tone2_7_0_pos 0
-#define	reg_fft_mask_tone2_7_0_len 8
-#define	reg_fft_mask_tone2_7_0_lsb 0
-#define xd_p_reg_fft_mask_tone2_12_8	0xA265
-#define	reg_fft_mask_tone2_12_8_pos 0
-#define	reg_fft_mask_tone2_12_8_len 5
-#define	reg_fft_mask_tone2_12_8_lsb 8
-#define xd_p_reg_fft_mask_tone3_7_0	0xA266
-#define	reg_fft_mask_tone3_7_0_pos 0
-#define	reg_fft_mask_tone3_7_0_len 8
-#define	reg_fft_mask_tone3_7_0_lsb 0
-#define xd_p_reg_fft_mask_tone3_12_8	0xA267
-#define	reg_fft_mask_tone3_12_8_pos 0
-#define	reg_fft_mask_tone3_12_8_len 5
-#define	reg_fft_mask_tone3_12_8_lsb 8
-#define xd_p_reg_fft_mask_from0_7_0	0xA268
-#define	reg_fft_mask_from0_7_0_pos 0
-#define	reg_fft_mask_from0_7_0_len 8
-#define	reg_fft_mask_from0_7_0_lsb 0
-#define xd_p_reg_fft_mask_from0_12_8	0xA269
-#define	reg_fft_mask_from0_12_8_pos 0
-#define	reg_fft_mask_from0_12_8_len 5
-#define	reg_fft_mask_from0_12_8_lsb 8
-#define xd_p_reg_fft_mask_to0_7_0	0xA26A
-#define	reg_fft_mask_to0_7_0_pos 0
-#define	reg_fft_mask_to0_7_0_len 8
-#define	reg_fft_mask_to0_7_0_lsb 0
-#define xd_p_reg_fft_mask_to0_12_8	0xA26B
-#define	reg_fft_mask_to0_12_8_pos 0
-#define	reg_fft_mask_to0_12_8_len 5
-#define	reg_fft_mask_to0_12_8_lsb 8
-#define xd_p_reg_fft_mask_from1_7_0	0xA26C
-#define	reg_fft_mask_from1_7_0_pos 0
-#define	reg_fft_mask_from1_7_0_len 8
-#define	reg_fft_mask_from1_7_0_lsb 0
-#define xd_p_reg_fft_mask_from1_12_8	0xA26D
-#define	reg_fft_mask_from1_12_8_pos 0
-#define	reg_fft_mask_from1_12_8_len 5
-#define	reg_fft_mask_from1_12_8_lsb 8
-#define xd_p_reg_fft_mask_to1_7_0	0xA26E
-#define	reg_fft_mask_to1_7_0_pos 0
-#define	reg_fft_mask_to1_7_0_len 8
-#define	reg_fft_mask_to1_7_0_lsb 0
-#define xd_p_reg_fft_mask_to1_12_8	0xA26F
-#define	reg_fft_mask_to1_12_8_pos 0
-#define	reg_fft_mask_to1_12_8_len 5
-#define	reg_fft_mask_to1_12_8_lsb 8
-#define xd_p_reg_cge_idx0_7_0	0xA280
-#define	reg_cge_idx0_7_0_pos 0
-#define	reg_cge_idx0_7_0_len 8
-#define	reg_cge_idx0_7_0_lsb 0
-#define xd_p_reg_cge_idx0_12_8	0xA281
-#define	reg_cge_idx0_12_8_pos 0
-#define	reg_cge_idx0_12_8_len 5
-#define	reg_cge_idx0_12_8_lsb 8
-#define xd_p_reg_cge_idx1_7_0	0xA282
-#define	reg_cge_idx1_7_0_pos 0
-#define	reg_cge_idx1_7_0_len 8
-#define	reg_cge_idx1_7_0_lsb 0
-#define xd_p_reg_cge_idx1_12_8	0xA283
-#define	reg_cge_idx1_12_8_pos 0
-#define	reg_cge_idx1_12_8_len 5
-#define	reg_cge_idx1_12_8_lsb 8
-#define xd_p_reg_cge_idx2_7_0	0xA284
-#define	reg_cge_idx2_7_0_pos 0
-#define	reg_cge_idx2_7_0_len 8
-#define	reg_cge_idx2_7_0_lsb 0
-#define xd_p_reg_cge_idx2_12_8	0xA285
-#define	reg_cge_idx2_12_8_pos 0
-#define	reg_cge_idx2_12_8_len 5
-#define	reg_cge_idx2_12_8_lsb 8
-#define xd_p_reg_cge_idx3_7_0	0xA286
-#define	reg_cge_idx3_7_0_pos 0
-#define	reg_cge_idx3_7_0_len 8
-#define	reg_cge_idx3_7_0_lsb 0
-#define xd_p_reg_cge_idx3_12_8	0xA287
-#define	reg_cge_idx3_12_8_pos 0
-#define	reg_cge_idx3_12_8_len 5
-#define	reg_cge_idx3_12_8_lsb 8
-#define xd_p_reg_cge_idx4_7_0	0xA288
-#define	reg_cge_idx4_7_0_pos 0
-#define	reg_cge_idx4_7_0_len 8
-#define	reg_cge_idx4_7_0_lsb 0
-#define xd_p_reg_cge_idx4_12_8	0xA289
-#define	reg_cge_idx4_12_8_pos 0
-#define	reg_cge_idx4_12_8_len 5
-#define	reg_cge_idx4_12_8_lsb 8
-#define xd_p_reg_cge_idx5_7_0	0xA28A
-#define	reg_cge_idx5_7_0_pos 0
-#define	reg_cge_idx5_7_0_len 8
-#define	reg_cge_idx5_7_0_lsb 0
-#define xd_p_reg_cge_idx5_12_8	0xA28B
-#define	reg_cge_idx5_12_8_pos 0
-#define	reg_cge_idx5_12_8_len 5
-#define	reg_cge_idx5_12_8_lsb 8
-#define xd_p_reg_cge_idx6_7_0	0xA28C
-#define	reg_cge_idx6_7_0_pos 0
-#define	reg_cge_idx6_7_0_len 8
-#define	reg_cge_idx6_7_0_lsb 0
-#define xd_p_reg_cge_idx6_12_8	0xA28D
-#define	reg_cge_idx6_12_8_pos 0
-#define	reg_cge_idx6_12_8_len 5
-#define	reg_cge_idx6_12_8_lsb 8
-#define xd_p_reg_cge_idx7_7_0	0xA28E
-#define	reg_cge_idx7_7_0_pos 0
-#define	reg_cge_idx7_7_0_len 8
-#define	reg_cge_idx7_7_0_lsb 0
-#define xd_p_reg_cge_idx7_12_8	0xA28F
-#define	reg_cge_idx7_12_8_pos 0
-#define	reg_cge_idx7_12_8_len 5
-#define	reg_cge_idx7_12_8_lsb 8
-#define xd_p_reg_cge_idx8_7_0	0xA290
-#define	reg_cge_idx8_7_0_pos 0
-#define	reg_cge_idx8_7_0_len 8
-#define	reg_cge_idx8_7_0_lsb 0
-#define xd_p_reg_cge_idx8_12_8	0xA291
-#define	reg_cge_idx8_12_8_pos 0
-#define	reg_cge_idx8_12_8_len 5
-#define	reg_cge_idx8_12_8_lsb 8
-#define xd_p_reg_cge_idx9_7_0	0xA292
-#define	reg_cge_idx9_7_0_pos 0
-#define	reg_cge_idx9_7_0_len 8
-#define	reg_cge_idx9_7_0_lsb 0
-#define xd_p_reg_cge_idx9_12_8	0xA293
-#define	reg_cge_idx9_12_8_pos 0
-#define	reg_cge_idx9_12_8_len 5
-#define	reg_cge_idx9_12_8_lsb 8
-#define xd_p_reg_cge_idx10_7_0	0xA294
-#define	reg_cge_idx10_7_0_pos 0
-#define	reg_cge_idx10_7_0_len 8
-#define	reg_cge_idx10_7_0_lsb 0
-#define xd_p_reg_cge_idx10_12_8	0xA295
-#define	reg_cge_idx10_12_8_pos 0
-#define	reg_cge_idx10_12_8_len 5
-#define	reg_cge_idx10_12_8_lsb 8
-#define xd_p_reg_cge_idx11_7_0	0xA296
-#define	reg_cge_idx11_7_0_pos 0
-#define	reg_cge_idx11_7_0_len 8
-#define	reg_cge_idx11_7_0_lsb 0
-#define xd_p_reg_cge_idx11_12_8	0xA297
-#define	reg_cge_idx11_12_8_pos 0
-#define	reg_cge_idx11_12_8_len 5
-#define	reg_cge_idx11_12_8_lsb 8
-#define xd_p_reg_cge_idx12_7_0	0xA298
-#define	reg_cge_idx12_7_0_pos 0
-#define	reg_cge_idx12_7_0_len 8
-#define	reg_cge_idx12_7_0_lsb 0
-#define xd_p_reg_cge_idx12_12_8	0xA299
-#define	reg_cge_idx12_12_8_pos 0
-#define	reg_cge_idx12_12_8_len 5
-#define	reg_cge_idx12_12_8_lsb 8
-#define xd_p_reg_cge_idx13_7_0	0xA29A
-#define	reg_cge_idx13_7_0_pos 0
-#define	reg_cge_idx13_7_0_len 8
-#define	reg_cge_idx13_7_0_lsb 0
-#define xd_p_reg_cge_idx13_12_8	0xA29B
-#define	reg_cge_idx13_12_8_pos 0
-#define	reg_cge_idx13_12_8_len 5
-#define	reg_cge_idx13_12_8_lsb 8
-#define xd_p_reg_cge_idx14_7_0	0xA29C
-#define	reg_cge_idx14_7_0_pos 0
-#define	reg_cge_idx14_7_0_len 8
-#define	reg_cge_idx14_7_0_lsb 0
-#define xd_p_reg_cge_idx14_12_8	0xA29D
-#define	reg_cge_idx14_12_8_pos 0
-#define	reg_cge_idx14_12_8_len 5
-#define	reg_cge_idx14_12_8_lsb 8
-#define xd_p_reg_cge_idx15_7_0	0xA29E
-#define	reg_cge_idx15_7_0_pos 0
-#define	reg_cge_idx15_7_0_len 8
-#define	reg_cge_idx15_7_0_lsb 0
-#define xd_p_reg_cge_idx15_12_8	0xA29F
-#define	reg_cge_idx15_12_8_pos 0
-#define	reg_cge_idx15_12_8_len 5
-#define	reg_cge_idx15_12_8_lsb 8
-#define xd_r_reg_fft_crc	0xA2A8
-#define	reg_fft_crc_pos 0
-#define	reg_fft_crc_len 8
-#define	reg_fft_crc_lsb 0
-#define xd_p_fd_fft_shift_max	0xA2A9
-#define	fd_fft_shift_max_pos 0
-#define	fd_fft_shift_max_len 4
-#define	fd_fft_shift_max_lsb 0
-#define xd_r_fd_fft_shift	0xA2A9
-#define	fd_fft_shift_pos 4
-#define	fd_fft_shift_len 4
-#define	fd_fft_shift_lsb 0
-#define xd_r_fd_fft_frame_num	0xA2AA
-#define	fd_fft_frame_num_pos 0
-#define	fd_fft_frame_num_len 2
-#define	fd_fft_frame_num_lsb 0
-#define xd_r_fd_fft_symbol_count	0xA2AB
-#define	fd_fft_symbol_count_pos 0
-#define	fd_fft_symbol_count_len 7
-#define	fd_fft_symbol_count_lsb 0
-#define xd_r_reg_fft_idx_max_7_0	0xA2AC
-#define	reg_fft_idx_max_7_0_pos 0
-#define	reg_fft_idx_max_7_0_len 8
-#define	reg_fft_idx_max_7_0_lsb 0
-#define xd_r_reg_fft_idx_max_12_8	0xA2AD
-#define	reg_fft_idx_max_12_8_pos 0
-#define	reg_fft_idx_max_12_8_len 5
-#define	reg_fft_idx_max_12_8_lsb 8
-#define xd_p_reg_cge_program	0xA2AE
-#define	reg_cge_program_pos 0
-#define	reg_cge_program_len 1
-#define	reg_cge_program_lsb 0
-#define xd_p_reg_cge_fixed	0xA2AE
-#define	reg_cge_fixed_pos 1
-#define	reg_cge_fixed_len 1
-#define	reg_cge_fixed_lsb 0
-#define xd_p_reg_fft_rotate_en	0xA2AE
-#define	reg_fft_rotate_en_pos 2
-#define	reg_fft_rotate_en_len 1
-#define	reg_fft_rotate_en_lsb 0
-#define xd_p_reg_fft_rotate_base_4_0	0xA2AE
-#define	reg_fft_rotate_base_4_0_pos 3
-#define	reg_fft_rotate_base_4_0_len 5
-#define	reg_fft_rotate_base_4_0_lsb 0
-#define xd_p_reg_fft_rotate_base_12_5	0xA2AF
-#define	reg_fft_rotate_base_12_5_pos 0
-#define	reg_fft_rotate_base_12_5_len 8
-#define	reg_fft_rotate_base_12_5_lsb 5
-#define xd_p_reg_gp_trigger_fd	0xA2B8
-#define	reg_gp_trigger_fd_pos 0
-#define	reg_gp_trigger_fd_len 1
-#define	reg_gp_trigger_fd_lsb 0
-#define xd_p_reg_trigger_sel_fd	0xA2B8
-#define	reg_trigger_sel_fd_pos 1
-#define	reg_trigger_sel_fd_len 2
-#define	reg_trigger_sel_fd_lsb 0
-#define xd_p_reg_trigger_module_sel_fd	0xA2B9
-#define	reg_trigger_module_sel_fd_pos 0
-#define	reg_trigger_module_sel_fd_len 6
-#define	reg_trigger_module_sel_fd_lsb 0
-#define xd_p_reg_trigger_set_sel_fd	0xA2BA
-#define	reg_trigger_set_sel_fd_pos 0
-#define	reg_trigger_set_sel_fd_len 6
-#define	reg_trigger_set_sel_fd_lsb 0
-#define xd_p_reg_fd_noname_7_0	0xA2BC
-#define	reg_fd_noname_7_0_pos 0
-#define	reg_fd_noname_7_0_len 8
-#define	reg_fd_noname_7_0_lsb 0
-#define xd_p_reg_fd_noname_15_8	0xA2BD
-#define	reg_fd_noname_15_8_pos 0
-#define	reg_fd_noname_15_8_len 8
-#define	reg_fd_noname_15_8_lsb 8
-#define xd_p_reg_fd_noname_23_16	0xA2BE
-#define	reg_fd_noname_23_16_pos 0
-#define	reg_fd_noname_23_16_len 8
-#define	reg_fd_noname_23_16_lsb 16
-#define xd_p_reg_fd_noname_31_24	0xA2BF
-#define	reg_fd_noname_31_24_pos 0
-#define	reg_fd_noname_31_24_len 8
-#define	reg_fd_noname_31_24_lsb 24
-#define xd_r_fd_fpcc_cp_corr_signn	0xA2C0
-#define	fd_fpcc_cp_corr_signn_pos 0
-#define	fd_fpcc_cp_corr_signn_len 8
-#define	fd_fpcc_cp_corr_signn_lsb 0
-#define xd_p_reg_feq_s1	0xA2C1
-#define	reg_feq_s1_pos 0
-#define	reg_feq_s1_len 5
-#define	reg_feq_s1_lsb 0
-#define xd_p_fd_fpcc_cp_corr_tone_th	0xA2C2
-#define	fd_fpcc_cp_corr_tone_th_pos 0
-#define	fd_fpcc_cp_corr_tone_th_len 6
-#define	fd_fpcc_cp_corr_tone_th_lsb 0
-#define xd_p_fd_fpcc_cp_corr_symbol_log_th	0xA2C3
-#define	fd_fpcc_cp_corr_symbol_log_th_pos 0
-#define	fd_fpcc_cp_corr_symbol_log_th_len 4
-#define	fd_fpcc_cp_corr_symbol_log_th_lsb 0
-#define xd_p_fd_fpcc_cp_corr_int	0xA2C4
-#define	fd_fpcc_cp_corr_int_pos 0
-#define	fd_fpcc_cp_corr_int_len 1
-#define	fd_fpcc_cp_corr_int_lsb 0
-#define xd_p_reg_sfoe_ns_7_0	0xA320
-#define	reg_sfoe_ns_7_0_pos 0
-#define	reg_sfoe_ns_7_0_len 8
-#define	reg_sfoe_ns_7_0_lsb 0
-#define xd_p_reg_sfoe_ns_14_8	0xA321
-#define	reg_sfoe_ns_14_8_pos 0
-#define	reg_sfoe_ns_14_8_len 7
-#define	reg_sfoe_ns_14_8_lsb 8
-#define xd_p_reg_sfoe_c1_7_0	0xA322
-#define	reg_sfoe_c1_7_0_pos 0
-#define	reg_sfoe_c1_7_0_len 8
-#define	reg_sfoe_c1_7_0_lsb 0
-#define xd_p_reg_sfoe_c1_15_8	0xA323
-#define	reg_sfoe_c1_15_8_pos 0
-#define	reg_sfoe_c1_15_8_len 8
-#define	reg_sfoe_c1_15_8_lsb 8
-#define xd_p_reg_sfoe_c1_17_16	0xA324
-#define	reg_sfoe_c1_17_16_pos 0
-#define	reg_sfoe_c1_17_16_len 2
-#define	reg_sfoe_c1_17_16_lsb 16
-#define xd_p_reg_sfoe_c2_7_0	0xA325
-#define	reg_sfoe_c2_7_0_pos 0
-#define	reg_sfoe_c2_7_0_len 8
-#define	reg_sfoe_c2_7_0_lsb 0
-#define xd_p_reg_sfoe_c2_15_8	0xA326
-#define	reg_sfoe_c2_15_8_pos 0
-#define	reg_sfoe_c2_15_8_len 8
-#define	reg_sfoe_c2_15_8_lsb 8
-#define xd_p_reg_sfoe_c2_17_16	0xA327
-#define	reg_sfoe_c2_17_16_pos 0
-#define	reg_sfoe_c2_17_16_len 2
-#define	reg_sfoe_c2_17_16_lsb 16
-#define xd_r_reg_sfoe_out_9_2	0xA328
-#define	reg_sfoe_out_9_2_pos 0
-#define	reg_sfoe_out_9_2_len 8
-#define	reg_sfoe_out_9_2_lsb 0
-#define xd_r_reg_sfoe_out_1_0	0xA329
-#define	reg_sfoe_out_1_0_pos 0
-#define	reg_sfoe_out_1_0_len 2
-#define	reg_sfoe_out_1_0_lsb 0
-#define xd_p_reg_sfoe_lm_counter_th	0xA32A
-#define	reg_sfoe_lm_counter_th_pos 0
-#define	reg_sfoe_lm_counter_th_len 4
-#define	reg_sfoe_lm_counter_th_lsb 0
-#define xd_p_reg_sfoe_convg_th	0xA32B
-#define	reg_sfoe_convg_th_pos 0
-#define	reg_sfoe_convg_th_len 8
-#define	reg_sfoe_convg_th_lsb 0
-#define xd_p_reg_sfoe_divg_th	0xA32C
-#define	reg_sfoe_divg_th_pos 0
-#define	reg_sfoe_divg_th_len 8
-#define	reg_sfoe_divg_th_lsb 0
-#define xd_p_fd_tpsd_en	0xA330
-#define	fd_tpsd_en_pos 0
-#define	fd_tpsd_en_len 1
-#define	fd_tpsd_en_lsb 0
-#define xd_p_fd_tpsd_dis	0xA330
-#define	fd_tpsd_dis_pos 1
-#define	fd_tpsd_dis_len 1
-#define	fd_tpsd_dis_lsb 0
-#define xd_p_fd_tpsd_rst	0xA330
-#define	fd_tpsd_rst_pos 2
-#define	fd_tpsd_rst_len 1
-#define	fd_tpsd_rst_lsb 0
-#define xd_p_fd_tpsd_lock	0xA330
-#define	fd_tpsd_lock_pos 3
-#define	fd_tpsd_lock_len 1
-#define	fd_tpsd_lock_lsb 0
-#define xd_r_fd_tpsd_s19	0xA330
-#define	fd_tpsd_s19_pos 4
-#define	fd_tpsd_s19_len 1
-#define	fd_tpsd_s19_lsb 0
-#define xd_r_fd_tpsd_s17	0xA330
-#define	fd_tpsd_s17_pos 5
-#define	fd_tpsd_s17_len 1
-#define	fd_tpsd_s17_lsb 0
-#define xd_p_fd_sfr_ste_en	0xA331
-#define	fd_sfr_ste_en_pos 0
-#define	fd_sfr_ste_en_len 1
-#define	fd_sfr_ste_en_lsb 0
-#define xd_p_fd_sfr_ste_dis	0xA331
-#define	fd_sfr_ste_dis_pos 1
-#define	fd_sfr_ste_dis_len 1
-#define	fd_sfr_ste_dis_lsb 0
-#define xd_p_fd_sfr_ste_rst	0xA331
-#define	fd_sfr_ste_rst_pos 2
-#define	fd_sfr_ste_rst_len 1
-#define	fd_sfr_ste_rst_lsb 0
-#define xd_p_fd_sfr_ste_mode	0xA331
-#define	fd_sfr_ste_mode_pos 3
-#define	fd_sfr_ste_mode_len 1
-#define	fd_sfr_ste_mode_lsb 0
-#define xd_p_fd_sfr_ste_done	0xA331
-#define	fd_sfr_ste_done_pos 4
-#define	fd_sfr_ste_done_len 1
-#define	fd_sfr_ste_done_lsb 0
-#define xd_p_reg_cfoe_ffoe_en	0xA332
-#define	reg_cfoe_ffoe_en_pos 0
-#define	reg_cfoe_ffoe_en_len 1
-#define	reg_cfoe_ffoe_en_lsb 0
-#define xd_p_reg_cfoe_ffoe_dis	0xA332
-#define	reg_cfoe_ffoe_dis_pos 1
-#define	reg_cfoe_ffoe_dis_len 1
-#define	reg_cfoe_ffoe_dis_lsb 0
-#define xd_p_reg_cfoe_ffoe_rst	0xA332
-#define	reg_cfoe_ffoe_rst_pos 2
-#define	reg_cfoe_ffoe_rst_len 1
-#define	reg_cfoe_ffoe_rst_lsb 0
-#define xd_p_reg_cfoe_ifoe_en	0xA332
-#define	reg_cfoe_ifoe_en_pos 3
-#define	reg_cfoe_ifoe_en_len 1
-#define	reg_cfoe_ifoe_en_lsb 0
-#define xd_p_reg_cfoe_ifoe_dis	0xA332
-#define	reg_cfoe_ifoe_dis_pos 4
-#define	reg_cfoe_ifoe_dis_len 1
-#define	reg_cfoe_ifoe_dis_lsb 0
-#define xd_p_reg_cfoe_ifoe_rst	0xA332
-#define	reg_cfoe_ifoe_rst_pos 5
-#define	reg_cfoe_ifoe_rst_len 1
-#define	reg_cfoe_ifoe_rst_lsb 0
-#define xd_p_reg_cfoe_fot_en	0xA332
-#define	reg_cfoe_fot_en_pos 6
-#define	reg_cfoe_fot_en_len 1
-#define	reg_cfoe_fot_en_lsb 0
-#define xd_p_reg_cfoe_fot_lm_en	0xA332
-#define	reg_cfoe_fot_lm_en_pos 7
-#define	reg_cfoe_fot_lm_en_len 1
-#define	reg_cfoe_fot_lm_en_lsb 0
-#define xd_p_reg_cfoe_fot_rst	0xA333
-#define	reg_cfoe_fot_rst_pos 0
-#define	reg_cfoe_fot_rst_len 1
-#define	reg_cfoe_fot_rst_lsb 0
-#define xd_r_fd_cfoe_ffoe_done	0xA333
-#define	fd_cfoe_ffoe_done_pos 1
-#define	fd_cfoe_ffoe_done_len 1
-#define	fd_cfoe_ffoe_done_lsb 0
-#define xd_p_fd_cfoe_metric_vld	0xA333
-#define	fd_cfoe_metric_vld_pos 2
-#define	fd_cfoe_metric_vld_len 1
-#define	fd_cfoe_metric_vld_lsb 0
-#define xd_p_reg_cfoe_ifod_vld	0xA333
-#define	reg_cfoe_ifod_vld_pos 3
-#define	reg_cfoe_ifod_vld_len 1
-#define	reg_cfoe_ifod_vld_lsb 0
-#define xd_r_fd_cfoe_ifoe_done	0xA333
-#define	fd_cfoe_ifoe_done_pos 4
-#define	fd_cfoe_ifoe_done_len 1
-#define	fd_cfoe_ifoe_done_lsb 0
-#define xd_r_fd_cfoe_fot_valid	0xA333
-#define	fd_cfoe_fot_valid_pos 5
-#define	fd_cfoe_fot_valid_len 1
-#define	fd_cfoe_fot_valid_lsb 0
-#define xd_p_reg_cfoe_divg_int	0xA333
-#define	reg_cfoe_divg_int_pos 6
-#define	reg_cfoe_divg_int_len 1
-#define	reg_cfoe_divg_int_lsb 0
-#define xd_r_reg_cfoe_divg_flag	0xA333
-#define	reg_cfoe_divg_flag_pos 7
-#define	reg_cfoe_divg_flag_len 1
-#define	reg_cfoe_divg_flag_lsb 0
-#define xd_p_reg_sfoe_en	0xA334
-#define	reg_sfoe_en_pos 0
-#define	reg_sfoe_en_len 1
-#define	reg_sfoe_en_lsb 0
-#define xd_p_reg_sfoe_dis	0xA334
-#define	reg_sfoe_dis_pos 1
-#define	reg_sfoe_dis_len 1
-#define	reg_sfoe_dis_lsb 0
-#define xd_p_reg_sfoe_rst	0xA334
-#define	reg_sfoe_rst_pos 2
-#define	reg_sfoe_rst_len 1
-#define	reg_sfoe_rst_lsb 0
-#define xd_p_reg_sfoe_vld_int	0xA334
-#define	reg_sfoe_vld_int_pos 3
-#define	reg_sfoe_vld_int_len 1
-#define	reg_sfoe_vld_int_lsb 0
-#define xd_p_reg_sfoe_lm_en	0xA334
-#define	reg_sfoe_lm_en_pos 4
-#define	reg_sfoe_lm_en_len 1
-#define	reg_sfoe_lm_en_lsb 0
-#define xd_p_reg_sfoe_divg_int	0xA334
-#define	reg_sfoe_divg_int_pos 5
-#define	reg_sfoe_divg_int_len 1
-#define	reg_sfoe_divg_int_lsb 0
-#define xd_r_reg_sfoe_divg_flag	0xA334
-#define	reg_sfoe_divg_flag_pos 6
-#define	reg_sfoe_divg_flag_len 1
-#define	reg_sfoe_divg_flag_lsb 0
-#define xd_p_reg_fft_rst	0xA335
-#define	reg_fft_rst_pos 0
-#define	reg_fft_rst_len 1
-#define	reg_fft_rst_lsb 0
-#define xd_p_reg_fft_fast_beacon	0xA335
-#define	reg_fft_fast_beacon_pos 1
-#define	reg_fft_fast_beacon_len 1
-#define	reg_fft_fast_beacon_lsb 0
-#define xd_p_reg_fft_fast_valid	0xA335
-#define	reg_fft_fast_valid_pos 2
-#define	reg_fft_fast_valid_len 1
-#define	reg_fft_fast_valid_lsb 0
-#define xd_p_reg_fft_mask_en	0xA335
-#define	reg_fft_mask_en_pos 3
-#define	reg_fft_mask_en_len 1
-#define	reg_fft_mask_en_lsb 0
-#define xd_p_reg_fft_crc_en	0xA335
-#define	reg_fft_crc_en_pos 4
-#define	reg_fft_crc_en_len 1
-#define	reg_fft_crc_en_lsb 0
-#define xd_p_reg_finr_en	0xA336
-#define	reg_finr_en_pos 0
-#define	reg_finr_en_len 1
-#define	reg_finr_en_lsb 0
-#define xd_p_fd_fste_en	0xA337
-#define	fd_fste_en_pos 1
-#define	fd_fste_en_len 1
-#define	fd_fste_en_lsb 0
-#define xd_p_fd_sqi_tps_level_shift	0xA338
-#define	fd_sqi_tps_level_shift_pos 0
-#define	fd_sqi_tps_level_shift_len 8
-#define	fd_sqi_tps_level_shift_lsb 0
-#define xd_p_fd_pilot_ma_len	0xA339
-#define	fd_pilot_ma_len_pos 0
-#define	fd_pilot_ma_len_len 6
-#define	fd_pilot_ma_len_lsb 0
-#define xd_p_fd_tps_ma_len	0xA33A
-#define	fd_tps_ma_len_pos 0
-#define	fd_tps_ma_len_len 6
-#define	fd_tps_ma_len_lsb 0
-#define xd_p_fd_sqi_s3	0xA33B
-#define	fd_sqi_s3_pos 0
-#define	fd_sqi_s3_len 8
-#define	fd_sqi_s3_lsb 0
-#define xd_p_fd_sqi_dummy_reg_0	0xA33C
-#define	fd_sqi_dummy_reg_0_pos 0
-#define	fd_sqi_dummy_reg_0_len 1
-#define	fd_sqi_dummy_reg_0_lsb 0
-#define xd_p_fd_sqi_debug_sel	0xA33C
-#define	fd_sqi_debug_sel_pos 1
-#define	fd_sqi_debug_sel_len 2
-#define	fd_sqi_debug_sel_lsb 0
-#define xd_p_fd_sqi_s2	0xA33C
-#define	fd_sqi_s2_pos 3
-#define	fd_sqi_s2_len 5
-#define	fd_sqi_s2_lsb 0
-#define xd_p_fd_sqi_dummy_reg_1	0xA33D
-#define	fd_sqi_dummy_reg_1_pos 0
-#define	fd_sqi_dummy_reg_1_len 1
-#define	fd_sqi_dummy_reg_1_lsb 0
-#define xd_p_fd_inr_ignore	0xA33D
-#define	fd_inr_ignore_pos 1
-#define	fd_inr_ignore_len 1
-#define	fd_inr_ignore_lsb 0
-#define xd_p_fd_pilot_ignore	0xA33D
-#define	fd_pilot_ignore_pos 2
-#define	fd_pilot_ignore_len 1
-#define	fd_pilot_ignore_lsb 0
-#define xd_p_fd_etps_ignore	0xA33D
-#define	fd_etps_ignore_pos 3
-#define	fd_etps_ignore_len 1
-#define	fd_etps_ignore_lsb 0
-#define xd_p_fd_sqi_s1	0xA33D
-#define	fd_sqi_s1_pos 4
-#define	fd_sqi_s1_len 4
-#define	fd_sqi_s1_lsb 0
-#define xd_p_reg_fste_ehw_7_0	0xA33E
-#define	reg_fste_ehw_7_0_pos 0
-#define	reg_fste_ehw_7_0_len 8
-#define	reg_fste_ehw_7_0_lsb 0
-#define xd_p_reg_fste_ehw_9_8	0xA33F
-#define	reg_fste_ehw_9_8_pos 0
-#define	reg_fste_ehw_9_8_len 2
-#define	reg_fste_ehw_9_8_lsb 8
-#define xd_p_reg_fste_i_adj_vld	0xA33F
-#define	reg_fste_i_adj_vld_pos 2
-#define	reg_fste_i_adj_vld_len 1
-#define	reg_fste_i_adj_vld_lsb 0
-#define xd_p_reg_fste_phase_ini_7_0	0xA340
-#define	reg_fste_phase_ini_7_0_pos 0
-#define	reg_fste_phase_ini_7_0_len 8
-#define	reg_fste_phase_ini_7_0_lsb 0
-#define xd_p_reg_fste_phase_ini_11_8	0xA341
-#define	reg_fste_phase_ini_11_8_pos 0
-#define	reg_fste_phase_ini_11_8_len 4
-#define	reg_fste_phase_ini_11_8_lsb 8
-#define xd_p_reg_fste_phase_inc_3_0	0xA341
-#define	reg_fste_phase_inc_3_0_pos 4
-#define	reg_fste_phase_inc_3_0_len 4
-#define	reg_fste_phase_inc_3_0_lsb 0
-#define xd_p_reg_fste_phase_inc_11_4	0xA342
-#define	reg_fste_phase_inc_11_4_pos 0
-#define	reg_fste_phase_inc_11_4_len 8
-#define	reg_fste_phase_inc_11_4_lsb 4
-#define xd_p_reg_fste_acum_cost_cnt_max	0xA343
-#define	reg_fste_acum_cost_cnt_max_pos 0
-#define	reg_fste_acum_cost_cnt_max_len 4
-#define	reg_fste_acum_cost_cnt_max_lsb 0
-#define xd_p_reg_fste_step_size_std	0xA343
-#define	reg_fste_step_size_std_pos 4
-#define	reg_fste_step_size_std_len 4
-#define	reg_fste_step_size_std_lsb 0
-#define xd_p_reg_fste_step_size_max	0xA344
-#define	reg_fste_step_size_max_pos 0
-#define	reg_fste_step_size_max_len 4
-#define	reg_fste_step_size_max_lsb 0
-#define xd_p_reg_fste_step_size_min	0xA344
-#define	reg_fste_step_size_min_pos 4
-#define	reg_fste_step_size_min_len 4
-#define	reg_fste_step_size_min_lsb 0
-#define xd_p_reg_fste_frac_step_size_7_0	0xA345
-#define	reg_fste_frac_step_size_7_0_pos 0
-#define	reg_fste_frac_step_size_7_0_len 8
-#define	reg_fste_frac_step_size_7_0_lsb 0
-#define xd_p_reg_fste_frac_step_size_15_8	0xA346
-#define	reg_fste_frac_step_size_15_8_pos 0
-#define	reg_fste_frac_step_size_15_8_len 8
-#define	reg_fste_frac_step_size_15_8_lsb 8
-#define xd_p_reg_fste_frac_step_size_19_16	0xA347
-#define	reg_fste_frac_step_size_19_16_pos 0
-#define	reg_fste_frac_step_size_19_16_len 4
-#define	reg_fste_frac_step_size_19_16_lsb 16
-#define xd_p_reg_fste_rpd_dir_cnt_max	0xA347
-#define	reg_fste_rpd_dir_cnt_max_pos 4
-#define	reg_fste_rpd_dir_cnt_max_len 4
-#define	reg_fste_rpd_dir_cnt_max_lsb 0
-#define xd_p_reg_fste_ehs	0xA348
-#define	reg_fste_ehs_pos 0
-#define	reg_fste_ehs_len 4
-#define	reg_fste_ehs_lsb 0
-#define xd_p_reg_fste_frac_cost_cnt_max_3_0	0xA348
-#define	reg_fste_frac_cost_cnt_max_3_0_pos 4
-#define	reg_fste_frac_cost_cnt_max_3_0_len 4
-#define	reg_fste_frac_cost_cnt_max_3_0_lsb 0
-#define xd_p_reg_fste_frac_cost_cnt_max_9_4	0xA349
-#define	reg_fste_frac_cost_cnt_max_9_4_pos 0
-#define	reg_fste_frac_cost_cnt_max_9_4_len 6
-#define	reg_fste_frac_cost_cnt_max_9_4_lsb 4
-#define xd_p_reg_fste_w0_7_0	0xA34A
-#define	reg_fste_w0_7_0_pos 0
-#define	reg_fste_w0_7_0_len 8
-#define	reg_fste_w0_7_0_lsb 0
-#define xd_p_reg_fste_w0_11_8	0xA34B
-#define	reg_fste_w0_11_8_pos 0
-#define	reg_fste_w0_11_8_len 4
-#define	reg_fste_w0_11_8_lsb 8
-#define xd_p_reg_fste_w1_3_0	0xA34B
-#define	reg_fste_w1_3_0_pos 4
-#define	reg_fste_w1_3_0_len 4
-#define	reg_fste_w1_3_0_lsb 0
-#define xd_p_reg_fste_w1_11_4	0xA34C
-#define	reg_fste_w1_11_4_pos 0
-#define	reg_fste_w1_11_4_len 8
-#define	reg_fste_w1_11_4_lsb 4
-#define xd_p_reg_fste_w2_7_0	0xA34D
-#define	reg_fste_w2_7_0_pos 0
-#define	reg_fste_w2_7_0_len 8
-#define	reg_fste_w2_7_0_lsb 0
-#define xd_p_reg_fste_w2_11_8	0xA34E
-#define	reg_fste_w2_11_8_pos 0
-#define	reg_fste_w2_11_8_len 4
-#define	reg_fste_w2_11_8_lsb 8
-#define xd_p_reg_fste_w3_3_0	0xA34E
-#define	reg_fste_w3_3_0_pos 4
-#define	reg_fste_w3_3_0_len 4
-#define	reg_fste_w3_3_0_lsb 0
-#define xd_p_reg_fste_w3_11_4	0xA34F
-#define	reg_fste_w3_11_4_pos 0
-#define	reg_fste_w3_11_4_len 8
-#define	reg_fste_w3_11_4_lsb 4
-#define xd_p_reg_fste_w4_7_0	0xA350
-#define	reg_fste_w4_7_0_pos 0
-#define	reg_fste_w4_7_0_len 8
-#define	reg_fste_w4_7_0_lsb 0
-#define xd_p_reg_fste_w4_11_8	0xA351
-#define	reg_fste_w4_11_8_pos 0
-#define	reg_fste_w4_11_8_len 4
-#define	reg_fste_w4_11_8_lsb 8
-#define xd_p_reg_fste_w5_3_0	0xA351
-#define	reg_fste_w5_3_0_pos 4
-#define	reg_fste_w5_3_0_len 4
-#define	reg_fste_w5_3_0_lsb 0
-#define xd_p_reg_fste_w5_11_4	0xA352
-#define	reg_fste_w5_11_4_pos 0
-#define	reg_fste_w5_11_4_len 8
-#define	reg_fste_w5_11_4_lsb 4
-#define xd_p_reg_fste_w6_7_0	0xA353
-#define	reg_fste_w6_7_0_pos 0
-#define	reg_fste_w6_7_0_len 8
-#define	reg_fste_w6_7_0_lsb 0
-#define xd_p_reg_fste_w6_11_8	0xA354
-#define	reg_fste_w6_11_8_pos 0
-#define	reg_fste_w6_11_8_len 4
-#define	reg_fste_w6_11_8_lsb 8
-#define xd_p_reg_fste_w7_3_0	0xA354
-#define	reg_fste_w7_3_0_pos 4
-#define	reg_fste_w7_3_0_len 4
-#define	reg_fste_w7_3_0_lsb 0
-#define xd_p_reg_fste_w7_11_4	0xA355
-#define	reg_fste_w7_11_4_pos 0
-#define	reg_fste_w7_11_4_len 8
-#define	reg_fste_w7_11_4_lsb 4
-#define xd_p_reg_fste_w8_7_0	0xA356
-#define	reg_fste_w8_7_0_pos 0
-#define	reg_fste_w8_7_0_len 8
-#define	reg_fste_w8_7_0_lsb 0
-#define xd_p_reg_fste_w8_11_8	0xA357
-#define	reg_fste_w8_11_8_pos 0
-#define	reg_fste_w8_11_8_len 4
-#define	reg_fste_w8_11_8_lsb 8
-#define xd_p_reg_fste_w9_3_0	0xA357
-#define	reg_fste_w9_3_0_pos 4
-#define	reg_fste_w9_3_0_len 4
-#define	reg_fste_w9_3_0_lsb 0
-#define xd_p_reg_fste_w9_11_4	0xA358
-#define	reg_fste_w9_11_4_pos 0
-#define	reg_fste_w9_11_4_len 8
-#define	reg_fste_w9_11_4_lsb 4
-#define xd_p_reg_fste_wa_7_0	0xA359
-#define	reg_fste_wa_7_0_pos 0
-#define	reg_fste_wa_7_0_len 8
-#define	reg_fste_wa_7_0_lsb 0
-#define xd_p_reg_fste_wa_11_8	0xA35A
-#define	reg_fste_wa_11_8_pos 0
-#define	reg_fste_wa_11_8_len 4
-#define	reg_fste_wa_11_8_lsb 8
-#define xd_p_reg_fste_wb_3_0	0xA35A
-#define	reg_fste_wb_3_0_pos 4
-#define	reg_fste_wb_3_0_len 4
-#define	reg_fste_wb_3_0_lsb 0
-#define xd_p_reg_fste_wb_11_4	0xA35B
-#define	reg_fste_wb_11_4_pos 0
-#define	reg_fste_wb_11_4_len 8
-#define	reg_fste_wb_11_4_lsb 4
-#define xd_r_fd_fste_i_adj	0xA35C
-#define	fd_fste_i_adj_pos 0
-#define	fd_fste_i_adj_len 5
-#define	fd_fste_i_adj_lsb 0
-#define xd_r_fd_fste_f_adj_7_0	0xA35D
-#define	fd_fste_f_adj_7_0_pos 0
-#define	fd_fste_f_adj_7_0_len 8
-#define	fd_fste_f_adj_7_0_lsb 0
-#define xd_r_fd_fste_f_adj_15_8	0xA35E
-#define	fd_fste_f_adj_15_8_pos 0
-#define	fd_fste_f_adj_15_8_len 8
-#define	fd_fste_f_adj_15_8_lsb 8
-#define xd_r_fd_fste_f_adj_19_16	0xA35F
-#define	fd_fste_f_adj_19_16_pos 0
-#define	fd_fste_f_adj_19_16_len 4
-#define	fd_fste_f_adj_19_16_lsb 16
-#define xd_p_reg_feq_Leak_Bypass	0xA366
-#define	reg_feq_Leak_Bypass_pos 0
-#define	reg_feq_Leak_Bypass_len 1
-#define	reg_feq_Leak_Bypass_lsb 0
-#define xd_p_reg_feq_Leak_Mneg1	0xA366
-#define	reg_feq_Leak_Mneg1_pos 1
-#define	reg_feq_Leak_Mneg1_len 3
-#define	reg_feq_Leak_Mneg1_lsb 0
-#define xd_p_reg_feq_Leak_B_ShiftQ	0xA366
-#define	reg_feq_Leak_B_ShiftQ_pos 4
-#define	reg_feq_Leak_B_ShiftQ_len 4
-#define	reg_feq_Leak_B_ShiftQ_lsb 0
-#define xd_p_reg_feq_Leak_B_Float0	0xA367
-#define	reg_feq_Leak_B_Float0_pos 0
-#define	reg_feq_Leak_B_Float0_len 8
-#define	reg_feq_Leak_B_Float0_lsb 0
-#define xd_p_reg_feq_Leak_B_Float1	0xA368
-#define	reg_feq_Leak_B_Float1_pos 0
-#define	reg_feq_Leak_B_Float1_len 8
-#define	reg_feq_Leak_B_Float1_lsb 0
-#define xd_p_reg_feq_Leak_B_Float2	0xA369
-#define	reg_feq_Leak_B_Float2_pos 0
-#define	reg_feq_Leak_B_Float2_len 8
-#define	reg_feq_Leak_B_Float2_lsb 0
-#define xd_p_reg_feq_Leak_B_Float3	0xA36A
-#define	reg_feq_Leak_B_Float3_pos 0
-#define	reg_feq_Leak_B_Float3_len 8
-#define	reg_feq_Leak_B_Float3_lsb 0
-#define xd_p_reg_feq_Leak_B_Float4	0xA36B
-#define	reg_feq_Leak_B_Float4_pos 0
-#define	reg_feq_Leak_B_Float4_len 8
-#define	reg_feq_Leak_B_Float4_lsb 0
-#define xd_p_reg_feq_Leak_B_Float5	0xA36C
-#define	reg_feq_Leak_B_Float5_pos 0
-#define	reg_feq_Leak_B_Float5_len 8
-#define	reg_feq_Leak_B_Float5_lsb 0
-#define xd_p_reg_feq_Leak_B_Float6	0xA36D
-#define	reg_feq_Leak_B_Float6_pos 0
-#define	reg_feq_Leak_B_Float6_len 8
-#define	reg_feq_Leak_B_Float6_lsb 0
-#define xd_p_reg_feq_Leak_B_Float7	0xA36E
-#define	reg_feq_Leak_B_Float7_pos 0
-#define	reg_feq_Leak_B_Float7_len 8
-#define	reg_feq_Leak_B_Float7_lsb 0
-#define xd_r_reg_feq_data_h2_7_0	0xA36F
-#define	reg_feq_data_h2_7_0_pos 0
-#define	reg_feq_data_h2_7_0_len 8
-#define	reg_feq_data_h2_7_0_lsb 0
-#define xd_r_reg_feq_data_h2_9_8	0xA370
-#define	reg_feq_data_h2_9_8_pos 0
-#define	reg_feq_data_h2_9_8_len 2
-#define	reg_feq_data_h2_9_8_lsb 8
-#define xd_p_reg_feq_leak_use_slice_tps	0xA371
-#define	reg_feq_leak_use_slice_tps_pos 0
-#define	reg_feq_leak_use_slice_tps_len 1
-#define	reg_feq_leak_use_slice_tps_lsb 0
-#define xd_p_reg_feq_read_update	0xA371
-#define	reg_feq_read_update_pos 1
-#define	reg_feq_read_update_len 1
-#define	reg_feq_read_update_lsb 0
-#define xd_p_reg_feq_data_vld	0xA371
-#define	reg_feq_data_vld_pos 2
-#define	reg_feq_data_vld_len 1
-#define	reg_feq_data_vld_lsb 0
-#define xd_p_reg_feq_tone_idx_4_0	0xA371
-#define	reg_feq_tone_idx_4_0_pos 3
-#define	reg_feq_tone_idx_4_0_len 5
-#define	reg_feq_tone_idx_4_0_lsb 0
-#define xd_p_reg_feq_tone_idx_12_5	0xA372
-#define	reg_feq_tone_idx_12_5_pos 0
-#define	reg_feq_tone_idx_12_5_len 8
-#define	reg_feq_tone_idx_12_5_lsb 5
-#define xd_r_reg_feq_data_re_7_0	0xA373
-#define	reg_feq_data_re_7_0_pos 0
-#define	reg_feq_data_re_7_0_len 8
-#define	reg_feq_data_re_7_0_lsb 0
-#define xd_r_reg_feq_data_re_10_8	0xA374
-#define	reg_feq_data_re_10_8_pos 0
-#define	reg_feq_data_re_10_8_len 3
-#define	reg_feq_data_re_10_8_lsb 8
-#define xd_r_reg_feq_data_im_7_0	0xA375
-#define	reg_feq_data_im_7_0_pos 0
-#define	reg_feq_data_im_7_0_len 8
-#define	reg_feq_data_im_7_0_lsb 0
-#define xd_r_reg_feq_data_im_10_8	0xA376
-#define	reg_feq_data_im_10_8_pos 0
-#define	reg_feq_data_im_10_8_len 3
-#define	reg_feq_data_im_10_8_lsb 8
-#define xd_r_reg_feq_y_re	0xA377
-#define	reg_feq_y_re_pos 0
-#define	reg_feq_y_re_len 8
-#define	reg_feq_y_re_lsb 0
-#define xd_r_reg_feq_y_im	0xA378
-#define	reg_feq_y_im_pos 0
-#define	reg_feq_y_im_len 8
-#define	reg_feq_y_im_lsb 0
-#define xd_r_reg_feq_h_re_7_0	0xA379
-#define	reg_feq_h_re_7_0_pos 0
-#define	reg_feq_h_re_7_0_len 8
-#define	reg_feq_h_re_7_0_lsb 0
-#define xd_r_reg_feq_h_re_8	0xA37A
-#define	reg_feq_h_re_8_pos 0
-#define	reg_feq_h_re_8_len 1
-#define	reg_feq_h_re_8_lsb 0
-#define xd_r_reg_feq_h_im_7_0	0xA37B
-#define	reg_feq_h_im_7_0_pos 0
-#define	reg_feq_h_im_7_0_len 8
-#define	reg_feq_h_im_7_0_lsb 0
-#define xd_r_reg_feq_h_im_8	0xA37C
-#define	reg_feq_h_im_8_pos 0
-#define	reg_feq_h_im_8_len 1
-#define	reg_feq_h_im_8_lsb 0
-#define xd_p_fec_super_frm_unit_7_0	0xA380
-#define	fec_super_frm_unit_7_0_pos 0
-#define	fec_super_frm_unit_7_0_len 8
-#define	fec_super_frm_unit_7_0_lsb 0
-#define xd_p_fec_super_frm_unit_15_8	0xA381
-#define	fec_super_frm_unit_15_8_pos 0
-#define	fec_super_frm_unit_15_8_len 8
-#define	fec_super_frm_unit_15_8_lsb 8
-#define xd_r_fec_vtb_err_bit_cnt_7_0	0xA382
-#define	fec_vtb_err_bit_cnt_7_0_pos 0
-#define	fec_vtb_err_bit_cnt_7_0_len 8
-#define	fec_vtb_err_bit_cnt_7_0_lsb 0
-#define xd_r_fec_vtb_err_bit_cnt_15_8	0xA383
-#define	fec_vtb_err_bit_cnt_15_8_pos 0
-#define	fec_vtb_err_bit_cnt_15_8_len 8
-#define	fec_vtb_err_bit_cnt_15_8_lsb 8
-#define xd_r_fec_vtb_err_bit_cnt_23_16	0xA384
-#define	fec_vtb_err_bit_cnt_23_16_pos 0
-#define	fec_vtb_err_bit_cnt_23_16_len 8
-#define	fec_vtb_err_bit_cnt_23_16_lsb 16
-#define xd_p_fec_rsd_packet_unit_7_0	0xA385
-#define	fec_rsd_packet_unit_7_0_pos 0
-#define	fec_rsd_packet_unit_7_0_len 8
-#define	fec_rsd_packet_unit_7_0_lsb 0
-#define xd_p_fec_rsd_packet_unit_15_8	0xA386
-#define	fec_rsd_packet_unit_15_8_pos 0
-#define	fec_rsd_packet_unit_15_8_len 8
-#define	fec_rsd_packet_unit_15_8_lsb 8
-#define xd_r_fec_rsd_bit_err_cnt_7_0	0xA387
-#define	fec_rsd_bit_err_cnt_7_0_pos 0
-#define	fec_rsd_bit_err_cnt_7_0_len 8
-#define	fec_rsd_bit_err_cnt_7_0_lsb 0
-#define xd_r_fec_rsd_bit_err_cnt_15_8	0xA388
-#define	fec_rsd_bit_err_cnt_15_8_pos 0
-#define	fec_rsd_bit_err_cnt_15_8_len 8
-#define	fec_rsd_bit_err_cnt_15_8_lsb 8
-#define xd_r_fec_rsd_bit_err_cnt_23_16	0xA389
-#define	fec_rsd_bit_err_cnt_23_16_pos 0
-#define	fec_rsd_bit_err_cnt_23_16_len 8
-#define	fec_rsd_bit_err_cnt_23_16_lsb 16
-#define xd_r_fec_rsd_abort_packet_cnt_7_0	0xA38A
-#define	fec_rsd_abort_packet_cnt_7_0_pos 0
-#define	fec_rsd_abort_packet_cnt_7_0_len 8
-#define	fec_rsd_abort_packet_cnt_7_0_lsb 0
-#define xd_r_fec_rsd_abort_packet_cnt_15_8	0xA38B
-#define	fec_rsd_abort_packet_cnt_15_8_pos 0
-#define	fec_rsd_abort_packet_cnt_15_8_len 8
-#define	fec_rsd_abort_packet_cnt_15_8_lsb 8
-#define xd_p_fec_RSD_PKT_NUM_PER_UNIT_7_0	0xA38C
-#define	fec_RSD_PKT_NUM_PER_UNIT_7_0_pos 0
-#define	fec_RSD_PKT_NUM_PER_UNIT_7_0_len 8
-#define	fec_RSD_PKT_NUM_PER_UNIT_7_0_lsb 0
-#define xd_p_fec_RSD_PKT_NUM_PER_UNIT_15_8	0xA38D
-#define	fec_RSD_PKT_NUM_PER_UNIT_15_8_pos 0
-#define	fec_RSD_PKT_NUM_PER_UNIT_15_8_len 8
-#define	fec_RSD_PKT_NUM_PER_UNIT_15_8_lsb 8
-#define xd_p_fec_RS_TH_1_7_0	0xA38E
-#define	fec_RS_TH_1_7_0_pos 0
-#define	fec_RS_TH_1_7_0_len 8
-#define	fec_RS_TH_1_7_0_lsb 0
-#define xd_p_fec_RS_TH_1_15_8	0xA38F
-#define	fec_RS_TH_1_15_8_pos 0
-#define	fec_RS_TH_1_15_8_len 8
-#define	fec_RS_TH_1_15_8_lsb 8
-#define xd_p_fec_RS_TH_2	0xA390
-#define	fec_RS_TH_2_pos 0
-#define	fec_RS_TH_2_len 8
-#define	fec_RS_TH_2_lsb 0
-#define xd_p_fec_mon_en	0xA391
-#define	fec_mon_en_pos 0
-#define	fec_mon_en_len 1
-#define	fec_mon_en_lsb 0
-#define xd_p_reg_b8to47	0xA391
-#define	reg_b8to47_pos 1
-#define	reg_b8to47_len 1
-#define	reg_b8to47_lsb 0
-#define xd_p_reg_rsd_sync_rep	0xA391
-#define	reg_rsd_sync_rep_pos 2
-#define	reg_rsd_sync_rep_len 1
-#define	reg_rsd_sync_rep_lsb 0
-#define xd_p_fec_rsd_retrain_rst	0xA391
-#define	fec_rsd_retrain_rst_pos 3
-#define	fec_rsd_retrain_rst_len 1
-#define	fec_rsd_retrain_rst_lsb 0
-#define xd_r_fec_rsd_ber_rdy	0xA391
-#define	fec_rsd_ber_rdy_pos 4
-#define	fec_rsd_ber_rdy_len 1
-#define	fec_rsd_ber_rdy_lsb 0
-#define xd_p_fec_rsd_ber_rst	0xA391
-#define	fec_rsd_ber_rst_pos 5
-#define	fec_rsd_ber_rst_len 1
-#define	fec_rsd_ber_rst_lsb 0
-#define xd_r_fec_vtb_ber_rdy	0xA391
-#define	fec_vtb_ber_rdy_pos 6
-#define	fec_vtb_ber_rdy_len 1
-#define	fec_vtb_ber_rdy_lsb 0
-#define xd_p_fec_vtb_ber_rst	0xA391
-#define	fec_vtb_ber_rst_pos 7
-#define	fec_vtb_ber_rst_len 1
-#define	fec_vtb_ber_rst_lsb 0
-#define xd_p_reg_vtb_clk40en	0xA392
-#define	reg_vtb_clk40en_pos 0
-#define	reg_vtb_clk40en_len 1
-#define	reg_vtb_clk40en_lsb 0
-#define xd_p_fec_vtb_rsd_mon_en	0xA392
-#define	fec_vtb_rsd_mon_en_pos 1
-#define	fec_vtb_rsd_mon_en_len 1
-#define	fec_vtb_rsd_mon_en_lsb 0
-#define xd_p_reg_fec_data_en	0xA392
-#define	reg_fec_data_en_pos 2
-#define	reg_fec_data_en_len 1
-#define	reg_fec_data_en_lsb 0
-#define xd_p_fec_dummy_reg_2	0xA392
-#define	fec_dummy_reg_2_pos 3
-#define	fec_dummy_reg_2_len 3
-#define	fec_dummy_reg_2_lsb 0
-#define xd_p_reg_sync_chk	0xA392
-#define	reg_sync_chk_pos 6
-#define	reg_sync_chk_len 1
-#define	reg_sync_chk_lsb 0
-#define xd_p_fec_rsd_bypass	0xA392
-#define	fec_rsd_bypass_pos 7
-#define	fec_rsd_bypass_len 1
-#define	fec_rsd_bypass_lsb 0
-#define xd_p_fec_sw_rst	0xA393
-#define	fec_sw_rst_pos 0
-#define	fec_sw_rst_len 1
-#define	fec_sw_rst_lsb 0
-#define xd_r_fec_vtb_pm_crc	0xA394
-#define	fec_vtb_pm_crc_pos 0
-#define	fec_vtb_pm_crc_len 8
-#define	fec_vtb_pm_crc_lsb 0
-#define xd_r_fec_vtb_tb_7_crc	0xA395
-#define	fec_vtb_tb_7_crc_pos 0
-#define	fec_vtb_tb_7_crc_len 8
-#define	fec_vtb_tb_7_crc_lsb 0
-#define xd_r_fec_vtb_tb_6_crc	0xA396
-#define	fec_vtb_tb_6_crc_pos 0
-#define	fec_vtb_tb_6_crc_len 8
-#define	fec_vtb_tb_6_crc_lsb 0
-#define xd_r_fec_vtb_tb_5_crc	0xA397
-#define	fec_vtb_tb_5_crc_pos 0
-#define	fec_vtb_tb_5_crc_len 8
-#define	fec_vtb_tb_5_crc_lsb 0
-#define xd_r_fec_vtb_tb_4_crc	0xA398
-#define	fec_vtb_tb_4_crc_pos 0
-#define	fec_vtb_tb_4_crc_len 8
-#define	fec_vtb_tb_4_crc_lsb 0
-#define xd_r_fec_vtb_tb_3_crc	0xA399
-#define	fec_vtb_tb_3_crc_pos 0
-#define	fec_vtb_tb_3_crc_len 8
-#define	fec_vtb_tb_3_crc_lsb 0
-#define xd_r_fec_vtb_tb_2_crc	0xA39A
-#define	fec_vtb_tb_2_crc_pos 0
-#define	fec_vtb_tb_2_crc_len 8
-#define	fec_vtb_tb_2_crc_lsb 0
-#define xd_r_fec_vtb_tb_1_crc	0xA39B
-#define	fec_vtb_tb_1_crc_pos 0
-#define	fec_vtb_tb_1_crc_len 8
-#define	fec_vtb_tb_1_crc_lsb 0
-#define xd_r_fec_vtb_tb_0_crc	0xA39C
-#define	fec_vtb_tb_0_crc_pos 0
-#define	fec_vtb_tb_0_crc_len 8
-#define	fec_vtb_tb_0_crc_lsb 0
-#define xd_r_fec_rsd_bank0_crc	0xA39D
-#define	fec_rsd_bank0_crc_pos 0
-#define	fec_rsd_bank0_crc_len 8
-#define	fec_rsd_bank0_crc_lsb 0
-#define xd_r_fec_rsd_bank1_crc	0xA39E
-#define	fec_rsd_bank1_crc_pos 0
-#define	fec_rsd_bank1_crc_len 8
-#define	fec_rsd_bank1_crc_lsb 0
-#define xd_r_fec_idi_vtb_crc	0xA39F
-#define	fec_idi_vtb_crc_pos 0
-#define	fec_idi_vtb_crc_len 8
-#define	fec_idi_vtb_crc_lsb 0
-#define xd_g_reg_tpsd_txmod	0xA3C0
-#define	reg_tpsd_txmod_pos 0
-#define	reg_tpsd_txmod_len 2
-#define	reg_tpsd_txmod_lsb 0
-#define xd_g_reg_tpsd_gi	0xA3C0
-#define	reg_tpsd_gi_pos 2
-#define	reg_tpsd_gi_len 2
-#define	reg_tpsd_gi_lsb 0
-#define xd_g_reg_tpsd_hier	0xA3C0
-#define	reg_tpsd_hier_pos 4
-#define	reg_tpsd_hier_len 3
-#define	reg_tpsd_hier_lsb 0
-#define xd_g_reg_bw	0xA3C1
-#define	reg_bw_pos 2
-#define	reg_bw_len 2
-#define	reg_bw_lsb 0
-#define xd_g_reg_dec_pri	0xA3C1
-#define	reg_dec_pri_pos 4
-#define	reg_dec_pri_len 1
-#define	reg_dec_pri_lsb 0
-#define xd_g_reg_tpsd_const	0xA3C1
-#define	reg_tpsd_const_pos 6
-#define	reg_tpsd_const_len 2
-#define	reg_tpsd_const_lsb 0
-#define xd_g_reg_tpsd_hpcr	0xA3C2
-#define	reg_tpsd_hpcr_pos 0
-#define	reg_tpsd_hpcr_len 3
-#define	reg_tpsd_hpcr_lsb 0
-#define xd_g_reg_tpsd_lpcr	0xA3C2
-#define	reg_tpsd_lpcr_pos 3
-#define	reg_tpsd_lpcr_len 3
-#define	reg_tpsd_lpcr_lsb 0
-#define xd_g_reg_ofsm_clk	0xA3D0
-#define	reg_ofsm_clk_pos 0
-#define	reg_ofsm_clk_len 3
-#define	reg_ofsm_clk_lsb 0
-#define xd_g_reg_fclk_cfg	0xA3D1
-#define	reg_fclk_cfg_pos 0
-#define	reg_fclk_cfg_len 1
-#define	reg_fclk_cfg_lsb 0
-#define xd_g_reg_fclk_idi	0xA3D1
-#define	reg_fclk_idi_pos 1
-#define	reg_fclk_idi_len 1
-#define	reg_fclk_idi_lsb 0
-#define xd_g_reg_fclk_odi	0xA3D1
-#define	reg_fclk_odi_pos 2
-#define	reg_fclk_odi_len 1
-#define	reg_fclk_odi_lsb 0
-#define xd_g_reg_fclk_rsd	0xA3D1
-#define	reg_fclk_rsd_pos 3
-#define	reg_fclk_rsd_len 1
-#define	reg_fclk_rsd_lsb 0
-#define xd_g_reg_fclk_vtb	0xA3D1
-#define	reg_fclk_vtb_pos 4
-#define	reg_fclk_vtb_len 1
-#define	reg_fclk_vtb_lsb 0
-#define xd_g_reg_fclk_cste	0xA3D1
-#define	reg_fclk_cste_pos 5
-#define	reg_fclk_cste_len 1
-#define	reg_fclk_cste_lsb 0
-#define xd_g_reg_fclk_mp2if	0xA3D1
-#define	reg_fclk_mp2if_pos 6
-#define	reg_fclk_mp2if_len 1
-#define	reg_fclk_mp2if_lsb 0
-#define xd_I2C_i2c_m_slave_addr	0xA400
-#define	i2c_m_slave_addr_pos 0
-#define	i2c_m_slave_addr_len 8
-#define	i2c_m_slave_addr_lsb 0
-#define xd_I2C_i2c_m_data1	0xA401
-#define	i2c_m_data1_pos 0
-#define	i2c_m_data1_len 8
-#define	i2c_m_data1_lsb 0
-#define xd_I2C_i2c_m_data2	0xA402
-#define	i2c_m_data2_pos 0
-#define	i2c_m_data2_len 8
-#define	i2c_m_data2_lsb 0
-#define xd_I2C_i2c_m_data3	0xA403
-#define	i2c_m_data3_pos 0
-#define	i2c_m_data3_len 8
-#define	i2c_m_data3_lsb 0
-#define xd_I2C_i2c_m_data4	0xA404
-#define	i2c_m_data4_pos 0
-#define	i2c_m_data4_len 8
-#define	i2c_m_data4_lsb 0
-#define xd_I2C_i2c_m_data5	0xA405
-#define	i2c_m_data5_pos 0
-#define	i2c_m_data5_len 8
-#define	i2c_m_data5_lsb 0
-#define xd_I2C_i2c_m_data6	0xA406
-#define	i2c_m_data6_pos 0
-#define	i2c_m_data6_len 8
-#define	i2c_m_data6_lsb 0
-#define xd_I2C_i2c_m_data7	0xA407
-#define	i2c_m_data7_pos 0
-#define	i2c_m_data7_len 8
-#define	i2c_m_data7_lsb 0
-#define xd_I2C_i2c_m_data8	0xA408
-#define	i2c_m_data8_pos 0
-#define	i2c_m_data8_len 8
-#define	i2c_m_data8_lsb 0
-#define xd_I2C_i2c_m_data9	0xA409
-#define	i2c_m_data9_pos 0
-#define	i2c_m_data9_len 8
-#define	i2c_m_data9_lsb 0
-#define xd_I2C_i2c_m_data10	0xA40A
-#define	i2c_m_data10_pos 0
-#define	i2c_m_data10_len 8
-#define	i2c_m_data10_lsb 0
-#define xd_I2C_i2c_m_data11	0xA40B
-#define	i2c_m_data11_pos 0
-#define	i2c_m_data11_len 8
-#define	i2c_m_data11_lsb 0
-#define xd_I2C_i2c_m_cmd_rw	0xA40C
-#define	i2c_m_cmd_rw_pos 0
-#define	i2c_m_cmd_rw_len 1
-#define	i2c_m_cmd_rw_lsb 0
-#define xd_I2C_i2c_m_cmd_rwlen	0xA40C
-#define	i2c_m_cmd_rwlen_pos 3
-#define	i2c_m_cmd_rwlen_len 4
-#define	i2c_m_cmd_rwlen_lsb 0
-#define xd_I2C_i2c_m_status_cmd_exe	0xA40D
-#define	i2c_m_status_cmd_exe_pos 0
-#define	i2c_m_status_cmd_exe_len 1
-#define	i2c_m_status_cmd_exe_lsb 0
-#define xd_I2C_i2c_m_status_wdat_done	0xA40D
-#define	i2c_m_status_wdat_done_pos 1
-#define	i2c_m_status_wdat_done_len 1
-#define	i2c_m_status_wdat_done_lsb 0
-#define xd_I2C_i2c_m_status_wdat_fail	0xA40D
-#define	i2c_m_status_wdat_fail_pos 2
-#define	i2c_m_status_wdat_fail_len 1
-#define	i2c_m_status_wdat_fail_lsb 0
-#define xd_I2C_i2c_m_period	0xA40E
-#define	i2c_m_period_pos 0
-#define	i2c_m_period_len 8
-#define	i2c_m_period_lsb 0
-#define xd_I2C_i2c_m_reg_msb_lsb	0xA40F
-#define	i2c_m_reg_msb_lsb_pos 0
-#define	i2c_m_reg_msb_lsb_len 1
-#define	i2c_m_reg_msb_lsb_lsb 0
-#define xd_I2C_reg_ofdm_rst	0xA40F
-#define	reg_ofdm_rst_pos 1
-#define	reg_ofdm_rst_len 1
-#define	reg_ofdm_rst_lsb 0
-#define xd_I2C_reg_sample_period_on_tuner	0xA40F
-#define	reg_sample_period_on_tuner_pos 2
-#define	reg_sample_period_on_tuner_len 1
-#define	reg_sample_period_on_tuner_lsb 0
-#define xd_I2C_reg_rst_i2c	0xA40F
-#define	reg_rst_i2c_pos 3
-#define	reg_rst_i2c_len 1
-#define	reg_rst_i2c_lsb 0
-#define xd_I2C_reg_ofdm_rst_en	0xA40F
-#define	reg_ofdm_rst_en_pos 4
-#define	reg_ofdm_rst_en_len 1
-#define	reg_ofdm_rst_en_lsb 0
-#define xd_I2C_reg_tuner_sda_sync_on	0xA40F
-#define	reg_tuner_sda_sync_on_pos 5
-#define	reg_tuner_sda_sync_on_len 1
-#define	reg_tuner_sda_sync_on_lsb 0
-#define xd_p_mp2if_data_access_disable_ofsm	0xA500
-#define	mp2if_data_access_disable_ofsm_pos 0
-#define	mp2if_data_access_disable_ofsm_len 1
-#define	mp2if_data_access_disable_ofsm_lsb 0
-#define xd_p_reg_mp2_sw_rst_ofsm	0xA500
-#define	reg_mp2_sw_rst_ofsm_pos 1
-#define	reg_mp2_sw_rst_ofsm_len 1
-#define	reg_mp2_sw_rst_ofsm_lsb 0
-#define xd_p_reg_mp2if_clk_en_ofsm	0xA500
-#define	reg_mp2if_clk_en_ofsm_pos 2
-#define	reg_mp2if_clk_en_ofsm_len 1
-#define	reg_mp2if_clk_en_ofsm_lsb 0
-#define xd_r_mp2if_sync_byte_locked	0xA500
-#define	mp2if_sync_byte_locked_pos 3
-#define	mp2if_sync_byte_locked_len 1
-#define	mp2if_sync_byte_locked_lsb 0
-#define xd_r_mp2if_ts_not_188	0xA500
-#define	mp2if_ts_not_188_pos 4
-#define	mp2if_ts_not_188_len 1
-#define	mp2if_ts_not_188_lsb 0
-#define xd_r_mp2if_psb_empty	0xA500
-#define	mp2if_psb_empty_pos 5
-#define	mp2if_psb_empty_len 1
-#define	mp2if_psb_empty_lsb 0
-#define xd_r_mp2if_psb_overflow	0xA500
-#define	mp2if_psb_overflow_pos 6
-#define	mp2if_psb_overflow_len 1
-#define	mp2if_psb_overflow_lsb 0
-#define xd_p_mp2if_keep_sf_sync_byte_ofsm	0xA500
-#define	mp2if_keep_sf_sync_byte_ofsm_pos 7
-#define	mp2if_keep_sf_sync_byte_ofsm_len 1
-#define	mp2if_keep_sf_sync_byte_ofsm_lsb 0
-#define xd_r_mp2if_psb_mp2if_num_pkt	0xA501
-#define	mp2if_psb_mp2if_num_pkt_pos 0
-#define	mp2if_psb_mp2if_num_pkt_len 6
-#define	mp2if_psb_mp2if_num_pkt_lsb 0
-#define xd_p_reg_mpeg_full_speed_ofsm	0xA501
-#define	reg_mpeg_full_speed_ofsm_pos 6
-#define	reg_mpeg_full_speed_ofsm_len 1
-#define	reg_mpeg_full_speed_ofsm_lsb 0
-#define xd_p_mp2if_mpeg_ser_mode_ofsm	0xA501
-#define	mp2if_mpeg_ser_mode_ofsm_pos 7
-#define	mp2if_mpeg_ser_mode_ofsm_len 1
-#define	mp2if_mpeg_ser_mode_ofsm_lsb 0
-#define xd_p_reg_sw_mon51	0xA600
-#define	reg_sw_mon51_pos 0
-#define	reg_sw_mon51_len 8
-#define	reg_sw_mon51_lsb 0
-#define xd_p_reg_top_pcsel	0xA601
-#define	reg_top_pcsel_pos 0
-#define	reg_top_pcsel_len 1
-#define	reg_top_pcsel_lsb 0
-#define xd_p_reg_top_rs232	0xA601
-#define	reg_top_rs232_pos 1
-#define	reg_top_rs232_len 1
-#define	reg_top_rs232_lsb 0
-#define xd_p_reg_top_pcout	0xA601
-#define	reg_top_pcout_pos 2
-#define	reg_top_pcout_len 1
-#define	reg_top_pcout_lsb 0
-#define xd_p_reg_top_debug	0xA601
-#define	reg_top_debug_pos 3
-#define	reg_top_debug_len 1
-#define	reg_top_debug_lsb 0
-#define xd_p_reg_top_adcdly	0xA601
-#define	reg_top_adcdly_pos 4
-#define	reg_top_adcdly_len 2
-#define	reg_top_adcdly_lsb 0
-#define xd_p_reg_top_pwrdw	0xA601
-#define	reg_top_pwrdw_pos 6
-#define	reg_top_pwrdw_len 1
-#define	reg_top_pwrdw_lsb 0
-#define xd_p_reg_top_pwrdw_inv	0xA601
-#define	reg_top_pwrdw_inv_pos 7
-#define	reg_top_pwrdw_inv_len 1
-#define	reg_top_pwrdw_inv_lsb 0
-#define xd_p_reg_top_int_inv	0xA602
-#define	reg_top_int_inv_pos 0
-#define	reg_top_int_inv_len 1
-#define	reg_top_int_inv_lsb 0
-#define xd_p_reg_top_dio_sel	0xA602
-#define	reg_top_dio_sel_pos 1
-#define	reg_top_dio_sel_len 1
-#define	reg_top_dio_sel_lsb 0
-#define xd_p_reg_top_gpioon0	0xA603
-#define	reg_top_gpioon0_pos 0
-#define	reg_top_gpioon0_len 1
-#define	reg_top_gpioon0_lsb 0
-#define xd_p_reg_top_gpioon1	0xA603
-#define	reg_top_gpioon1_pos 1
-#define	reg_top_gpioon1_len 1
-#define	reg_top_gpioon1_lsb 0
-#define xd_p_reg_top_gpioon2	0xA603
-#define	reg_top_gpioon2_pos 2
-#define	reg_top_gpioon2_len 1
-#define	reg_top_gpioon2_lsb 0
-#define xd_p_reg_top_gpioon3	0xA603
-#define	reg_top_gpioon3_pos 3
-#define	reg_top_gpioon3_len 1
-#define	reg_top_gpioon3_lsb 0
-#define xd_p_reg_top_lockon1	0xA603
-#define	reg_top_lockon1_pos 4
-#define	reg_top_lockon1_len 1
-#define	reg_top_lockon1_lsb 0
-#define xd_p_reg_top_lockon2	0xA603
-#define	reg_top_lockon2_pos 5
-#define	reg_top_lockon2_len 1
-#define	reg_top_lockon2_lsb 0
-#define xd_p_reg_top_gpioo0	0xA604
-#define	reg_top_gpioo0_pos 0
-#define	reg_top_gpioo0_len 1
-#define	reg_top_gpioo0_lsb 0
-#define xd_p_reg_top_gpioo1	0xA604
-#define	reg_top_gpioo1_pos 1
-#define	reg_top_gpioo1_len 1
-#define	reg_top_gpioo1_lsb 0
-#define xd_p_reg_top_gpioo2	0xA604
-#define	reg_top_gpioo2_pos 2
-#define	reg_top_gpioo2_len 1
-#define	reg_top_gpioo2_lsb 0
-#define xd_p_reg_top_gpioo3	0xA604
-#define	reg_top_gpioo3_pos 3
-#define	reg_top_gpioo3_len 1
-#define	reg_top_gpioo3_lsb 0
-#define xd_p_reg_top_lock1	0xA604
-#define	reg_top_lock1_pos 4
-#define	reg_top_lock1_len 1
-#define	reg_top_lock1_lsb 0
-#define xd_p_reg_top_lock2	0xA604
-#define	reg_top_lock2_pos 5
-#define	reg_top_lock2_len 1
-#define	reg_top_lock2_lsb 0
-#define xd_p_reg_top_gpioen0	0xA605
-#define	reg_top_gpioen0_pos 0
-#define	reg_top_gpioen0_len 1
-#define	reg_top_gpioen0_lsb 0
-#define xd_p_reg_top_gpioen1	0xA605
-#define	reg_top_gpioen1_pos 1
-#define	reg_top_gpioen1_len 1
-#define	reg_top_gpioen1_lsb 0
-#define xd_p_reg_top_gpioen2	0xA605
-#define	reg_top_gpioen2_pos 2
-#define	reg_top_gpioen2_len 1
-#define	reg_top_gpioen2_lsb 0
-#define xd_p_reg_top_gpioen3	0xA605
-#define	reg_top_gpioen3_pos 3
-#define	reg_top_gpioen3_len 1
-#define	reg_top_gpioen3_lsb 0
-#define xd_p_reg_top_locken1	0xA605
-#define	reg_top_locken1_pos 4
-#define	reg_top_locken1_len 1
-#define	reg_top_locken1_lsb 0
-#define xd_p_reg_top_locken2	0xA605
-#define	reg_top_locken2_pos 5
-#define	reg_top_locken2_len 1
-#define	reg_top_locken2_lsb 0
-#define xd_r_reg_top_gpioi0	0xA606
-#define	reg_top_gpioi0_pos 0
-#define	reg_top_gpioi0_len 1
-#define	reg_top_gpioi0_lsb 0
-#define xd_r_reg_top_gpioi1	0xA606
-#define	reg_top_gpioi1_pos 1
-#define	reg_top_gpioi1_len 1
-#define	reg_top_gpioi1_lsb 0
-#define xd_r_reg_top_gpioi2	0xA606
-#define	reg_top_gpioi2_pos 2
-#define	reg_top_gpioi2_len 1
-#define	reg_top_gpioi2_lsb 0
-#define xd_r_reg_top_gpioi3	0xA606
-#define	reg_top_gpioi3_pos 3
-#define	reg_top_gpioi3_len 1
-#define	reg_top_gpioi3_lsb 0
-#define xd_r_reg_top_locki1	0xA606
-#define	reg_top_locki1_pos 4
-#define	reg_top_locki1_len 1
-#define	reg_top_locki1_lsb 0
-#define xd_r_reg_top_locki2	0xA606
-#define	reg_top_locki2_pos 5
-#define	reg_top_locki2_len 1
-#define	reg_top_locki2_lsb 0
-#define xd_p_reg_dummy_7_0	0xA608
-#define	reg_dummy_7_0_pos 0
-#define	reg_dummy_7_0_len 8
-#define	reg_dummy_7_0_lsb 0
-#define xd_p_reg_dummy_15_8	0xA609
-#define	reg_dummy_15_8_pos 0
-#define	reg_dummy_15_8_len 8
-#define	reg_dummy_15_8_lsb 8
-#define xd_p_reg_dummy_23_16	0xA60A
-#define	reg_dummy_23_16_pos 0
-#define	reg_dummy_23_16_len 8
-#define	reg_dummy_23_16_lsb 16
-#define xd_p_reg_dummy_31_24	0xA60B
-#define	reg_dummy_31_24_pos 0
-#define	reg_dummy_31_24_len 8
-#define	reg_dummy_31_24_lsb 24
-#define xd_p_reg_dummy_39_32	0xA60C
-#define	reg_dummy_39_32_pos 0
-#define	reg_dummy_39_32_len 8
-#define	reg_dummy_39_32_lsb 32
-#define xd_p_reg_dummy_47_40	0xA60D
-#define	reg_dummy_47_40_pos 0
-#define	reg_dummy_47_40_len 8
-#define	reg_dummy_47_40_lsb 40
-#define xd_p_reg_dummy_55_48	0xA60E
-#define	reg_dummy_55_48_pos 0
-#define	reg_dummy_55_48_len 8
-#define	reg_dummy_55_48_lsb 48
-#define xd_p_reg_dummy_63_56	0xA60F
-#define	reg_dummy_63_56_pos 0
-#define	reg_dummy_63_56_len 8
-#define	reg_dummy_63_56_lsb 56
-#define xd_p_reg_dummy_71_64	0xA610
-#define	reg_dummy_71_64_pos 0
-#define	reg_dummy_71_64_len 8
-#define	reg_dummy_71_64_lsb 64
-#define xd_p_reg_dummy_79_72	0xA611
-#define	reg_dummy_79_72_pos 0
-#define	reg_dummy_79_72_len 8
-#define	reg_dummy_79_72_lsb 72
-#define xd_p_reg_dummy_87_80	0xA612
-#define	reg_dummy_87_80_pos 0
-#define	reg_dummy_87_80_len 8
-#define	reg_dummy_87_80_lsb 80
-#define xd_p_reg_dummy_95_88	0xA613
-#define	reg_dummy_95_88_pos 0
-#define	reg_dummy_95_88_len 8
-#define	reg_dummy_95_88_lsb 88
-#define xd_p_reg_dummy_103_96	0xA614
-#define	reg_dummy_103_96_pos 0
-#define	reg_dummy_103_96_len 8
-#define	reg_dummy_103_96_lsb 96
-
-#define xd_p_reg_unplug_flag	0xA615
-#define	reg_unplug_flag_pos 0
-#define	reg_unplug_flag_len 1
-#define	reg_unplug_flag_lsb 104
-
-#define xd_p_reg_api_dca_stes_request   0xA615
-#define reg_api_dca_stes_request_pos 1
-#define reg_api_dca_stes_request_len 1
-#define reg_api_dca_stes_request_lsb 0
-
-#define xd_p_reg_back_to_dca_flag	0xA615
-#define	reg_back_to_dca_flag_pos 2
-#define	reg_back_to_dca_flag_len 1
-#define	reg_back_to_dca_flag_lsb 106
-
-#define xd_p_reg_api_retrain_request    0xA615
-#define reg_api_retrain_request_pos 3
-#define reg_api_retrain_request_len 1
-#define reg_api_retrain_request_lsb 0
-
-#define xd_p_reg_Dyn_Top_Try_flag	0xA615
-#define	reg_Dyn_Top_Try_flag_pos 3
-#define	reg_Dyn_Top_Try_flag_len 1
-#define	reg_Dyn_Top_Try_flag_lsb 107
-
-#define xd_p_reg_API_retrain_freeze_flag	0xA615
-#define	reg_API_retrain_freeze_flag_pos 4
-#define	reg_API_retrain_freeze_flag_len 1
-#define	reg_API_retrain_freeze_flag_lsb 108
-
-#define xd_p_reg_dummy_111_104	0xA615
-#define	reg_dummy_111_104_pos 0
-#define	reg_dummy_111_104_len 8
-#define	reg_dummy_111_104_lsb 104
-#define xd_p_reg_dummy_119_112	0xA616
-#define	reg_dummy_119_112_pos 0
-#define	reg_dummy_119_112_len 8
-#define	reg_dummy_119_112_lsb 112
-#define xd_p_reg_dummy_127_120	0xA617
-#define	reg_dummy_127_120_pos 0
-#define	reg_dummy_127_120_len 8
-#define	reg_dummy_127_120_lsb 120
-#define xd_p_reg_dummy_135_128	0xA618
-#define	reg_dummy_135_128_pos 0
-#define	reg_dummy_135_128_len 8
-#define	reg_dummy_135_128_lsb 128
-
-#define xd_p_reg_dummy_143_136	0xA619
-#define	reg_dummy_143_136_pos 0
-#define	reg_dummy_143_136_len 8
-#define	reg_dummy_143_136_lsb 136
-
-#define xd_p_reg_CCIR_dis	0xA619
-#define	reg_CCIR_dis_pos 0
-#define	reg_CCIR_dis_len 1
-#define	reg_CCIR_dis_lsb 0
-
-#define xd_p_reg_dummy_151_144	0xA61A
-#define	reg_dummy_151_144_pos 0
-#define	reg_dummy_151_144_len 8
-#define	reg_dummy_151_144_lsb 144
-
-#define xd_p_reg_dummy_159_152	0xA61B
-#define	reg_dummy_159_152_pos 0
-#define	reg_dummy_159_152_len 8
-#define	reg_dummy_159_152_lsb 152
-
-#define xd_p_reg_dummy_167_160	0xA61C
-#define	reg_dummy_167_160_pos 0
-#define	reg_dummy_167_160_len 8
-#define	reg_dummy_167_160_lsb 160
-
-#define xd_p_reg_dummy_175_168	0xA61D
-#define	reg_dummy_175_168_pos 0
-#define	reg_dummy_175_168_len 8
-#define	reg_dummy_175_168_lsb 168
-
-#define xd_p_reg_dummy_183_176	0xA61E
-#define	reg_dummy_183_176_pos 0
-#define	reg_dummy_183_176_len 8
-#define	reg_dummy_183_176_lsb 176
-
-#define xd_p_reg_ofsm_read_rbc_en  0xA61E
-#define reg_ofsm_read_rbc_en_pos 2
-#define reg_ofsm_read_rbc_en_len 1
-#define reg_ofsm_read_rbc_en_lsb 0
-
-#define xd_p_reg_ce_filter_selection_dis  0xA61E
-#define reg_ce_filter_selection_dis_pos 1
-#define reg_ce_filter_selection_dis_len 1
-#define reg_ce_filter_selection_dis_lsb 0
-
-#define xd_p_reg_OFSM_version_control_7_0  0xA611
-#define reg_OFSM_version_control_7_0_pos 0
-#define reg_OFSM_version_control_7_0_len 8
-#define reg_OFSM_version_control_7_0_lsb 0
-
-#define xd_p_reg_OFSM_version_control_15_8  0xA61F
-#define reg_OFSM_version_control_15_8_pos 0
-#define reg_OFSM_version_control_15_8_len 8
-#define reg_OFSM_version_control_15_8_lsb 0
-
-#define xd_p_reg_OFSM_version_control_23_16  0xA620
-#define reg_OFSM_version_control_23_16_pos 0
-#define reg_OFSM_version_control_23_16_len 8
-#define reg_OFSM_version_control_23_16_lsb 0
-
-#define xd_p_reg_dummy_191_184	0xA61F
-#define	reg_dummy_191_184_pos 0
-#define	reg_dummy_191_184_len 8
-#define	reg_dummy_191_184_lsb 184
-
-#define xd_p_reg_dummy_199_192	0xA620
-#define	reg_dummy_199_192_pos 0
-#define	reg_dummy_199_192_len 8
-#define	reg_dummy_199_192_lsb 192
-
-#define xd_p_reg_ce_en	0xABC0
-#define	reg_ce_en_pos 0
-#define	reg_ce_en_len 1
-#define	reg_ce_en_lsb 0
-#define xd_p_reg_ce_fctrl_en	0xABC0
-#define	reg_ce_fctrl_en_pos 1
-#define	reg_ce_fctrl_en_len 1
-#define	reg_ce_fctrl_en_lsb 0
-#define xd_p_reg_ce_fste_tdi	0xABC0
-#define	reg_ce_fste_tdi_pos 2
-#define	reg_ce_fste_tdi_len 1
-#define	reg_ce_fste_tdi_lsb 0
-#define xd_p_reg_ce_dynamic	0xABC0
-#define	reg_ce_dynamic_pos 3
-#define	reg_ce_dynamic_len 1
-#define	reg_ce_dynamic_lsb 0
-#define xd_p_reg_ce_conf	0xABC0
-#define	reg_ce_conf_pos 4
-#define	reg_ce_conf_len 2
-#define	reg_ce_conf_lsb 0
-#define xd_p_reg_ce_dyn12	0xABC0
-#define	reg_ce_dyn12_pos 6
-#define	reg_ce_dyn12_len 1
-#define	reg_ce_dyn12_lsb 0
-#define xd_p_reg_ce_derot_en	0xABC0
-#define	reg_ce_derot_en_pos 7
-#define	reg_ce_derot_en_len 1
-#define	reg_ce_derot_en_lsb 0
-#define xd_p_reg_ce_dynamic_th_7_0	0xABC1
-#define	reg_ce_dynamic_th_7_0_pos 0
-#define	reg_ce_dynamic_th_7_0_len 8
-#define	reg_ce_dynamic_th_7_0_lsb 0
-#define xd_p_reg_ce_dynamic_th_15_8	0xABC2
-#define	reg_ce_dynamic_th_15_8_pos 0
-#define	reg_ce_dynamic_th_15_8_len 8
-#define	reg_ce_dynamic_th_15_8_lsb 8
-#define xd_p_reg_ce_s1	0xABC3
-#define	reg_ce_s1_pos 0
-#define	reg_ce_s1_len 5
-#define	reg_ce_s1_lsb 0
-#define xd_p_reg_ce_var_forced_value	0xABC3
-#define	reg_ce_var_forced_value_pos 5
-#define	reg_ce_var_forced_value_len 3
-#define	reg_ce_var_forced_value_lsb 0
-#define xd_p_reg_ce_data_im_7_0	0xABC4
-#define	reg_ce_data_im_7_0_pos 0
-#define	reg_ce_data_im_7_0_len 8
-#define	reg_ce_data_im_7_0_lsb 0
-#define xd_p_reg_ce_data_im_8	0xABC5
-#define	reg_ce_data_im_8_pos 0
-#define	reg_ce_data_im_8_len 1
-#define	reg_ce_data_im_8_lsb 0
-#define xd_p_reg_ce_data_re_6_0	0xABC5
-#define	reg_ce_data_re_6_0_pos 1
-#define	reg_ce_data_re_6_0_len 7
-#define	reg_ce_data_re_6_0_lsb 0
-#define xd_p_reg_ce_data_re_8_7	0xABC6
-#define	reg_ce_data_re_8_7_pos 0
-#define	reg_ce_data_re_8_7_len 2
-#define	reg_ce_data_re_8_7_lsb 7
-#define xd_p_reg_ce_tone_5_0	0xABC6
-#define	reg_ce_tone_5_0_pos 2
-#define	reg_ce_tone_5_0_len 6
-#define	reg_ce_tone_5_0_lsb 0
-#define xd_p_reg_ce_tone_12_6	0xABC7
-#define	reg_ce_tone_12_6_pos 0
-#define	reg_ce_tone_12_6_len 7
-#define	reg_ce_tone_12_6_lsb 6
-#define xd_p_reg_ce_centroid_drift_th	0xABC8
-#define	reg_ce_centroid_drift_th_pos 0
-#define	reg_ce_centroid_drift_th_len 8
-#define	reg_ce_centroid_drift_th_lsb 0
-#define xd_p_reg_ce_centroid_count_max	0xABC9
-#define	reg_ce_centroid_count_max_pos 0
-#define	reg_ce_centroid_count_max_len 4
-#define	reg_ce_centroid_count_max_lsb 0
-#define xd_p_reg_ce_centroid_bias_inc_7_0	0xABCA
-#define	reg_ce_centroid_bias_inc_7_0_pos 0
-#define	reg_ce_centroid_bias_inc_7_0_len 8
-#define	reg_ce_centroid_bias_inc_7_0_lsb 0
-#define xd_p_reg_ce_centroid_bias_inc_8	0xABCB
-#define	reg_ce_centroid_bias_inc_8_pos 0
-#define	reg_ce_centroid_bias_inc_8_len 1
-#define	reg_ce_centroid_bias_inc_8_lsb 0
-#define xd_p_reg_ce_var_th0_7_0	0xABCC
-#define	reg_ce_var_th0_7_0_pos 0
-#define	reg_ce_var_th0_7_0_len 8
-#define	reg_ce_var_th0_7_0_lsb 0
-#define xd_p_reg_ce_var_th0_15_8	0xABCD
-#define	reg_ce_var_th0_15_8_pos 0
-#define	reg_ce_var_th0_15_8_len 8
-#define	reg_ce_var_th0_15_8_lsb 8
-#define xd_p_reg_ce_var_th1_7_0	0xABCE
-#define	reg_ce_var_th1_7_0_pos 0
-#define	reg_ce_var_th1_7_0_len 8
-#define	reg_ce_var_th1_7_0_lsb 0
-#define xd_p_reg_ce_var_th1_15_8	0xABCF
-#define	reg_ce_var_th1_15_8_pos 0
-#define	reg_ce_var_th1_15_8_len 8
-#define	reg_ce_var_th1_15_8_lsb 8
-#define xd_p_reg_ce_var_th2_7_0	0xABD0
-#define	reg_ce_var_th2_7_0_pos 0
-#define	reg_ce_var_th2_7_0_len 8
-#define	reg_ce_var_th2_7_0_lsb 0
-#define xd_p_reg_ce_var_th2_15_8	0xABD1
-#define	reg_ce_var_th2_15_8_pos 0
-#define	reg_ce_var_th2_15_8_len 8
-#define	reg_ce_var_th2_15_8_lsb 8
-#define xd_p_reg_ce_var_th3_7_0	0xABD2
-#define	reg_ce_var_th3_7_0_pos 0
-#define	reg_ce_var_th3_7_0_len 8
-#define	reg_ce_var_th3_7_0_lsb 0
-#define xd_p_reg_ce_var_th3_15_8	0xABD3
-#define	reg_ce_var_th3_15_8_pos 0
-#define	reg_ce_var_th3_15_8_len 8
-#define	reg_ce_var_th3_15_8_lsb 8
-#define xd_p_reg_ce_var_th4_7_0	0xABD4
-#define	reg_ce_var_th4_7_0_pos 0
-#define	reg_ce_var_th4_7_0_len 8
-#define	reg_ce_var_th4_7_0_lsb 0
-#define xd_p_reg_ce_var_th4_15_8	0xABD5
-#define	reg_ce_var_th4_15_8_pos 0
-#define	reg_ce_var_th4_15_8_len 8
-#define	reg_ce_var_th4_15_8_lsb 8
-#define xd_p_reg_ce_var_th5_7_0	0xABD6
-#define	reg_ce_var_th5_7_0_pos 0
-#define	reg_ce_var_th5_7_0_len 8
-#define	reg_ce_var_th5_7_0_lsb 0
-#define xd_p_reg_ce_var_th5_15_8	0xABD7
-#define	reg_ce_var_th5_15_8_pos 0
-#define	reg_ce_var_th5_15_8_len 8
-#define	reg_ce_var_th5_15_8_lsb 8
-#define xd_p_reg_ce_var_th6_7_0	0xABD8
-#define	reg_ce_var_th6_7_0_pos 0
-#define	reg_ce_var_th6_7_0_len 8
-#define	reg_ce_var_th6_7_0_lsb 0
-#define xd_p_reg_ce_var_th6_15_8	0xABD9
-#define	reg_ce_var_th6_15_8_pos 0
-#define	reg_ce_var_th6_15_8_len 8
-#define	reg_ce_var_th6_15_8_lsb 8
-#define xd_p_reg_ce_fctrl_reset	0xABDA
-#define	reg_ce_fctrl_reset_pos 0
-#define	reg_ce_fctrl_reset_len 1
-#define	reg_ce_fctrl_reset_lsb 0
-#define xd_p_reg_ce_cent_auto_clr_en	0xABDA
-#define	reg_ce_cent_auto_clr_en_pos 1
-#define	reg_ce_cent_auto_clr_en_len 1
-#define	reg_ce_cent_auto_clr_en_lsb 0
-#define xd_p_reg_ce_fctrl_auto_reset_en	0xABDA
-#define	reg_ce_fctrl_auto_reset_en_pos 2
-#define	reg_ce_fctrl_auto_reset_en_len 1
-#define	reg_ce_fctrl_auto_reset_en_lsb 0
-#define xd_p_reg_ce_var_forced_en	0xABDA
-#define	reg_ce_var_forced_en_pos 3
-#define	reg_ce_var_forced_en_len 1
-#define	reg_ce_var_forced_en_lsb 0
-#define xd_p_reg_ce_cent_forced_en	0xABDA
-#define	reg_ce_cent_forced_en_pos 4
-#define	reg_ce_cent_forced_en_len 1
-#define	reg_ce_cent_forced_en_lsb 0
-#define xd_p_reg_ce_var_max	0xABDA
-#define	reg_ce_var_max_pos 5
-#define	reg_ce_var_max_len 3
-#define	reg_ce_var_max_lsb 0
-#define xd_p_reg_ce_cent_forced_value_7_0	0xABDB
-#define	reg_ce_cent_forced_value_7_0_pos 0
-#define	reg_ce_cent_forced_value_7_0_len 8
-#define	reg_ce_cent_forced_value_7_0_lsb 0
-#define xd_p_reg_ce_cent_forced_value_11_8	0xABDC
-#define	reg_ce_cent_forced_value_11_8_pos 0
-#define	reg_ce_cent_forced_value_11_8_len 4
-#define	reg_ce_cent_forced_value_11_8_lsb 8
-#define xd_p_reg_ce_fctrl_rd	0xABDD
-#define	reg_ce_fctrl_rd_pos 0
-#define	reg_ce_fctrl_rd_len 1
-#define	reg_ce_fctrl_rd_lsb 0
-#define xd_p_reg_ce_centroid_max_6_0	0xABDD
-#define	reg_ce_centroid_max_6_0_pos 1
-#define	reg_ce_centroid_max_6_0_len 7
-#define	reg_ce_centroid_max_6_0_lsb 0
-#define xd_p_reg_ce_centroid_max_11_7	0xABDE
-#define	reg_ce_centroid_max_11_7_pos 0
-#define	reg_ce_centroid_max_11_7_len 5
-#define	reg_ce_centroid_max_11_7_lsb 7
-#define xd_p_reg_ce_var	0xABDF
-#define	reg_ce_var_pos 0
-#define	reg_ce_var_len 3
-#define	reg_ce_var_lsb 0
-#define xd_p_reg_ce_fctrl_rdy	0xABDF
-#define	reg_ce_fctrl_rdy_pos 3
-#define	reg_ce_fctrl_rdy_len 1
-#define	reg_ce_fctrl_rdy_lsb 0
-#define xd_p_reg_ce_centroid_out_3_0	0xABDF
-#define	reg_ce_centroid_out_3_0_pos 4
-#define	reg_ce_centroid_out_3_0_len 4
-#define	reg_ce_centroid_out_3_0_lsb 0
-#define xd_p_reg_ce_centroid_out_11_4	0xABE0
-#define	reg_ce_centroid_out_11_4_pos 0
-#define	reg_ce_centroid_out_11_4_len 8
-#define	reg_ce_centroid_out_11_4_lsb 4
-#define xd_p_reg_ce_bias_7_0	0xABE1
-#define	reg_ce_bias_7_0_pos 0
-#define	reg_ce_bias_7_0_len 8
-#define	reg_ce_bias_7_0_lsb 0
-#define xd_p_reg_ce_bias_11_8	0xABE2
-#define	reg_ce_bias_11_8_pos 0
-#define	reg_ce_bias_11_8_len 4
-#define	reg_ce_bias_11_8_lsb 8
-#define xd_p_reg_ce_m1_3_0	0xABE2
-#define	reg_ce_m1_3_0_pos 4
-#define	reg_ce_m1_3_0_len 4
-#define	reg_ce_m1_3_0_lsb 0
-#define xd_p_reg_ce_m1_11_4	0xABE3
-#define	reg_ce_m1_11_4_pos 0
-#define	reg_ce_m1_11_4_len 8
-#define	reg_ce_m1_11_4_lsb 4
-#define xd_p_reg_ce_rh0_7_0	0xABE4
-#define	reg_ce_rh0_7_0_pos 0
-#define	reg_ce_rh0_7_0_len 8
-#define	reg_ce_rh0_7_0_lsb 0
-#define xd_p_reg_ce_rh0_15_8	0xABE5
-#define	reg_ce_rh0_15_8_pos 0
-#define	reg_ce_rh0_15_8_len 8
-#define	reg_ce_rh0_15_8_lsb 8
-#define xd_p_reg_ce_rh0_23_16	0xABE6
-#define	reg_ce_rh0_23_16_pos 0
-#define	reg_ce_rh0_23_16_len 8
-#define	reg_ce_rh0_23_16_lsb 16
-#define xd_p_reg_ce_rh0_31_24	0xABE7
-#define	reg_ce_rh0_31_24_pos 0
-#define	reg_ce_rh0_31_24_len 8
-#define	reg_ce_rh0_31_24_lsb 24
-#define xd_p_reg_ce_rh3_real_7_0	0xABE8
-#define	reg_ce_rh3_real_7_0_pos 0
-#define	reg_ce_rh3_real_7_0_len 8
-#define	reg_ce_rh3_real_7_0_lsb 0
-#define xd_p_reg_ce_rh3_real_15_8	0xABE9
-#define	reg_ce_rh3_real_15_8_pos 0
-#define	reg_ce_rh3_real_15_8_len 8
-#define	reg_ce_rh3_real_15_8_lsb 8
-#define xd_p_reg_ce_rh3_real_23_16	0xABEA
-#define	reg_ce_rh3_real_23_16_pos 0
-#define	reg_ce_rh3_real_23_16_len 8
-#define	reg_ce_rh3_real_23_16_lsb 16
-#define xd_p_reg_ce_rh3_real_31_24	0xABEB
-#define	reg_ce_rh3_real_31_24_pos 0
-#define	reg_ce_rh3_real_31_24_len 8
-#define	reg_ce_rh3_real_31_24_lsb 24
-#define xd_p_reg_ce_rh3_imag_7_0	0xABEC
-#define	reg_ce_rh3_imag_7_0_pos 0
-#define	reg_ce_rh3_imag_7_0_len 8
-#define	reg_ce_rh3_imag_7_0_lsb 0
-#define xd_p_reg_ce_rh3_imag_15_8	0xABED
-#define	reg_ce_rh3_imag_15_8_pos 0
-#define	reg_ce_rh3_imag_15_8_len 8
-#define	reg_ce_rh3_imag_15_8_lsb 8
-#define xd_p_reg_ce_rh3_imag_23_16	0xABEE
-#define	reg_ce_rh3_imag_23_16_pos 0
-#define	reg_ce_rh3_imag_23_16_len 8
-#define	reg_ce_rh3_imag_23_16_lsb 16
-#define xd_p_reg_ce_rh3_imag_31_24	0xABEF
-#define	reg_ce_rh3_imag_31_24_pos 0
-#define	reg_ce_rh3_imag_31_24_len 8
-#define	reg_ce_rh3_imag_31_24_lsb 24
-#define xd_p_reg_feq_fix_eh2_7_0	0xABF0
-#define	reg_feq_fix_eh2_7_0_pos 0
-#define	reg_feq_fix_eh2_7_0_len 8
-#define	reg_feq_fix_eh2_7_0_lsb 0
-#define xd_p_reg_feq_fix_eh2_15_8	0xABF1
-#define	reg_feq_fix_eh2_15_8_pos 0
-#define	reg_feq_fix_eh2_15_8_len 8
-#define	reg_feq_fix_eh2_15_8_lsb 8
-#define xd_p_reg_feq_fix_eh2_23_16	0xABF2
-#define	reg_feq_fix_eh2_23_16_pos 0
-#define	reg_feq_fix_eh2_23_16_len 8
-#define	reg_feq_fix_eh2_23_16_lsb 16
-#define xd_p_reg_feq_fix_eh2_31_24	0xABF3
-#define	reg_feq_fix_eh2_31_24_pos 0
-#define	reg_feq_fix_eh2_31_24_len 8
-#define	reg_feq_fix_eh2_31_24_lsb 24
-#define xd_p_reg_ce_m2_central_7_0	0xABF4
-#define	reg_ce_m2_central_7_0_pos 0
-#define	reg_ce_m2_central_7_0_len 8
-#define	reg_ce_m2_central_7_0_lsb 0
-#define xd_p_reg_ce_m2_central_15_8	0xABF5
-#define	reg_ce_m2_central_15_8_pos 0
-#define	reg_ce_m2_central_15_8_len 8
-#define	reg_ce_m2_central_15_8_lsb 8
-#define xd_p_reg_ce_fftshift	0xABF6
-#define	reg_ce_fftshift_pos 0
-#define	reg_ce_fftshift_len 4
-#define	reg_ce_fftshift_lsb 0
-#define xd_p_reg_ce_fftshift1	0xABF6
-#define	reg_ce_fftshift1_pos 4
-#define	reg_ce_fftshift1_len 4
-#define	reg_ce_fftshift1_lsb 0
-#define xd_p_reg_ce_fftshift2	0xABF7
-#define	reg_ce_fftshift2_pos 0
-#define	reg_ce_fftshift2_len 4
-#define	reg_ce_fftshift2_lsb 0
-#define xd_p_reg_ce_top_mobile	0xABF7
-#define	reg_ce_top_mobile_pos 4
-#define	reg_ce_top_mobile_len 1
-#define	reg_ce_top_mobile_lsb 0
-#define xd_p_reg_strong_sginal_detected 0xA2BC
-#define reg_strong_sginal_detected_pos 2
-#define reg_strong_sginal_detected_len 1
-#define reg_strong_sginal_detected_lsb 0
-
-#define XD_MP2IF_BASE                           0xB000
-#define XD_MP2IF_CSR                        (0x00 + XD_MP2IF_BASE)
-#define XD_MP2IF_DMX_CTRL                       (0x03 + XD_MP2IF_BASE)
-#define XD_MP2IF_PID_IDX                        (0x04 + XD_MP2IF_BASE)
-#define XD_MP2IF_PID_DATA_L                     (0x05 + XD_MP2IF_BASE)
-#define XD_MP2IF_PID_DATA_H                     (0x06 + XD_MP2IF_BASE)
-#define XD_MP2IF_MISC                       (0x07 + XD_MP2IF_BASE)
-
-extern struct dvb_frontend *af9005_fe_attach(struct dvb_usb_device *d);
-extern int af9005_read_ofdm_register(struct dvb_usb_device *d, u16 reg,
-				     u8 * value);
-extern int af9005_read_ofdm_registers(struct dvb_usb_device *d, u16 reg,
-				      u8 * values, int len);
-extern int af9005_write_ofdm_register(struct dvb_usb_device *d, u16 reg,
-				      u8 value);
-extern int af9005_write_ofdm_registers(struct dvb_usb_device *d, u16 reg,
-				       u8 * values, int len);
-extern int af9005_read_tuner_registers(struct dvb_usb_device *d, u16 reg,
-				       u8 addr, u8 * values, int len);
-extern int af9005_write_tuner_registers(struct dvb_usb_device *d, u16 reg,
-					u8 * values, int len);
-extern int af9005_read_register_bits(struct dvb_usb_device *d, u16 reg,
-				     u8 pos, u8 len, u8 * value);
-extern int af9005_write_register_bits(struct dvb_usb_device *d, u16 reg,
-				      u8 pos, u8 len, u8 value);
-extern int af9005_send_command(struct dvb_usb_device *d, u8 command,
-			       u8 * wbuf, int wlen, u8 * rbuf, int rlen);
-extern int af9005_read_eeprom(struct dvb_usb_device *d, u8 address,
-			      u8 * values, int len);
-extern int af9005_tuner_attach(struct dvb_usb_adapter *adap);
-extern int af9005_led_control(struct dvb_usb_device *d, int onoff);
-
-extern u8 regmask[8];
-
-/* remote control decoder */
-extern int af9005_rc_decode(struct dvb_usb_device *d, u8 * data, int len,
-			    u32 * event, int *state);
-extern struct rc_map_table rc_map_af9005_table[];
-extern int rc_map_af9005_table_size;
-
-#endif
diff -ruN ../linux-4.14.336/drivers/net/Space.c ./drivers/net/Space.c
--- linux-4.14.336/../linux-4.14.336/drivers/net/Space.c	2024-01-10 14:45:41.000000000 +0100
+++ linux-4.14.336/./drivers/net/Space.c	2024-02-14 21:04:46.981594989 +0100
@@ -150,11 +150,6 @@
 	for (num = 0; num < 8; ++num)
 		ethif_probe2(num);
 
-#ifdef CONFIG_COPS
-	cops_probe(0);
-	cops_probe(1);
-	cops_probe(2);
-#endif
 #ifdef CONFIG_LTPC
 	ltpc_probe();
 #endif
diff -ruN ../linux-4.14.336/drivers/net/appletalk/Kconfig ./drivers/net/appletalk/Kconfig
--- linux-4.14.336/../linux-4.14.336/drivers/net/appletalk/Kconfig	2024-01-10 14:45:41.000000000 +0100
+++ linux-4.14.336/./drivers/net/appletalk/Kconfig	2024-02-14 21:04:25.861596249 +0100
@@ -49,32 +49,6 @@
 	  This driver is experimental, which means that it may not work.
 	  See the file <file:Documentation/networking/ltpc.txt>.
 
-config COPS
-	tristate "COPS LocalTalk PC support"
-	depends on DEV_APPLETALK && (ISA || EISA)
-	help
-	  This allows you to use COPS AppleTalk cards to connect to LocalTalk
-	  networks. You also need version 1.3.3 or later of the netatalk
-	  package. This driver is experimental, which means that it may not
-	  work. This driver will only work if you choose "AppleTalk DDP"
-	  networking support, above.
-	  Please read the file <file:Documentation/networking/cops.txt>.
-
-config COPS_DAYNA
-	bool "Dayna firmware support"
-	depends on COPS
-	help
-	  Support COPS compatible cards with Dayna style firmware (Dayna
-	  DL2000/ Daynatalk/PC (half length), COPS LT-95, Farallon PhoneNET PC
-	  III, Farallon PhoneNET PC II).
-
-config COPS_TANGENT
-	bool "Tangent firmware support"
-	depends on COPS
-	help
-	  Support COPS compatible cards with Tangent style firmware (Tangent
-	  ATB_II, Novell NL-1000, Daystar Digital LT-200.
-
 config IPDDP
 	tristate "Appletalk-IP driver support"
 	depends on DEV_APPLETALK && ATALK
diff -ruN ../linux-4.14.336/drivers/net/appletalk/Makefile ./drivers/net/appletalk/Makefile
--- linux-4.14.336/../linux-4.14.336/drivers/net/appletalk/Makefile	2024-01-10 14:45:41.000000000 +0100
+++ linux-4.14.336/./drivers/net/appletalk/Makefile	2024-02-14 21:04:05.191597490 +0100
@@ -3,5 +3,4 @@
 #
 
 obj-$(CONFIG_IPDDP) += ipddp.o
-obj-$(CONFIG_COPS) += cops.o
 obj-$(CONFIG_LTPC) += ltpc.o
diff -ruN ../linux-4.14.336/drivers/net/appletalk/cops.c ./drivers/net/appletalk/cops.c
--- linux-4.14.336/../linux-4.14.336/drivers/net/appletalk/cops.c	2024-01-10 14:45:41.000000000 +0100
+++ linux-4.14.336/./drivers/net/appletalk/cops.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1010 +0,0 @@
-/*      cops.c: LocalTalk driver for Linux.
- *
- *	Authors:
- *      - Jay Schulist <jschlst@samba.org>
- *
- *	With more than a little help from;
- *	- Alan Cox <alan@lxorguk.ukuu.org.uk>
- *
- *      Derived from:
- *      - skeleton.c: A network driver outline for linux.
- *        Written 1993-94 by Donald Becker.
- *	- ltpc.c: A driver for the LocalTalk PC card.
- *	  Written by Bradford W. Johnson.
- *
- *      Copyright 1993 United States Government as represented by the
- *      Director, National Security Agency.
- *
- *      This software may be used and distributed according to the terms
- *      of the GNU General Public License, incorporated herein by reference.
- *
- *	Changes:
- *	19970608	Alan Cox	Allowed dual card type support
- *					Can set board type in insmod
- *					Hooks for cops_setup routine
- *					(not yet implemented).
- *	19971101	Jay Schulist	Fixes for multiple lt* devices.
- *	19980607	Steven Hirsch	Fixed the badly broken support
- *					for Tangent type cards. Only
- *                                      tested on Daystar LT200. Some
- *                                      cleanup of formatting and program
- *                                      logic.  Added emacs 'local-vars'
- *                                      setup for Jay's brace style.
- *	20000211	Alan Cox	Cleaned up for softnet
- */
-
-static const char *version =
-"cops.c:v0.04 6/7/98 Jay Schulist <jschlst@samba.org>\n";
-/*
- *  Sources:
- *      COPS Localtalk SDK. This provides almost all of the information
- *      needed.
- */
-
-/*
- * insmod/modprobe configurable stuff.
- *	- IO Port, choose one your card supports or 0 if you dare.
- *	- IRQ, also choose one your card supports or nothing and let
- *	  the driver figure it out.
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/fcntl.h>
-#include <linux/interrupt.h>
-#include <linux/ptrace.h>
-#include <linux/ioport.h>
-#include <linux/in.h>
-#include <linux/string.h>
-#include <linux/errno.h>
-#include <linux/init.h>
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/skbuff.h>
-#include <linux/if_arp.h>
-#include <linux/if_ltalk.h>
-#include <linux/delay.h>	/* For udelay() */
-#include <linux/atalk.h>
-#include <linux/spinlock.h>
-#include <linux/bitops.h>
-#include <linux/jiffies.h>
-
-#include <asm/io.h>
-#include <asm/dma.h>
-
-#include "cops.h"		/* Our Stuff */
-#include "cops_ltdrv.h"		/* Firmware code for Tangent type cards. */
-#include "cops_ffdrv.h"		/* Firmware code for Dayna type cards. */
-
-/*
- *      The name of the card. Is used for messages and in the requests for
- *      io regions, irqs and dma channels
- */
-
-static const char *cardname = "cops";
-
-#ifdef CONFIG_COPS_DAYNA
-static int board_type = DAYNA;	/* Module exported */
-#else
-static int board_type = TANGENT;
-#endif
-
-static int io = 0x240;		/* Default IO for Dayna */
-static int irq = 5;		/* Default IRQ */
-
-/*
- *	COPS Autoprobe information.
- *	Right now if port address is right but IRQ is not 5 this will
- *      return a 5 no matter what since we will still get a status response.
- *      Need one more additional check to narrow down after we have gotten
- *      the ioaddr. But since only other possible IRQs is 3 and 4 so no real
- *	hurry on this. I *STRONGLY* recommend using IRQ 5 for your card with
- *	this driver.
- * 
- *	This driver has 2 modes and they are: Dayna mode and Tangent mode.
- *	Each mode corresponds with the type of card. It has been found
- *	that there are 2 main types of cards and all other cards are
- *	the same and just have different names or only have minor differences
- *	such as more IO ports. As this driver is tested it will
- *	become more clear on exactly what cards are supported. The driver
- *	defaults to using Dayna mode. To change the drivers mode, simply
- *	select Dayna or Tangent mode when configuring the kernel.
- *
- *      This driver should support:
- *      TANGENT driver mode:
- *              Tangent ATB-II, Novell NL-1000, Daystar Digital LT-200,
- *		COPS LT-1
- *      DAYNA driver mode:
- *              Dayna DL2000/DaynaTalk PC (Half Length), COPS LT-95, 
- *		Farallon PhoneNET PC III, Farallon PhoneNET PC II
- *	Other cards possibly supported mode unknown though:
- *		Dayna DL2000 (Full length), COPS LT/M (Micro-Channel)
- *
- *	Cards NOT supported by this driver but supported by the ltpc.c
- *	driver written by Bradford W. Johnson <johns393@maroon.tc.umn.edu>
- *		Farallon PhoneNET PC
- *		Original Apple LocalTalk PC card
- * 
- *      N.B.
- *
- *      The Daystar Digital LT200 boards do not support interrupt-driven
- *      IO.  You must specify 'irq=0xff' as a module parameter to invoke
- *      polled mode.  I also believe that the port probing logic is quite
- *      dangerous at best and certainly hopeless for a polled card.  Best to 
- *      specify both. - Steve H.
- *
- */
-
-/*
- * Zero terminated list of IO ports to probe.
- */
-
-static unsigned int ports[] = { 
-	0x240, 0x340, 0x200, 0x210, 0x220, 0x230, 0x260, 
-	0x2A0, 0x300, 0x310, 0x320, 0x330, 0x350, 0x360,
-	0
-};
-
-/*
- * Zero terminated list of IRQ ports to probe.
- */
-
-static int cops_irqlist[] = {
-	5, 4, 3, 0 
-};
-
-static struct timer_list cops_timer;
-
-/* use 0 for production, 1 for verification, 2 for debug, 3 for verbose debug */
-#ifndef COPS_DEBUG
-#define COPS_DEBUG 1 
-#endif
-static unsigned int cops_debug = COPS_DEBUG;
-
-/* The number of low I/O ports used by the card. */
-#define COPS_IO_EXTENT       8
-
-/* Information that needs to be kept for each board. */
-
-struct cops_local
-{
-        int board;			/* Holds what board type is. */
-	int nodeid;			/* Set to 1 once have nodeid. */
-        unsigned char node_acquire;	/* Node ID when acquired. */
-        struct atalk_addr node_addr;	/* Full node address */
-	spinlock_t lock;		/* RX/TX lock */
-};
-
-/* Index to functions, as function prototypes. */
-static int  cops_probe1 (struct net_device *dev, int ioaddr);
-static int  cops_irq (int ioaddr, int board);
-
-static int  cops_open (struct net_device *dev);
-static int  cops_jumpstart (struct net_device *dev);
-static void cops_reset (struct net_device *dev, int sleep);
-static void cops_load (struct net_device *dev);
-static int  cops_nodeid (struct net_device *dev, int nodeid);
-
-static irqreturn_t cops_interrupt (int irq, void *dev_id);
-static void cops_poll (unsigned long ltdev);
-static void cops_timeout(struct net_device *dev);
-static void cops_rx (struct net_device *dev);
-static netdev_tx_t  cops_send_packet (struct sk_buff *skb,
-					    struct net_device *dev);
-static void set_multicast_list (struct net_device *dev);
-static int  cops_ioctl (struct net_device *dev, struct ifreq *rq, int cmd);
-static int  cops_close (struct net_device *dev);
-
-static void cleanup_card(struct net_device *dev)
-{
-	if (dev->irq)
-		free_irq(dev->irq, dev);
-	release_region(dev->base_addr, COPS_IO_EXTENT);
-}
-
-/*
- *      Check for a network adaptor of this type, and return '0' iff one exists.
- *      If dev->base_addr == 0, probe all likely locations.
- *      If dev->base_addr in [1..0x1ff], always return failure.
- *        otherwise go with what we pass in.
- */
-struct net_device * __init cops_probe(int unit)
-{
-	struct net_device *dev;
-	unsigned *port;
-	int base_addr;
-	int err = 0;
-
-	dev = alloc_ltalkdev(sizeof(struct cops_local));
-	if (!dev)
-		return ERR_PTR(-ENOMEM);
-
-	if (unit >= 0) {
-		sprintf(dev->name, "lt%d", unit);
-		netdev_boot_setup_check(dev);
-		irq = dev->irq;
-		base_addr = dev->base_addr;
-	} else {
-		base_addr = dev->base_addr = io;
-	}
-
-	if (base_addr > 0x1ff) {    /* Check a single specified location. */
-		err = cops_probe1(dev, base_addr);
-	} else if (base_addr != 0) { /* Don't probe at all. */
-		err = -ENXIO;
-	} else {
-		/* FIXME  Does this really work for cards which generate irq?
-		 * It's definitely N.G. for polled Tangent. sh
-		 * Dayna cards don't autoprobe well at all, but if your card is
-		 * at IRQ 5 & IO 0x240 we find it every time. ;) JS
-		 */
-		for (port = ports; *port && cops_probe1(dev, *port) < 0; port++)
-			;
-		if (!*port)
-			err = -ENODEV;
-	}
-	if (err)
-		goto out;
-	err = register_netdev(dev);
-	if (err)
-		goto out1;
-	return dev;
-out1:
-	cleanup_card(dev);
-out:
-	free_netdev(dev);
-	return ERR_PTR(err);
-}
-
-static const struct net_device_ops cops_netdev_ops = {
-	.ndo_open               = cops_open,
-        .ndo_stop               = cops_close,
-	.ndo_start_xmit   	= cops_send_packet,
-	.ndo_tx_timeout		= cops_timeout,
-        .ndo_do_ioctl           = cops_ioctl,
-	.ndo_set_rx_mode	= set_multicast_list,
-};
-
-/*
- *      This is the real probe routine. Linux has a history of friendly device
- *      probes on the ISA bus. A good device probes avoids doing writes, and
- *      verifies that the correct device exists and functions.
- */
-static int __init cops_probe1(struct net_device *dev, int ioaddr)
-{
-        struct cops_local *lp;
-	static unsigned version_printed;
-	int board = board_type;
-	int retval;
-	
-        if(cops_debug && version_printed++ == 0)
-		printk("%s", version);
-
-	/* Grab the region so no one else tries to probe our ioports. */
-	if (!request_region(ioaddr, COPS_IO_EXTENT, dev->name))
-		return -EBUSY;
-
-        /*
-         * Since this board has jumpered interrupts, allocate the interrupt
-         * vector now. There is no point in waiting since no other device
-         * can use the interrupt, and this marks the irq as busy. Jumpered
-         * interrupts are typically not reported by the boards, and we must
-         * used AutoIRQ to find them.
-	 */
-	dev->irq = irq;
-	switch (dev->irq)
-	{
-		case 0:
-			/* COPS AutoIRQ routine */
-			dev->irq = cops_irq(ioaddr, board);
-			if (dev->irq)
-				break;
-			/* No IRQ found on this port, fallthrough */
-		case 1:
-			retval = -EINVAL;
-			goto err_out;
-
-		/* Fixup for users that don't know that IRQ 2 is really
-		 * IRQ 9, or don't know which one to set.
-		 */
-		case 2:
-			dev->irq = 9;
-			break;
-
-		/* Polled operation requested. Although irq of zero passed as
-		 * a parameter tells the init routines to probe, we'll
-		 * overload it to denote polled operation at runtime.
-		 */
-		case 0xff:
-			dev->irq = 0;
-			break;
-
-		default:
-			break;
-	}
-
-	dev->base_addr = ioaddr;
-
-	/* Reserve any actual interrupt. */
-	if (dev->irq) {
-		retval = request_irq(dev->irq, cops_interrupt, 0, dev->name, dev);
-		if (retval)
-			goto err_out;
-	}
-
-        lp = netdev_priv(dev);
-        spin_lock_init(&lp->lock);
-
-	/* Copy local board variable to lp struct. */
-	lp->board               = board;
-
-	dev->netdev_ops 	= &cops_netdev_ops;
-	dev->watchdog_timeo	= HZ * 2;
-
-
-	/* Tell the user where the card is and what mode we're in. */
-	if(board==DAYNA)
-		printk("%s: %s at %#3x, using IRQ %d, in Dayna mode.\n", 
-			dev->name, cardname, ioaddr, dev->irq);
-	if(board==TANGENT) {
-		if(dev->irq)
-			printk("%s: %s at %#3x, IRQ %d, in Tangent mode\n", 
-				dev->name, cardname, ioaddr, dev->irq);
-		else
-			printk("%s: %s at %#3x, using polled IO, in Tangent mode.\n", 
-				dev->name, cardname, ioaddr);
-
-	}
-        return 0;
-
-err_out:
-	release_region(ioaddr, COPS_IO_EXTENT);
-	return retval;
-}
-
-static int __init cops_irq (int ioaddr, int board)
-{       /*
-         * This does not use the IRQ to determine where the IRQ is. We just
-         * assume that when we get a correct status response that it's the IRQ.
-         * This really just verifies the IO port but since we only have access
-         * to such a small number of IRQs (5, 4, 3) this is not bad.
-         * This will probably not work for more than one card.
-         */
-        int irqaddr=0;
-        int i, x, status;
-
-        if(board==DAYNA)
-        {
-                outb(0, ioaddr+DAYNA_RESET);
-                inb(ioaddr+DAYNA_RESET);
-                mdelay(333);
-        }
-        if(board==TANGENT)
-        {
-                inb(ioaddr);
-                outb(0, ioaddr);
-                outb(0, ioaddr+TANG_RESET);
-        }
-
-        for(i=0; cops_irqlist[i] !=0; i++)
-        {
-                irqaddr = cops_irqlist[i];
-                for(x = 0xFFFF; x>0; x --)    /* wait for response */
-                {
-                        if(board==DAYNA)
-                        {
-                                status = (inb(ioaddr+DAYNA_CARD_STATUS)&3);
-                                if(status == 1)
-                                        return irqaddr;
-                        }
-                        if(board==TANGENT)
-                        {
-                                if((inb(ioaddr+TANG_CARD_STATUS)& TANG_TX_READY) !=0)
-                                        return irqaddr;
-                        }
-                }
-        }
-        return 0;       /* no IRQ found */
-}
-
-/*
- * Open/initialize the board. This is called (in the current kernel)
- * sometime after booting when the 'ifconfig' program is run.
- */
-static int cops_open(struct net_device *dev)
-{
-    struct cops_local *lp = netdev_priv(dev);
-
-	if(dev->irq==0)
-	{
-		/*
-		 * I don't know if the Dayna-style boards support polled 
-		 * operation.  For now, only allow it for Tangent.
-		 */
-		if(lp->board==TANGENT)	/* Poll 20 times per second */
-		{
-		    init_timer(&cops_timer);
-		    cops_timer.function = cops_poll;
-		    cops_timer.data 	= (unsigned long)dev;
-		    cops_timer.expires 	= jiffies + HZ/20;
-		    add_timer(&cops_timer);
-		} 
-		else 
-		{
-			printk(KERN_WARNING "%s: No irq line set\n", dev->name);
-			return -EAGAIN;
-		}
-	}
-
-	cops_jumpstart(dev);	/* Start the card up. */
-
-	netif_start_queue(dev);
-        return 0;
-}
-
-/*
- *	This allows for a dynamic start/restart of the entire card.
- */
-static int cops_jumpstart(struct net_device *dev)
-{
-	struct cops_local *lp = netdev_priv(dev);
-
-	/*
-         *      Once the card has the firmware loaded and has acquired
-         *      the nodeid, if it is reset it will lose it all.
-         */
-        cops_reset(dev,1);	/* Need to reset card before load firmware. */
-        cops_load(dev);		/* Load the firmware. */
-
-	/*
-	 *	If atalkd already gave us a nodeid we will use that
-	 *	one again, else we wait for atalkd to give us a nodeid
-	 *	in cops_ioctl. This may cause a problem if someone steals
-	 *	our nodeid while we are resetting.
-	 */	
-	if(lp->nodeid == 1)
-		cops_nodeid(dev,lp->node_acquire);
-
-	return 0;
-}
-
-static void tangent_wait_reset(int ioaddr)
-{
-	int timeout=0;
-
-	while(timeout++ < 5 && (inb(ioaddr+TANG_CARD_STATUS)&TANG_TX_READY)==0)
-		mdelay(1);   /* Wait 1 second */
-}
-
-/*
- *      Reset the LocalTalk board.
- */
-static void cops_reset(struct net_device *dev, int sleep)
-{
-        struct cops_local *lp = netdev_priv(dev);
-        int ioaddr=dev->base_addr;
-
-        if(lp->board==TANGENT)
-        {
-                inb(ioaddr);		/* Clear request latch. */
-                outb(0,ioaddr);		/* Clear the TANG_TX_READY flop. */
-                outb(0, ioaddr+TANG_RESET);	/* Reset the adapter. */
-
-		tangent_wait_reset(ioaddr);
-                outb(0, ioaddr+TANG_CLEAR_INT);
-        }
-        if(lp->board==DAYNA)
-        {
-                outb(0, ioaddr+DAYNA_RESET);	/* Assert the reset port */
-                inb(ioaddr+DAYNA_RESET);	/* Clear the reset */
-		if (sleep)
-			msleep(333);
-		else
-			mdelay(333);
-        }
-
-	netif_wake_queue(dev);
-}
-
-static void cops_load (struct net_device *dev)
-{
-        struct ifreq ifr;
-        struct ltfirmware *ltf= (struct ltfirmware *)&ifr.ifr_ifru;
-        struct cops_local *lp = netdev_priv(dev);
-        int ioaddr=dev->base_addr;
-	int length, i = 0;
-
-        strcpy(ifr.ifr_name,"lt0");
-
-        /* Get card's firmware code and do some checks on it. */
-#ifdef CONFIG_COPS_DAYNA        
-        if(lp->board==DAYNA)
-        {
-                ltf->length=sizeof(ffdrv_code);
-                ltf->data=ffdrv_code;
-        }
-        else
-#endif        
-#ifdef CONFIG_COPS_TANGENT
-        if(lp->board==TANGENT)
-        {
-                ltf->length=sizeof(ltdrv_code);
-                ltf->data=ltdrv_code;
-        }
-        else
-#endif
-	{
-		printk(KERN_INFO "%s; unsupported board type.\n", dev->name);
-		return;
-	}
-	
-        /* Check to make sure firmware is correct length. */
-        if(lp->board==DAYNA && ltf->length!=5983)
-        {
-                printk(KERN_WARNING "%s: Firmware is not length of FFDRV.BIN.\n", dev->name);
-                return;
-        }
-        if(lp->board==TANGENT && ltf->length!=2501)
-        {
-                printk(KERN_WARNING "%s: Firmware is not length of DRVCODE.BIN.\n", dev->name);
-                return;
-        }
-
-        if(lp->board==DAYNA)
-        {
-                /*
-                 *      We must wait for a status response
-                 *      with the DAYNA board.
-                 */
-                while(++i<65536)
-                {
-                       if((inb(ioaddr+DAYNA_CARD_STATUS)&3)==1)
-                                break;
-                }
-
-                if(i==65536)
-                        return;
-        }
-
-        /*
-         *      Upload the firmware and kick. Byte-by-byte works nicely here.
-         */
-	i=0;
-        length = ltf->length;
-        while(length--)
-        {
-                outb(ltf->data[i], ioaddr);
-                i++;
-        }
-
-	if(cops_debug > 1)
-		printk("%s: Uploaded firmware - %d bytes of %d bytes.\n", 
-			dev->name, i, ltf->length);
-
-        if(lp->board==DAYNA) 	/* Tell Dayna to run the firmware code. */
-                outb(1, ioaddr+DAYNA_INT_CARD);
-	else			/* Tell Tang to run the firmware code. */
-		inb(ioaddr);
-
-        if(lp->board==TANGENT)
-        {
-                tangent_wait_reset(ioaddr);
-                inb(ioaddr);	/* Clear initial ready signal. */
-        }
-}
-
-/*
- * 	Get the LocalTalk Nodeid from the card. We can suggest
- *	any nodeid 1-254. The card will try and get that exact
- *	address else we can specify 0 as the nodeid and the card
- *	will autoprobe for a nodeid.
- */
-static int cops_nodeid (struct net_device *dev, int nodeid)
-{
-	struct cops_local *lp = netdev_priv(dev);
-	int ioaddr = dev->base_addr;
-
-	if(lp->board == DAYNA)
-        {
-        	/* Empty any pending adapter responses. */
-                while((inb(ioaddr+DAYNA_CARD_STATUS)&DAYNA_TX_READY)==0)
-                {
-			outb(0, ioaddr+COPS_CLEAR_INT);	/* Clear interrupts. */
-        		if((inb(ioaddr+DAYNA_CARD_STATUS)&0x03)==DAYNA_RX_REQUEST)
-                		cops_rx(dev);	/* Kick any packets waiting. */
-			schedule();
-                }
-
-                outb(2, ioaddr);       	/* Output command packet length as 2. */
-                outb(0, ioaddr);
-                outb(LAP_INIT, ioaddr);	/* Send LAP_INIT command byte. */
-                outb(nodeid, ioaddr);  	/* Suggest node address. */
-        }
-
-	if(lp->board == TANGENT)
-        {
-                /* Empty any pending adapter responses. */
-                while(inb(ioaddr+TANG_CARD_STATUS)&TANG_RX_READY)
-                {
-			outb(0, ioaddr+COPS_CLEAR_INT);	/* Clear interrupt. */
-                	cops_rx(dev);          	/* Kick out packets waiting. */
-			schedule();
-                }
-
-		/* Not sure what Tangent does if nodeid picked is used. */
-                if(nodeid == 0)	         		/* Seed. */
-                	nodeid = jiffies&0xFF;		/* Get a random try */
-                outb(2, ioaddr);        		/* Command length LSB */
-                outb(0, ioaddr);       			/* Command length MSB */
-                outb(LAP_INIT, ioaddr); 		/* Send LAP_INIT byte */
-                outb(nodeid, ioaddr); 		  	/* LAP address hint. */
-                outb(0xFF, ioaddr);     		/* Int. level to use */
-        }
-
-	lp->node_acquire=0;		/* Set nodeid holder to 0. */
-        while(lp->node_acquire==0)	/* Get *True* nodeid finally. */
-	{
-		outb(0, ioaddr+COPS_CLEAR_INT);	/* Clear any interrupt. */
-
-		if(lp->board == DAYNA)
-		{
-                	if((inb(ioaddr+DAYNA_CARD_STATUS)&0x03)==DAYNA_RX_REQUEST)
-                		cops_rx(dev);	/* Grab the nodeid put in lp->node_acquire. */
-		}
-		if(lp->board == TANGENT)
-		{	
-			if(inb(ioaddr+TANG_CARD_STATUS)&TANG_RX_READY)
-                                cops_rx(dev);   /* Grab the nodeid put in lp->node_acquire. */
-		}
-		schedule();
-	}
-
-	if(cops_debug > 1)
-		printk(KERN_DEBUG "%s: Node ID %d has been acquired.\n", 
-			dev->name, lp->node_acquire);
-
-	lp->nodeid=1;	/* Set got nodeid to 1. */
-
-        return 0;
-}
-
-/*
- *	Poll the Tangent type cards to see if we have work.
- */
- 
-static void cops_poll(unsigned long ltdev)
-{
-	int ioaddr, status;
-	int boguscount = 0;
-
-	struct net_device *dev = (struct net_device *)ltdev;
-
-	del_timer(&cops_timer);
-
-	if(dev == NULL)
-		return;	/* We've been downed */
-
-	ioaddr = dev->base_addr;
-	do {
-		status=inb(ioaddr+TANG_CARD_STATUS);
-		if(status & TANG_RX_READY)
-			cops_rx(dev);
-		if(status & TANG_TX_READY)
-			netif_wake_queue(dev);
-		status = inb(ioaddr+TANG_CARD_STATUS);
-	} while((++boguscount < 20) && (status&(TANG_RX_READY|TANG_TX_READY)));
-
-	/* poll 20 times per second */
-	cops_timer.expires = jiffies + HZ/20;
-	add_timer(&cops_timer);
-}
-
-/*
- *      The typical workload of the driver:
- *      Handle the network interface interrupts.
- */
-static irqreturn_t cops_interrupt(int irq, void *dev_id)
-{
-        struct net_device *dev = dev_id;
-        struct cops_local *lp;
-        int ioaddr, status;
-        int boguscount = 0;
-
-        ioaddr = dev->base_addr;
-        lp = netdev_priv(dev);
-
-	if(lp->board==DAYNA)
-	{
-		do {
-			outb(0, ioaddr + COPS_CLEAR_INT);
-                       	status=inb(ioaddr+DAYNA_CARD_STATUS);
-                       	if((status&0x03)==DAYNA_RX_REQUEST)
-                       	        cops_rx(dev);
-                	netif_wake_queue(dev);
-		} while(++boguscount < 20);
-	}
-	else
-	{
-		do {
-                       	status=inb(ioaddr+TANG_CARD_STATUS);
-			if(status & TANG_RX_READY)
-				cops_rx(dev);
-			if(status & TANG_TX_READY)
-				netif_wake_queue(dev);
-			status=inb(ioaddr+TANG_CARD_STATUS);
-		} while((++boguscount < 20) && (status&(TANG_RX_READY|TANG_TX_READY)));
-	}
-
-        return IRQ_HANDLED;
-}
-
-/*
- *      We have a good packet(s), get it/them out of the buffers.
- */
-static void cops_rx(struct net_device *dev)
-{
-        int pkt_len = 0;
-        int rsp_type = 0;
-        struct sk_buff *skb = NULL;
-        struct cops_local *lp = netdev_priv(dev);
-        int ioaddr = dev->base_addr;
-        int boguscount = 0;
-        unsigned long flags;
-
-
-	spin_lock_irqsave(&lp->lock, flags);
-	
-        if(lp->board==DAYNA)
-        {
-                outb(0, ioaddr);                /* Send out Zero length. */
-                outb(0, ioaddr);
-                outb(DATA_READ, ioaddr);        /* Send read command out. */
-
-                /* Wait for DMA to turn around. */
-                while(++boguscount<1000000)
-                {
-			barrier();
-                        if((inb(ioaddr+DAYNA_CARD_STATUS)&0x03)==DAYNA_RX_READY)
-                                break;
-                }
-
-                if(boguscount==1000000)
-                {
-                        printk(KERN_WARNING "%s: DMA timed out.\n",dev->name);
-			spin_unlock_irqrestore(&lp->lock, flags);
-                        return;
-                }
-        }
-
-        /* Get response length. */
-	if(lp->board==DAYNA)
-        	pkt_len = inb(ioaddr) & 0xFF;
-	else
-		pkt_len = inb(ioaddr) & 0x00FF;
-        pkt_len |= (inb(ioaddr) << 8);
-        /* Input IO code. */
-        rsp_type=inb(ioaddr);
-
-        /* Malloc up new buffer. */
-        skb = dev_alloc_skb(pkt_len);
-        if(skb == NULL)
-        {
-                printk(KERN_WARNING "%s: Memory squeeze, dropping packet.\n",
-			dev->name);
-                dev->stats.rx_dropped++;
-                while(pkt_len--)        /* Discard packet */
-                        inb(ioaddr);
-                spin_unlock_irqrestore(&lp->lock, flags);
-                return;
-        }
-        skb->dev = dev;
-        skb_put(skb, pkt_len);
-        skb->protocol = htons(ETH_P_LOCALTALK);
-
-        insb(ioaddr, skb->data, pkt_len);               /* Eat the Data */
-
-        if(lp->board==DAYNA)
-                outb(1, ioaddr+DAYNA_INT_CARD);         /* Interrupt the card */
-
-        spin_unlock_irqrestore(&lp->lock, flags);  /* Restore interrupts. */
-
-        /* Check for bad response length */
-        if(pkt_len < 0 || pkt_len > MAX_LLAP_SIZE)
-        {
-		printk(KERN_WARNING "%s: Bad packet length of %d bytes.\n", 
-			dev->name, pkt_len);
-                dev->stats.tx_errors++;
-                dev_kfree_skb_any(skb);
-                return;
-        }
-
-        /* Set nodeid and then get out. */
-        if(rsp_type == LAP_INIT_RSP)
-        {	/* Nodeid taken from received packet. */
-                lp->node_acquire = skb->data[0];
-                dev_kfree_skb_any(skb);
-                return;
-        }
-
-        /* One last check to make sure we have a good packet. */
-        if(rsp_type != LAP_RESPONSE)
-        {
-                printk(KERN_WARNING "%s: Bad packet type %d.\n", dev->name, rsp_type);
-                dev->stats.tx_errors++;
-                dev_kfree_skb_any(skb);
-                return;
-        }
-
-        skb_reset_mac_header(skb);    /* Point to entire packet. */
-        skb_pull(skb,3);
-        skb_reset_transport_header(skb);    /* Point to data (Skip header). */
-
-        /* Update the counters. */
-        dev->stats.rx_packets++;
-        dev->stats.rx_bytes += skb->len;
-
-        /* Send packet to a higher place. */
-        netif_rx(skb);
-}
-
-static void cops_timeout(struct net_device *dev)
-{
-        struct cops_local *lp = netdev_priv(dev);
-        int ioaddr = dev->base_addr;
-
-	dev->stats.tx_errors++;
-        if(lp->board==TANGENT)
-        {
-		if((inb(ioaddr+TANG_CARD_STATUS)&TANG_TX_READY)==0)
-               		printk(KERN_WARNING "%s: No TX complete interrupt.\n", dev->name);
-	}
-	printk(KERN_WARNING "%s: Transmit timed out.\n", dev->name);
-	cops_jumpstart(dev);	/* Restart the card. */
-	netif_trans_update(dev); /* prevent tx timeout */
-	netif_wake_queue(dev);
-}
-
-
-/*
- *	Make the card transmit a LocalTalk packet.
- */
-
-static netdev_tx_t cops_send_packet(struct sk_buff *skb,
-					  struct net_device *dev)
-{
-        struct cops_local *lp = netdev_priv(dev);
-        int ioaddr = dev->base_addr;
-        unsigned long flags;
-
-        /*
-         * Block a timer-based transmit from overlapping. 
-	 */
-	 
-	netif_stop_queue(dev);
-
-	spin_lock_irqsave(&lp->lock, flags);
-	if(lp->board == DAYNA)	 /* Wait for adapter transmit buffer. */
-		while((inb(ioaddr+DAYNA_CARD_STATUS)&DAYNA_TX_READY)==0)
-			cpu_relax();
-	if(lp->board == TANGENT) /* Wait for adapter transmit buffer. */
-		while((inb(ioaddr+TANG_CARD_STATUS)&TANG_TX_READY)==0)
-			cpu_relax();
-
-	/* Output IO length. */
-	outb(skb->len, ioaddr);
-	if(lp->board == DAYNA)
-               	outb(skb->len >> 8, ioaddr);
-	else
-		outb((skb->len >> 8)&0x0FF, ioaddr);
-
-	/* Output IO code. */
-	outb(LAP_WRITE, ioaddr);
-
-	if(lp->board == DAYNA)	/* Check the transmit buffer again. */
-        	while((inb(ioaddr+DAYNA_CARD_STATUS)&DAYNA_TX_READY)==0);
-
-	outsb(ioaddr, skb->data, skb->len);	/* Send out the data. */
-
-	if(lp->board==DAYNA)	/* Dayna requires you kick the card */
-		outb(1, ioaddr+DAYNA_INT_CARD);
-
-	spin_unlock_irqrestore(&lp->lock, flags);	/* Restore interrupts. */
-
-	/* Done sending packet, update counters and cleanup. */
-	dev->stats.tx_packets++;
-	dev->stats.tx_bytes += skb->len;
-	dev_kfree_skb (skb);
-	return NETDEV_TX_OK;
-}
-
-/*
- *	Dummy function to keep the Appletalk layer happy.
- */
- 
-static void set_multicast_list(struct net_device *dev)
-{
-        if(cops_debug >= 3)
-		printk("%s: set_multicast_list executed\n", dev->name);
-}
-
-/*
- *      System ioctls for the COPS LocalTalk card.
- */
- 
-static int cops_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
-{
-        struct cops_local *lp = netdev_priv(dev);
-        struct sockaddr_at *sa = (struct sockaddr_at *)&ifr->ifr_addr;
-        struct atalk_addr *aa = &lp->node_addr;
-
-        switch(cmd)
-        {
-                case SIOCSIFADDR:
-			/* Get and set the nodeid and network # atalkd wants. */
-			cops_nodeid(dev, sa->sat_addr.s_node);
-			aa->s_net               = sa->sat_addr.s_net;
-                        aa->s_node              = lp->node_acquire;
-
-			/* Set broardcast address. */
-                        dev->broadcast[0]       = 0xFF;
-			
-			/* Set hardware address. */
-                        dev->dev_addr[0]        = aa->s_node;
-                        dev->addr_len           = 1;
-                        return 0;
-
-                case SIOCGIFADDR:
-                        sa->sat_addr.s_net      = aa->s_net;
-                        sa->sat_addr.s_node     = aa->s_node;
-                        return 0;
-
-                default:
-                        return -EOPNOTSUPP;
-        }
-}
-
-/*
- *	The inverse routine to cops_open().
- */
- 
-static int cops_close(struct net_device *dev)
-{
-	struct cops_local *lp = netdev_priv(dev);
-
-	/* If we were running polled, yank the timer.
-	 */
-	if(lp->board==TANGENT && dev->irq==0)
-		del_timer(&cops_timer);
-
-	netif_stop_queue(dev);
-        return 0;
-}
-
-
-#ifdef MODULE
-static struct net_device *cops_dev;
-
-MODULE_LICENSE("GPL");
-module_param_hw(io, int, ioport, 0);
-module_param_hw(irq, int, irq, 0);
-module_param_hw(board_type, int, other, 0);
-
-static int __init cops_module_init(void)
-{
-	if (io == 0)
-		printk(KERN_WARNING "%s: You shouldn't autoprobe with insmod\n",
-			cardname);
-	cops_dev = cops_probe(-1);
-	return PTR_ERR_OR_ZERO(cops_dev);
-}
-
-static void __exit cops_module_exit(void)
-{
-	unregister_netdev(cops_dev);
-	cleanup_card(cops_dev);
-	free_netdev(cops_dev);
-}
-module_init(cops_module_init);
-module_exit(cops_module_exit);
-#endif /* MODULE */
diff -ruN ../linux-4.14.336/drivers/net/appletalk/cops.h ./drivers/net/appletalk/cops.h
--- linux-4.14.336/../linux-4.14.336/drivers/net/appletalk/cops.h	2024-01-10 14:45:41.000000000 +0100
+++ linux-4.14.336/./drivers/net/appletalk/cops.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,61 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*      cops.h: LocalTalk driver for Linux.
- *
- *      Authors:
- *      - Jay Schulist <jschlst@samba.org>
- */
-
-#ifndef __LINUX_COPSLTALK_H
-#define __LINUX_COPSLTALK_H
-
-#ifdef __KERNEL__
-
-/* Max LLAP size we will accept. */
-#define MAX_LLAP_SIZE		603
-
-/* Tangent */
-#define TANG_CARD_STATUS        1
-#define TANG_CLEAR_INT          1
-#define TANG_RESET              3
-
-#define TANG_TX_READY           1
-#define TANG_RX_READY           2
-
-/* Dayna */
-#define DAYNA_CMD_DATA          0
-#define DAYNA_CLEAR_INT         1
-#define DAYNA_CARD_STATUS       2
-#define DAYNA_INT_CARD          3
-#define DAYNA_RESET             4
-
-#define DAYNA_RX_READY          0
-#define DAYNA_TX_READY          1
-#define DAYNA_RX_REQUEST        3
-
-/* Same on both card types */
-#define COPS_CLEAR_INT  1
-
-/* LAP response codes received from the cards. */
-#define LAP_INIT        1       /* Init cmd */
-#define LAP_INIT_RSP    2       /* Init response */
-#define LAP_WRITE       3       /* Write cmd */
-#define DATA_READ       4       /* Data read */
-#define LAP_RESPONSE    4       /* Received ALAP frame response */
-#define LAP_GETSTAT     5       /* Get LAP and HW status */
-#define LAP_RSPSTAT     6       /* Status response */
-
-#endif
-
-/*
- *	Structure to hold the firmware information.
- */
-struct ltfirmware
-{
-        unsigned int length;
-        const unsigned char *data;
-};
-
-#define DAYNA 1
-#define TANGENT 2
-
-#endif
diff -ruN ../linux-4.14.336/drivers/net/appletalk/cops_ffdrv.h ./drivers/net/appletalk/cops_ffdrv.h
--- linux-4.14.336/../linux-4.14.336/drivers/net/appletalk/cops_ffdrv.h	2024-01-10 14:45:41.000000000 +0100
+++ linux-4.14.336/./drivers/net/appletalk/cops_ffdrv.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,532 +0,0 @@
-
-/*
- *	The firmware this driver downloads into the Localtalk card is a
- *	separate program and is not GPL'd source code, even though the Linux
- *	side driver and the routine that loads this data into the card are.
- *	
- *	It is taken from the COPS SDK and is under the following license
- *
- *	This material is licensed to you strictly for use in conjunction with
- *	the use of COPS LocalTalk adapters.
- *	There is no charge for this SDK. And no waranty express or implied
- *	about its fitness for any purpose. However, we will cheerefully
- *	refund every penny you paid for this SDK...
- *	Regards,
- *
- *	Thomas F. Divine
- *	Chief Scientist
- */
-
-
-/*      cops_ffdrv.h: LocalTalk driver firmware dump for Linux.
- *
- *      Authors:
- *      - Jay Schulist <jschlst@samba.org>
- */
-
-
-#ifdef CONFIG_COPS_DAYNA
-
-static const unsigned char ffdrv_code[] = {
-	58,3,0,50,228,149,33,255,255,34,226,149,
-	249,17,40,152,33,202,154,183,237,82,77,68,
-	11,107,98,19,54,0,237,176,175,50,80,0,
-	62,128,237,71,62,32,237,57,51,62,12,237,
-	57,50,237,57,54,62,6,237,57,52,62,12,
-	237,57,49,33,107,137,34,32,128,33,83,130,
-	34,40,128,33,86,130,34,42,128,33,112,130,
-	34,36,128,33,211,130,34,38,128,62,0,237,
-	57,16,33,63,148,34,34,128,237,94,205,15,
-	130,251,205,168,145,24,141,67,111,112,121,114,
-	105,103,104,116,32,40,67,41,32,49,57,56,
-	56,32,45,32,68,97,121,110,97,32,67,111,
-	109,109,117,110,105,99,97,116,105,111,110,115,
-	32,32,32,65,108,108,32,114,105,103,104,116,
-	115,32,114,101,115,101,114,118,101,100,46,32,
-	32,40,68,40,68,7,16,8,34,7,22,6,
-	16,5,12,4,8,3,6,140,0,16,39,128,
-	0,4,96,10,224,6,0,7,126,2,64,11,
-	118,12,6,13,0,14,193,15,0,5,96,3,
-	192,1,64,9,8,62,9,211,66,62,192,211,
-	66,62,100,61,32,253,6,28,33,205,129,14,
-	66,237,163,194,253,129,6,28,33,205,129,14,
-	64,237,163,194,9,130,201,62,47,50,71,152,
-	62,47,211,68,58,203,129,237,57,20,58,204,
-	129,237,57,21,33,77,152,54,132,205,233,129,
-	58,228,149,254,209,40,6,56,4,62,0,24,
-	2,219,96,33,233,149,119,230,62,33,232,149,
-	119,213,33,8,152,17,7,0,25,119,19,25,
-	119,209,201,251,237,77,245,197,213,229,221,229,
-	205,233,129,62,1,50,106,137,205,158,139,221,
-	225,225,209,193,241,251,237,77,245,197,213,219,
-	72,237,56,16,230,46,237,57,16,237,56,12,
-	58,72,152,183,32,26,6,20,17,128,2,237,
-	56,46,187,32,35,237,56,47,186,32,29,219,
-	72,230,1,32,3,5,32,232,175,50,72,152,
-	229,221,229,62,1,50,106,137,205,158,139,221,
-	225,225,24,25,62,1,50,72,152,58,201,129,
-	237,57,12,58,202,129,237,57,13,237,56,16,
-	246,17,237,57,16,209,193,241,251,237,77,245,
-	197,229,213,221,229,237,56,16,230,17,237,57,
-	16,237,56,20,58,34,152,246,16,246,8,211,
-	68,62,6,61,32,253,58,34,152,246,8,211,
-	68,58,203,129,237,57,20,58,204,129,237,57,
-	21,237,56,16,246,34,237,57,16,221,225,209,
-	225,193,241,251,237,77,33,2,0,57,126,230,
-	3,237,100,1,40,2,246,128,230,130,245,62,
-	5,211,64,241,211,64,201,229,213,243,237,56,
-	16,230,46,237,57,16,237,56,12,251,70,35,
-	35,126,254,175,202,77,133,254,129,202,15,133,
-	230,128,194,191,132,43,58,44,152,119,33,76,
-	152,119,35,62,132,119,120,254,255,40,4,58,
-	49,152,119,219,72,43,43,112,17,3,0,237,
-	56,52,230,248,237,57,52,219,72,230,1,194,
-	141,131,209,225,237,56,52,246,6,237,57,52,
-	62,1,55,251,201,62,3,211,66,62,192,211,
-	66,62,48,211,66,0,0,219,66,230,1,40,
-	4,219,67,24,240,205,203,135,58,75,152,254,
-	255,202,128,132,58,49,152,254,161,250,207,131,
-	58,34,152,211,68,62,10,211,66,62,128,211,
-	66,62,11,211,66,62,6,211,66,24,0,62,
-	14,211,66,62,33,211,66,62,1,211,66,62,
-	64,211,66,62,3,211,66,62,209,211,66,62,
-	100,71,219,66,230,1,32,6,5,32,247,195,
-	248,132,219,67,71,58,44,152,184,194,248,132,
-	62,100,71,219,66,230,1,32,6,5,32,247,
-	195,248,132,219,67,62,100,71,219,66,230,1,
-	32,6,5,32,247,195,248,132,219,67,254,133,
-	32,7,62,0,50,74,152,24,17,254,173,32,
-	7,62,1,50,74,152,24,6,254,141,194,248,
-	132,71,209,225,58,49,152,254,132,32,10,62,
-	50,205,2,134,205,144,135,24,27,254,140,32,
-	15,62,110,205,2,134,62,141,184,32,5,205,
-	144,135,24,8,62,10,205,2,134,205,8,134,
-	62,1,50,106,137,205,158,139,237,56,52,246,
-	6,237,57,52,175,183,251,201,62,20,135,237,
-	57,20,175,237,57,21,237,56,16,246,2,237,
-	57,16,237,56,20,95,237,56,21,123,254,10,
-	48,244,237,56,16,230,17,237,57,16,209,225,
-	205,144,135,62,1,50,106,137,205,158,139,237,
-	56,52,246,6,237,57,52,175,183,251,201,209,
-	225,243,219,72,230,1,40,13,62,10,211,66,
-	0,0,219,66,230,192,202,226,132,237,56,52,
-	246,6,237,57,52,62,1,55,251,201,205,203,
-	135,62,1,50,106,137,205,158,139,237,56,52,
-	246,6,237,57,52,183,251,201,209,225,62,1,
-	50,106,137,205,158,139,237,56,52,246,6,237,
-	57,52,62,2,55,251,201,209,225,243,219,72,
-	230,1,202,213,132,62,10,211,66,0,0,219,
-	66,230,192,194,213,132,229,62,1,50,106,137,
-	42,40,152,205,65,143,225,17,3,0,205,111,
-	136,62,6,211,66,58,44,152,211,66,237,56,
-	52,246,6,237,57,52,183,251,201,209,197,237,
-	56,52,230,248,237,57,52,219,72,230,1,32,
-	15,193,225,237,56,52,246,6,237,57,52,62,
-	1,55,251,201,14,23,58,37,152,254,0,40,
-	14,14,2,254,1,32,5,62,140,119,24,3,
-	62,132,119,43,43,197,205,203,135,193,62,1,
-	211,66,62,64,211,66,62,3,211,66,62,193,
-	211,66,62,100,203,39,71,219,66,230,1,32,
-	6,5,32,247,195,229,133,33,238,151,219,67,
-	71,58,44,152,184,194,229,133,119,62,100,71,
-	219,66,230,1,32,6,5,32,247,195,229,133,
-	219,67,35,119,13,32,234,193,225,62,1,50,
-	106,137,205,158,139,237,56,52,246,6,237,57,
-	52,175,183,251,201,33,234,151,35,35,62,255,
-	119,193,225,62,1,50,106,137,205,158,139,237,
-	56,52,246,6,237,57,52,175,251,201,243,61,
-	32,253,251,201,62,3,211,66,62,192,211,66,
-	58,49,152,254,140,32,19,197,229,213,17,181,
-	129,33,185,129,1,2,0,237,176,209,225,193,
-	24,27,229,213,33,187,129,58,49,152,230,15,
-	87,30,2,237,92,25,17,181,129,126,18,19,
-	35,126,18,209,225,58,34,152,246,8,211,68,
-	58,49,152,254,165,40,14,254,164,40,10,62,
-	10,211,66,62,224,211,66,24,25,58,74,152,
-	254,0,40,10,62,10,211,66,62,160,211,66,
-	24,8,62,10,211,66,62,128,211,66,62,11,
-	211,66,62,6,211,66,205,147,143,62,5,211,
-	66,62,224,211,66,62,5,211,66,62,96,211,
-	66,62,5,61,32,253,62,5,211,66,62,224,
-	211,66,62,14,61,32,253,62,5,211,66,62,
-	233,211,66,62,128,211,66,58,181,129,61,32,
-	253,62,1,211,66,62,192,211,66,1,254,19,
-	237,56,46,187,32,6,13,32,247,195,226,134,
-	62,192,211,66,0,0,219,66,203,119,40,250,
-	219,66,203,87,40,250,243,237,56,16,230,17,
-	237,57,16,237,56,20,251,62,5,211,66,62,
-	224,211,66,58,182,129,61,32,253,229,33,181,
-	129,58,183,129,203,63,119,35,58,184,129,119,
-	225,62,10,211,66,62,224,211,66,62,11,211,
-	66,62,118,211,66,62,47,211,68,62,5,211,
-	66,62,233,211,66,58,181,129,61,32,253,62,
-	5,211,66,62,224,211,66,58,182,129,61,32,
-	253,62,5,211,66,62,96,211,66,201,229,213,
-	58,50,152,230,15,87,30,2,237,92,33,187,
-	129,25,17,181,129,126,18,35,19,126,18,209,
-	225,58,71,152,246,8,211,68,58,50,152,254,
-	165,40,14,254,164,40,10,62,10,211,66,62,
-	224,211,66,24,8,62,10,211,66,62,128,211,
-	66,62,11,211,66,62,6,211,66,195,248,135,
-	62,3,211,66,62,192,211,66,197,229,213,17,
-	181,129,33,183,129,1,2,0,237,176,209,225,
-	193,62,47,211,68,62,10,211,66,62,224,211,
-	66,62,11,211,66,62,118,211,66,62,1,211,
-	66,62,0,211,66,205,147,143,195,16,136,62,
-	3,211,66,62,192,211,66,197,229,213,17,181,
-	129,33,183,129,1,2,0,237,176,209,225,193,
-	62,47,211,68,62,10,211,66,62,224,211,66,
-	62,11,211,66,62,118,211,66,205,147,143,62,
-	5,211,66,62,224,211,66,62,5,211,66,62,
-	96,211,66,62,5,61,32,253,62,5,211,66,
-	62,224,211,66,62,14,61,32,253,62,5,211,
-	66,62,233,211,66,62,128,211,66,58,181,129,
-	61,32,253,62,1,211,66,62,192,211,66,1,
-	254,19,237,56,46,187,32,6,13,32,247,195,
-	88,136,62,192,211,66,0,0,219,66,203,119,
-	40,250,219,66,203,87,40,250,62,5,211,66,
-	62,224,211,66,58,182,129,61,32,253,62,5,
-	211,66,62,96,211,66,201,197,14,67,6,0,
-	62,3,211,66,62,192,211,66,62,48,211,66,
-	0,0,219,66,230,1,40,4,219,67,24,240,
-	62,5,211,66,62,233,211,66,62,128,211,66,
-	58,181,129,61,32,253,237,163,29,62,192,211,
-	66,219,66,230,4,40,250,237,163,29,32,245,
-	219,66,230,4,40,250,62,255,71,219,66,230,
-	4,40,3,5,32,247,219,66,230,4,40,250,
-	62,5,211,66,62,224,211,66,58,182,129,61,
-	32,253,62,5,211,66,62,96,211,66,58,71,
-	152,254,1,202,18,137,62,16,211,66,62,56,
-	211,66,62,14,211,66,62,33,211,66,62,1,
-	211,66,62,248,211,66,237,56,48,246,153,230,
-	207,237,57,48,62,3,211,66,62,221,211,66,
-	193,201,58,71,152,211,68,62,10,211,66,62,
-	128,211,66,62,11,211,66,62,6,211,66,62,
-	6,211,66,58,44,152,211,66,62,16,211,66,
-	62,56,211,66,62,48,211,66,0,0,62,14,
-	211,66,62,33,211,66,62,1,211,66,62,248,
-	211,66,237,56,48,246,145,246,8,230,207,237,
-	57,48,62,3,211,66,62,221,211,66,193,201,
-	44,3,1,0,70,69,1,245,197,213,229,175,
-	50,72,152,237,56,16,230,46,237,57,16,237,
-	56,12,62,1,211,66,0,0,219,66,95,230,
-	160,32,3,195,20,139,123,230,96,194,72,139,
-	62,48,211,66,62,1,211,66,62,64,211,66,
-	237,91,40,152,205,207,143,25,43,55,237,82,
-	218,70,139,34,42,152,98,107,58,44,152,190,
-	194,210,138,35,35,62,130,190,194,200,137,62,
-	1,50,48,152,62,175,190,202,82,139,62,132,
-	190,32,44,50,50,152,62,47,50,71,152,229,
-	175,50,106,137,42,40,152,205,65,143,225,54,
-	133,43,70,58,44,152,119,43,112,17,3,0,
-	62,10,205,2,134,205,111,136,195,158,138,62,
-	140,190,32,19,50,50,152,58,233,149,230,4,
-	202,222,138,62,1,50,71,152,195,219,137,126,
-	254,160,250,185,138,254,166,242,185,138,50,50,
-	152,43,126,35,229,213,33,234,149,95,22,0,
-	25,126,254,132,40,18,254,140,40,14,58,50,
-	152,230,15,87,126,31,21,242,65,138,56,2,
-	175,119,58,50,152,230,15,87,58,233,149,230,
-	62,31,21,242,85,138,218,98,138,209,225,195,
-	20,139,58,50,152,33,100,137,230,15,95,22,
-	0,25,126,50,71,152,209,225,58,50,152,254,
-	164,250,135,138,58,73,152,254,0,40,4,54,
-	173,24,2,54,133,43,70,58,44,152,119,43,
-	112,17,3,0,205,70,135,175,50,106,137,205,
-	208,139,58,199,129,237,57,12,58,200,129,237,
-	57,13,237,56,16,246,17,237,57,16,225,209,
-	193,241,251,237,77,62,129,190,194,227,138,54,
-	130,43,70,58,44,152,119,43,112,17,3,0,
-	205,144,135,195,20,139,35,35,126,254,132,194,
-	227,138,175,50,106,137,205,158,139,24,42,58,
-	201,154,254,1,40,7,62,1,50,106,137,24,
-	237,58,106,137,254,1,202,222,138,62,128,166,
-	194,222,138,221,229,221,33,67,152,205,127,142,
-	205,109,144,221,225,225,209,193,241,251,237,77,
-	58,106,137,254,1,202,44,139,58,50,152,254,
-	164,250,44,139,58,73,152,238,1,50,73,152,
-	221,229,221,33,51,152,205,127,142,221,225,62,
-	1,50,106,137,205,158,139,195,13,139,24,208,
-	24,206,24,204,230,64,40,3,195,20,139,195,
-	20,139,43,126,33,8,152,119,35,58,44,152,
-	119,43,237,91,35,152,205,203,135,205,158,139,
-	195,13,139,175,50,78,152,62,3,211,66,62,
-	192,211,66,201,197,33,4,0,57,126,35,102,
-	111,62,1,50,106,137,219,72,205,141,139,193,
-	201,62,1,50,78,152,34,40,152,54,0,35,
-	35,54,0,195,163,139,58,78,152,183,200,229,
-	33,181,129,58,183,129,119,35,58,184,129,119,
-	225,62,47,211,68,62,14,211,66,62,193,211,
-	66,62,10,211,66,62,224,211,66,62,11,211,
-	66,62,118,211,66,195,3,140,58,78,152,183,
-	200,58,71,152,211,68,254,69,40,4,254,70,
-	32,17,58,73,152,254,0,40,10,62,10,211,
-	66,62,160,211,66,24,8,62,10,211,66,62,
-	128,211,66,62,11,211,66,62,6,211,66,62,
-	6,211,66,58,44,152,211,66,62,16,211,66,
-	62,56,211,66,62,48,211,66,0,0,219,66,
-	230,1,40,4,219,67,24,240,62,14,211,66,
-	62,33,211,66,42,40,152,205,65,143,62,1,
-	211,66,62,248,211,66,237,56,48,246,145,246,
-	8,230,207,237,57,48,62,3,211,66,62,221,
-	211,66,201,62,16,211,66,62,56,211,66,62,
-	48,211,66,0,0,219,66,230,1,40,4,219,
-	67,24,240,62,14,211,66,62,33,211,66,62,
-	1,211,66,62,248,211,66,237,56,48,246,153,
-	230,207,237,57,48,62,3,211,66,62,221,211,
-	66,201,229,213,33,234,149,95,22,0,25,126,
-	254,132,40,4,254,140,32,2,175,119,123,209,
-	225,201,6,8,14,0,31,48,1,12,16,250,
-	121,201,33,4,0,57,94,35,86,33,2,0,
-	57,126,35,102,111,221,229,34,89,152,237,83,
-	91,152,221,33,63,152,205,127,142,58,81,152,
-	50,82,152,58,80,152,135,50,80,152,205,162,
-	140,254,3,56,16,58,81,152,135,60,230,15,
-	50,81,152,175,50,80,152,24,23,58,79,152,
-	205,162,140,254,3,48,13,58,81,152,203,63,
-	50,81,152,62,255,50,79,152,58,81,152,50,
-	82,152,58,79,152,135,50,79,152,62,32,50,
-	83,152,50,84,152,237,56,16,230,17,237,57,
-	16,219,72,62,192,50,93,152,62,93,50,94,
-	152,58,93,152,61,50,93,152,32,9,58,94,
-	152,61,50,94,152,40,44,62,170,237,57,20,
-	175,237,57,21,237,56,16,246,2,237,57,16,
-	219,72,230,1,202,29,141,237,56,20,71,237,
-	56,21,120,254,10,48,237,237,56,16,230,17,
-	237,57,16,243,62,14,211,66,62,65,211,66,
-	251,58,39,152,23,23,60,50,39,152,71,58,
-	82,152,160,230,15,40,22,71,14,10,219,66,
-	230,16,202,186,141,219,72,230,1,202,186,141,
-	13,32,239,16,235,42,89,152,237,91,91,152,
-	205,47,131,48,7,61,202,186,141,195,227,141,
-	221,225,33,0,0,201,221,33,55,152,205,127,
-	142,58,84,152,61,50,84,152,40,19,58,82,
-	152,246,1,50,82,152,58,79,152,246,1,50,
-	79,152,195,29,141,221,225,33,1,0,201,221,
-	33,59,152,205,127,142,58,80,152,246,1,50,
-	80,152,58,82,152,135,246,1,50,82,152,58,
-	83,152,61,50,83,152,194,29,141,221,225,33,
-	2,0,201,221,229,33,0,0,57,17,4,0,
-	25,126,50,44,152,230,128,50,85,152,58,85,
-	152,183,40,6,221,33,88,2,24,4,221,33,
-	150,0,58,44,152,183,40,53,60,40,50,60,
-	40,47,61,61,33,86,152,119,35,119,35,54,
-	129,175,50,48,152,221,43,221,229,225,124,181,
-	40,42,33,86,152,17,3,0,205,189,140,17,
-	232,3,27,123,178,32,251,58,48,152,183,40,
-	224,58,44,152,71,62,7,128,230,127,71,58,
-	85,152,176,50,44,152,24,162,221,225,201,183,
-	221,52,0,192,221,52,1,192,221,52,2,192,
-	221,52,3,192,55,201,245,62,1,211,100,241,
-	201,245,62,1,211,96,241,201,33,2,0,57,
-	126,35,102,111,237,56,48,230,175,237,57,48,
-	62,48,237,57,49,125,237,57,32,124,237,57,
-	33,62,0,237,57,34,62,88,237,57,35,62,
-	0,237,57,36,237,57,37,33,128,2,125,237,
-	57,38,124,237,57,39,237,56,48,246,97,230,
-	207,237,57,48,62,0,237,57,0,62,0,211,
-	96,211,100,201,33,2,0,57,126,35,102,111,
-	237,56,48,230,175,237,57,48,62,12,237,57,
-	49,62,76,237,57,32,62,0,237,57,33,237,
-	57,34,125,237,57,35,124,237,57,36,62,0,
-	237,57,37,33,128,2,125,237,57,38,124,237,
-	57,39,237,56,48,246,97,230,207,237,57,48,
-	62,1,211,96,201,33,2,0,57,126,35,102,
-	111,229,237,56,48,230,87,237,57,48,125,237,
-	57,40,124,237,57,41,62,0,237,57,42,62,
-	67,237,57,43,62,0,237,57,44,58,106,137,
-	254,1,32,5,33,6,0,24,3,33,128,2,
-	125,237,57,46,124,237,57,47,237,56,50,230,
-	252,246,2,237,57,50,225,201,33,4,0,57,
-	94,35,86,33,2,0,57,126,35,102,111,237,
-	56,48,230,87,237,57,48,125,237,57,40,124,
-	237,57,41,62,0,237,57,42,62,67,237,57,
-	43,62,0,237,57,44,123,237,57,46,122,237,
-	57,47,237,56,50,230,244,246,0,237,57,50,
-	237,56,48,246,145,230,207,237,57,48,201,213,
-	237,56,46,95,237,56,47,87,237,56,46,111,
-	237,56,47,103,183,237,82,32,235,33,128,2,
-	183,237,82,209,201,213,237,56,38,95,237,56,
-	39,87,237,56,38,111,237,56,39,103,183,237,
-	82,32,235,33,128,2,183,237,82,209,201,245,
-	197,1,52,0,237,120,230,253,237,121,193,241,
-	201,245,197,1,52,0,237,120,246,2,237,121,
-	193,241,201,33,2,0,57,126,35,102,111,126,
-	35,110,103,201,33,0,0,34,102,152,34,96,
-	152,34,98,152,33,202,154,34,104,152,237,91,
-	104,152,42,226,149,183,237,82,17,0,255,25,
-	34,100,152,203,124,40,6,33,0,125,34,100,
-	152,42,104,152,35,35,35,229,205,120,139,193,
-	201,205,186,149,229,42,40,152,35,35,35,229,
-	205,39,144,193,124,230,3,103,221,117,254,221,
-	116,255,237,91,42,152,35,35,35,183,237,82,
-	32,12,17,5,0,42,42,152,205,171,149,242,
-	169,144,42,40,152,229,205,120,139,193,195,198,
-	149,237,91,42,152,42,98,152,25,34,98,152,
-	19,19,19,42,102,152,25,34,102,152,237,91,
-	100,152,33,158,253,25,237,91,102,152,205,171,
-	149,242,214,144,33,0,0,34,102,152,62,1,
-	50,95,152,205,225,144,195,198,149,58,95,152,
-	183,200,237,91,96,152,42,102,152,205,171,149,
-	242,5,145,237,91,102,152,33,98,2,25,237,
-	91,96,152,205,171,149,250,37,145,237,91,96,
-	152,42,102,152,183,237,82,32,7,42,98,152,
-	125,180,40,13,237,91,102,152,42,96,152,205,
-	171,149,242,58,145,237,91,104,152,42,102,152,
-	25,35,35,35,229,205,120,139,193,175,50,95,
-	152,201,195,107,139,205,206,149,250,255,243,205,
-	225,144,251,58,230,149,183,194,198,149,17,1,
-	0,42,98,152,205,171,149,250,198,149,62,1,
-	50,230,149,237,91,96,152,42,104,152,25,221,
-	117,252,221,116,253,237,91,104,152,42,96,152,
-	25,35,35,35,221,117,254,221,116,255,35,35,
-	35,229,205,39,144,124,230,3,103,35,35,35,
-	221,117,250,221,116,251,235,221,110,252,221,102,
-	253,115,35,114,35,54,4,62,1,211,100,211,
-	84,195,198,149,33,0,0,34,102,152,34,96,
-	152,34,98,152,33,202,154,34,104,152,237,91,
-	104,152,42,226,149,183,237,82,17,0,255,25,
-	34,100,152,33,109,152,54,0,33,107,152,229,
-	205,240,142,193,62,47,50,34,152,62,132,50,
-	49,152,205,241,145,205,61,145,58,39,152,60,
-	50,39,152,24,241,205,206,149,251,255,33,109,
-	152,126,183,202,198,149,110,221,117,251,33,109,
-	152,54,0,221,126,251,254,1,40,28,254,3,
-	40,101,254,4,202,190,147,254,5,202,147,147,
-	254,8,40,87,33,107,152,229,205,240,142,195,
-	198,149,58,201,154,183,32,21,33,111,152,126,
-	50,229,149,205,52,144,33,110,152,110,38,0,
-	229,205,11,142,193,237,91,96,152,42,104,152,
-	25,221,117,254,221,116,255,35,35,54,2,17,
-	2,0,43,43,115,35,114,58,44,152,35,35,
-	119,58,228,149,35,119,62,1,211,100,211,84,
-	62,1,50,201,154,24,169,205,153,142,58,231,
-	149,183,40,250,175,50,231,149,33,110,152,126,
-	254,255,40,91,58,233,149,230,63,183,40,83,
-	94,22,0,33,234,149,25,126,183,40,13,33,
-	110,152,94,33,234,150,25,126,254,3,32,36,
-	205,81,148,125,180,33,110,152,94,22,0,40,
-	17,33,234,149,25,54,0,33,107,152,229,205,
-	240,142,193,195,198,149,33,234,150,25,54,0,
-	33,110,152,94,22,0,33,234,149,25,126,50,
-	49,152,254,132,32,37,62,47,50,34,152,42,
-	107,152,229,33,110,152,229,205,174,140,193,193,
-	125,180,33,110,152,94,22,0,33,234,150,202,
-	117,147,25,52,195,120,147,58,49,152,254,140,
-	32,7,62,1,50,34,152,24,210,62,32,50,
-	106,152,24,19,58,49,152,95,58,106,152,163,
-	183,58,106,152,32,11,203,63,50,106,152,58,
-	106,152,183,32,231,254,2,40,51,254,4,40,
-	38,254,8,40,26,254,16,40,13,254,32,32,
-	158,62,165,50,49,152,62,69,24,190,62,164,
-	50,49,152,62,70,24,181,62,163,50,49,152,
-	175,24,173,62,162,50,49,152,62,1,24,164,
-	62,161,50,49,152,62,3,24,155,25,54,0,
-	221,126,251,254,8,40,7,58,230,149,183,202,
-	32,146,33,107,152,229,205,240,142,193,211,84,
-	195,198,149,237,91,96,152,42,104,152,25,221,
-	117,254,221,116,255,35,35,54,6,17,2,0,
-	43,43,115,35,114,58,228,149,35,35,119,58,
-	233,149,35,119,205,146,142,195,32,146,237,91,
-	96,152,42,104,152,25,229,205,160,142,193,58,
-	231,149,183,40,250,175,50,231,149,243,237,91,
-	96,152,42,104,152,25,221,117,254,221,116,255,
-	78,35,70,221,113,252,221,112,253,89,80,42,
-	98,152,183,237,82,34,98,152,203,124,40,19,
-	33,0,0,34,98,152,34,102,152,34,96,152,
-	62,1,50,95,152,24,40,221,94,252,221,86,
-	253,19,19,19,42,96,152,25,34,96,152,237,
-	91,100,152,33,158,253,25,237,91,96,152,205,
-	171,149,242,55,148,33,0,0,34,96,152,175,
-	50,230,149,251,195,32,146,245,62,1,50,231,
-	149,62,16,237,57,0,211,80,241,251,237,77,
-	201,205,186,149,229,229,33,0,0,34,37,152,
-	33,110,152,126,50,234,151,58,44,152,33,235,
-	151,119,221,54,253,0,221,54,254,0,195,230,
-	148,33,236,151,54,175,33,3,0,229,33,234,
-	151,229,205,174,140,193,193,33,236,151,126,254,
-	255,40,74,33,245,151,110,221,117,255,33,249,
-	151,126,221,166,255,221,119,255,33,253,151,126,
-	221,166,255,221,119,255,58,232,149,95,221,126,
-	255,163,221,119,255,183,40,15,230,191,33,110,
-	152,94,22,0,33,234,149,25,119,24,12,33,
-	110,152,94,22,0,33,234,149,25,54,132,33,
-	0,0,195,198,149,221,110,253,221,102,254,35,
-	221,117,253,221,116,254,17,32,0,221,110,253,
-	221,102,254,205,171,149,250,117,148,58,233,149,
-	203,87,40,84,33,1,0,34,37,152,221,54,
-	253,0,221,54,254,0,24,53,33,236,151,54,
-	175,33,3,0,229,33,234,151,229,205,174,140,
-	193,193,33,236,151,126,254,255,40,14,33,110,
-	152,94,22,0,33,234,149,25,54,140,24,159,
-	221,110,253,221,102,254,35,221,117,253,221,116,
-	254,17,32,0,221,110,253,221,102,254,205,171,
-	149,250,12,149,33,2,0,34,37,152,221,54,
-	253,0,221,54,254,0,24,54,33,236,151,54,
-	175,33,3,0,229,33,234,151,229,205,174,140,
-	193,193,33,236,151,126,254,255,40,15,33,110,
-	152,94,22,0,33,234,149,25,54,132,195,211,
-	148,221,110,253,221,102,254,35,221,117,253,221,
-	116,254,17,32,0,221,110,253,221,102,254,205,
-	171,149,250,96,149,33,1,0,195,198,149,124,
-	170,250,179,149,237,82,201,124,230,128,237,82,
-	60,201,225,253,229,221,229,221,33,0,0,221,
-	57,233,221,249,221,225,253,225,201,233,225,253,
-	229,221,229,221,33,0,0,221,57,94,35,86,
-	35,235,57,249,235,233,0,0,0,0,0,0,
-	62,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	175,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,133,1,0,0,0,63,
-	255,255,255,255,0,0,0,63,0,0,0,0,
-	0,0,0,0,0,0,0,24,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0
-	} ;
-
-#endif
diff -ruN ../linux-4.14.336/drivers/net/appletalk/cops_ltdrv.h ./drivers/net/appletalk/cops_ltdrv.h
--- linux-4.14.336/../linux-4.14.336/drivers/net/appletalk/cops_ltdrv.h	2024-01-10 14:45:41.000000000 +0100
+++ linux-4.14.336/./drivers/net/appletalk/cops_ltdrv.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,241 +0,0 @@
-/*
- *	The firmware this driver downloads into the Localtalk card is a
- *	separate program and is not GPL'd source code, even though the Linux
- *	side driver and the routine that loads this data into the card are.
- *	
- *	It is taken from the COPS SDK and is under the following license
- *
- *	This material is licensed to you strictly for use in conjunction with
- *	the use of COPS LocalTalk adapters.
- *	There is no charge for this SDK. And no waranty express or implied
- *	about its fitness for any purpose. However, we will cheerefully
- *	refund every penny you paid for this SDK...
- *	Regards,
- *
- *	Thomas F. Divine
- *	Chief Scientist
- */
-
-
-/*      cops_ltdrv.h: LocalTalk driver firmware dump for Linux.
- *
- *      Authors:
- *      - Jay Schulist <jschlst@samba.org>
- */
- 
-
-#ifdef CONFIG_COPS_TANGENT
-
-static const unsigned char ltdrv_code[] = {
-	58,3,0,50,148,10,33,143,15,62,85,119,
-	190,32,9,62,170,119,190,32,3,35,24,241,
-	34,146,10,249,17,150,10,33,143,15,183,237,
-	82,77,68,11,107,98,19,54,0,237,176,62,
-	16,237,57,51,62,0,237,57,50,237,57,54,
-	62,12,237,57,49,62,195,33,39,2,50,56,
-	0,34,57,0,237,86,205,30,2,251,205,60,
-	10,24,169,67,111,112,121,114,105,103,104,116,
-	32,40,99,41,32,49,57,56,56,45,49,57,
-	57,50,44,32,80,114,105,110,116,105,110,103,
-	32,67,111,109,109,117,110,105,99,97,116,105,
-	111,110,115,32,65,115,115,111,99,105,97,116,
-	101,115,44,32,73,110,99,46,65,108,108,32,
-	114,105,103,104,116,115,32,114,101,115,101,114,
-	118,101,100,46,32,32,4,4,22,40,255,60,
-	4,96,10,224,6,0,7,126,2,64,11,246,
-	12,6,13,0,14,193,15,0,5,96,3,192,
-	1,0,9,8,62,3,211,82,62,192,211,82,
-	201,62,3,211,82,62,213,211,82,201,62,5,
-	211,82,62,224,211,82,201,62,5,211,82,62,
-	224,211,82,201,62,5,211,82,62,96,211,82,
-	201,6,28,33,180,1,14,82,237,163,194,4,
-	2,33,39,2,34,64,0,58,3,0,230,1,
-	192,62,11,237,121,62,118,237,121,201,33,182,
-	10,54,132,205,253,1,201,245,197,213,229,42,
-	150,10,14,83,17,98,2,67,20,237,162,58,
-	179,1,95,219,82,230,1,32,6,29,32,247,
-	195,17,3,62,1,211,82,219,82,95,230,160,
-	32,10,237,162,32,225,21,32,222,195,15,3,
-	237,162,123,230,96,194,21,3,62,48,211,82,
-	62,1,211,82,175,211,82,237,91,150,10,43,
-	55,237,82,218,19,3,34,152,10,98,107,58,
-	154,10,190,32,81,62,1,50,158,10,35,35,
-	62,132,190,32,44,54,133,43,70,58,154,10,
-	119,43,112,17,3,0,205,137,3,62,16,211,
-	82,62,56,211,82,205,217,1,42,150,10,14,
-	83,17,98,2,67,20,58,178,1,95,195,59,
-	2,62,129,190,194,227,2,54,130,43,70,58,
-	154,10,119,43,112,17,3,0,205,137,3,195,
-	254,2,35,35,126,254,132,194,227,2,205,61,
-	3,24,20,62,128,166,194,222,2,221,229,221,
-	33,175,10,205,93,6,205,144,7,221,225,225,
-	209,193,241,251,237,77,221,229,221,33,159,10,
-	205,93,6,221,225,205,61,3,195,247,2,24,
-	237,24,235,24,233,230,64,40,2,24,227,24,
-	225,175,50,179,10,205,208,1,201,197,33,4,
-	0,57,126,35,102,111,205,51,3,193,201,62,
-	1,50,179,10,34,150,10,54,0,58,179,10,
-	183,200,62,14,211,82,62,193,211,82,62,10,
-	211,82,62,224,211,82,62,6,211,82,58,154,
-	10,211,82,62,16,211,82,62,56,211,82,62,
-	48,211,82,219,82,230,1,40,4,219,83,24,
-	242,62,14,211,82,62,33,211,82,62,1,211,
-	82,62,9,211,82,62,32,211,82,205,217,1,
-	201,14,83,205,208,1,24,23,14,83,205,208,
-	1,205,226,1,58,174,1,61,32,253,205,244,
-	1,58,174,1,61,32,253,205,226,1,58,175,
-	1,61,32,253,62,5,211,82,62,233,211,82,
-	62,128,211,82,58,176,1,61,32,253,237,163,
-	27,62,192,211,82,219,82,230,4,40,250,237,
-	163,27,122,179,32,243,219,82,230,4,40,250,
-	58,178,1,71,219,82,230,4,40,3,5,32,
-	247,219,82,230,4,40,250,205,235,1,58,177,
-	1,61,32,253,205,244,1,201,229,213,35,35,
-	126,230,128,194,145,4,43,58,154,10,119,43,
-	70,33,181,10,119,43,112,17,3,0,243,62,
-	10,211,82,219,82,230,128,202,41,4,209,225,
-	62,1,55,251,201,205,144,3,58,180,10,254,
-	255,202,127,4,205,217,1,58,178,1,71,219,
-	82,230,1,32,6,5,32,247,195,173,4,219,
-	83,71,58,154,10,184,194,173,4,58,178,1,
-	71,219,82,230,1,32,6,5,32,247,195,173,
-	4,219,83,58,178,1,71,219,82,230,1,32,
-	6,5,32,247,195,173,4,219,83,254,133,194,
-	173,4,58,179,1,24,4,58,179,1,135,61,
-	32,253,209,225,205,137,3,205,61,3,183,251,
-	201,209,225,243,62,10,211,82,219,82,230,128,
-	202,164,4,62,1,55,251,201,205,144,3,205,
-	61,3,183,251,201,209,225,62,2,55,251,201,
-	243,62,14,211,82,62,33,211,82,251,201,33,
-	4,0,57,94,35,86,33,2,0,57,126,35,
-	102,111,221,229,34,193,10,237,83,195,10,221,
-	33,171,10,205,93,6,58,185,10,50,186,10,
-	58,184,10,135,50,184,10,205,112,6,254,3,
-	56,16,58,185,10,135,60,230,15,50,185,10,
-	175,50,184,10,24,23,58,183,10,205,112,6,
-	254,3,48,13,58,185,10,203,63,50,185,10,
-	62,255,50,183,10,58,185,10,50,186,10,58,
-	183,10,135,50,183,10,62,32,50,187,10,50,
-	188,10,6,255,219,82,230,16,32,3,5,32,
-	247,205,180,4,6,40,219,82,230,16,40,3,
-	5,32,247,62,10,211,82,219,82,230,128,194,
-	46,5,219,82,230,16,40,214,237,95,71,58,
-	186,10,160,230,15,40,32,71,14,10,62,10,
-	211,82,219,82,230,128,202,119,5,205,180,4,
-	195,156,5,219,82,230,16,202,156,5,13,32,
-	229,16,225,42,193,10,237,91,195,10,205,252,
-	3,48,7,61,202,156,5,195,197,5,221,225,
-	33,0,0,201,221,33,163,10,205,93,6,58,
-	188,10,61,50,188,10,40,19,58,186,10,246,
-	1,50,186,10,58,183,10,246,1,50,183,10,
-	195,46,5,221,225,33,1,0,201,221,33,167,
-	10,205,93,6,58,184,10,246,1,50,184,10,
-	58,186,10,135,246,1,50,186,10,58,187,10,
-	61,50,187,10,194,46,5,221,225,33,2,0,
-	201,221,229,33,0,0,57,17,4,0,25,126,
-	50,154,10,230,128,50,189,10,58,189,10,183,
-	40,6,221,33,88,2,24,4,221,33,150,0,
-	58,154,10,183,40,49,60,40,46,61,33,190,
-	10,119,35,119,35,54,129,175,50,158,10,221,
-	43,221,229,225,124,181,40,42,33,190,10,17,
-	3,0,205,206,4,17,232,3,27,123,178,32,
-	251,58,158,10,183,40,224,58,154,10,71,62,
-	7,128,230,127,71,58,189,10,176,50,154,10,
-	24,166,221,225,201,183,221,52,0,192,221,52,
-	1,192,221,52,2,192,221,52,3,192,55,201,
-	6,8,14,0,31,48,1,12,16,250,121,201,
-	33,2,0,57,94,35,86,35,78,35,70,35,
-	126,35,102,105,79,120,68,103,237,176,201,33,
-	2,0,57,126,35,102,111,62,17,237,57,48,
-	125,237,57,40,124,237,57,41,62,0,237,57,
-	42,62,64,237,57,43,62,0,237,57,44,33,
-	128,2,125,237,57,46,124,237,57,47,62,145,
-	237,57,48,211,68,58,149,10,211,66,201,33,
-	2,0,57,126,35,102,111,62,33,237,57,48,
-	62,64,237,57,32,62,0,237,57,33,237,57,
-	34,125,237,57,35,124,237,57,36,62,0,237,
-	57,37,33,128,2,125,237,57,38,124,237,57,
-	39,62,97,237,57,48,211,67,58,149,10,211,
-	66,201,237,56,46,95,237,56,47,87,237,56,
-	46,111,237,56,47,103,183,237,82,32,235,33,
-	128,2,183,237,82,201,237,56,38,95,237,56,
-	39,87,237,56,38,111,237,56,39,103,183,237,
-	82,32,235,33,128,2,183,237,82,201,205,106,
-	10,221,110,6,221,102,7,126,35,110,103,195,
-	118,10,205,106,10,33,0,0,34,205,10,34,
-	198,10,34,200,10,33,143,15,34,207,10,237,
-	91,207,10,42,146,10,183,237,82,17,0,255,
-	25,34,203,10,203,124,40,6,33,0,125,34,
-	203,10,42,207,10,229,205,37,3,195,118,10,
-	205,106,10,229,42,150,10,35,35,35,229,205,
-	70,7,193,124,230,3,103,221,117,254,221,116,
-	255,237,91,152,10,35,35,35,183,237,82,32,
-	12,17,5,0,42,152,10,205,91,10,242,203,
-	7,42,150,10,229,205,37,3,195,118,10,237,
-	91,152,10,42,200,10,25,34,200,10,42,205,
-	10,25,34,205,10,237,91,203,10,33,158,253,
-	25,237,91,205,10,205,91,10,242,245,7,33,
-	0,0,34,205,10,62,1,50,197,10,205,5,
-	8,33,0,0,57,249,195,118,10,205,106,10,
-	58,197,10,183,202,118,10,237,91,198,10,42,
-	205,10,205,91,10,242,46,8,237,91,205,10,
-	33,98,2,25,237,91,198,10,205,91,10,250,
-	78,8,237,91,198,10,42,205,10,183,237,82,
-	32,7,42,200,10,125,180,40,13,237,91,205,
-	10,42,198,10,205,91,10,242,97,8,237,91,
-	207,10,42,205,10,25,229,205,37,3,175,50,
-	197,10,195,118,10,205,29,3,33,0,0,57,
-	249,195,118,10,205,106,10,58,202,10,183,40,
-	22,205,14,7,237,91,209,10,19,19,19,205,
-	91,10,242,139,8,33,1,0,195,118,10,33,
-	0,0,195,118,10,205,126,10,252,255,205,108,
-	8,125,180,194,118,10,237,91,200,10,33,0,
-	0,205,91,10,242,118,10,237,91,207,10,42,
-	198,10,25,221,117,254,221,116,255,35,35,35,
-	229,205,70,7,193,124,230,3,103,35,35,35,
-	221,117,252,221,116,253,229,221,110,254,221,102,
-	255,229,33,212,10,229,205,124,6,193,193,221,
-	110,252,221,102,253,34,209,10,33,211,10,54,
-	4,33,209,10,227,205,147,6,193,62,1,50,
-	202,10,243,221,94,252,221,86,253,42,200,10,
-	183,237,82,34,200,10,203,124,40,17,33,0,
-	0,34,200,10,34,205,10,34,198,10,50,197,
-	10,24,37,221,94,252,221,86,253,42,198,10,
-	25,34,198,10,237,91,203,10,33,158,253,25,
-	237,91,198,10,205,91,10,242,68,9,33,0,
-	0,34,198,10,205,5,8,33,0,0,57,249,
-	251,195,118,10,205,106,10,33,49,13,126,183,
-	40,16,205,42,7,237,91,47,13,19,19,19,
-	205,91,10,242,117,9,58,142,15,198,1,50,
-	142,15,195,118,10,33,49,13,126,254,1,40,
-	25,254,3,202,7,10,254,5,202,21,10,33,
-	49,13,54,0,33,47,13,229,205,207,6,195,
-	118,10,58,141,15,183,32,72,33,51,13,126,
-	50,149,10,205,86,7,33,50,13,126,230,127,
-	183,32,40,58,142,15,230,127,50,142,15,183,
-	32,5,198,1,50,142,15,33,50,13,126,111,
-	23,159,103,203,125,58,142,15,40,5,198,128,
-	50,142,15,33,50,13,119,33,50,13,126,111,
-	23,159,103,229,205,237,5,193,33,211,10,54,
-	2,33,2,0,34,209,10,58,154,10,33,212,
-	10,119,58,148,10,33,213,10,119,33,209,10,
-	229,205,147,6,193,24,128,42,47,13,229,33,
-	50,13,229,205,191,4,193,24,239,33,211,10,
-	54,6,33,3,0,34,209,10,58,154,10,33,
-	212,10,119,58,148,10,33,213,10,119,33,214,
-	10,54,5,33,209,10,229,205,147,6,24,200,
-	205,106,10,33,49,13,54,0,33,47,13,229,
-	205,207,6,33,209,10,227,205,147,6,193,205,
-	80,9,205,145,8,24,248,124,170,250,99,10,
-	237,82,201,124,230,128,237,82,60,201,225,253,
-	229,221,229,221,33,0,0,221,57,233,221,249,
-	221,225,253,225,201,233,225,253,229,221,229,221,
-	33,0,0,221,57,94,35,86,35,235,57,249,
-	235,233,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,0,0,0,0,0,0,
-	0,0,0,0,0
-	} ;
-
-#endif
