diff -r -u musl-1.1.24.orig/arch/i386/pthread_arch.h musl-1.1.24/arch/i386/pthread_arch.h
--- arch/i386/pthread_arch.h	2019-10-13 21:58:27.000000000 +0000
+++ arch/i386/pthread_arch.h	2023-02-28 14:06:10.700603762 +0000
@@ -1,8 +1,18 @@
+#define BOOTSTRAP
+
+#ifdef BOOTSTRAP
+extern pthread_t g_pthread;
+#endif
+
 static inline struct pthread *__pthread_self()
 {
+#ifndef BOOTSTRAP
 	struct pthread *self;
 	__asm__ ("movl %%gs:0,%0" : "=r" (self) );
 	return self;
+#else
+	return g_pthread;
+#endif
 }
 
 #define TP_ADJ(p) (p)
diff -r -u musl-1.1.24.orig/src/env/__init_tls.c musl-1.1.24/src/env/__init_tls.c
--- src/env/__init_tls.c	2019-10-13 21:58:27.000000000 +0000
+++ src/env/__init_tls.c	2023-02-28 14:07:04.956604831 +0000
@@ -8,22 +8,31 @@
 #include "libc.h"
 #include "atomic.h"
 #include "syscall.h"
+#define BOOTSTRAP
 
 volatile int __thread_list_lock;
+#ifdef BOOTSTRAP
+pthread_t g_pthread;
+#endif
 
 int __init_tp(void *p)
 {
 	pthread_t td = p;
 	td->self = td;
+#ifndef BOOTSTRAP
 	int r = __set_thread_area(TP_ADJ(p));
 	if (r < 0) return -1;
 	if (!r) libc.can_do_threads = 1;
+#endif
 	td->detach_state = DT_JOINABLE;
 	td->tid = __syscall(SYS_set_tid_address, &__thread_list_lock);
 	td->locale = &libc.global_locale;
 	td->robust_list.head = &td->robust_list.head;
 	td->sysinfo = __sysinfo;
 	td->next = td->prev = td;
+#ifdef BOOTSTRAP
+	g_pthread = td;
+#endif
 	return 0;
 }
 
